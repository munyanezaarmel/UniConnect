/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ical.js";
exports.ids = ["vendor-chunks/ical.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/ical.js/build/ical.js":
/*!********************************************!*\
  !*** ./node_modules/ical.js/build/ical.js ***!
  \********************************************/
/***/ ((module) => {

eval("/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n(function() {\n  /* istanbul ignore next */\n  if (true) {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else {}\n})();\n/* jshint ignore:end */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\nICAL.foldLength = 75;\n\n\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\nICAL.newLineChar = '\\r\\n';\n\n\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function(vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    }\n\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    }\n\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for (i = 0; i < properties.length; i++) {\n      if ((tzid = properties[i].getParameter(\"tzid\"))) {\n        reqTzid[tzid] = true;\n      }\n    }\n\n    //delete any vtimezones that are not on the reqTzid list.\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    }\n\n    //create any missing, but registered timezones\n    for (i in reqTzid) {\n      if (\n        reqTzid.hasOwnProperty(i) &&\n        !vtimezones[i] &&\n        ICAL.TimezoneService.has(i)\n      ) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function(number) {\n    return typeof(number) === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function(string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error(\n        'Could not extract integer from \"' + string + '\"'\n      );\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof(data) === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function(buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function(list, seekVal, cmpfunc) {\n    if (!list.length)\n      return 0;\n\n    var low = 0, high = list.length - 1,\n        mid, cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n\n      if (cmpval < 0)\n        high = mid - 1;\n      else if (cmpval > 0)\n        low = mid + 1;\n      else\n        break;\n    }\n\n    if (cmpval < 0)\n      return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0)\n      return mid + 1;\n    else\n      return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn: /* istanbul ignore next */ function() {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof (console) !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n      return arr;\n    } else {\n      var obj = {};\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;\n      else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;\n      else line_length += 4; //cp is less than 1114112\n      if (line_length < ICAL.foldLength + 1)\n        pos += cp > 65535 ? 2 : 1;\n      else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof(data) !== 'string') {\n      // handle fractions.\n      if (typeof(data) === 'number') {\n        data = parseInt(data);\n      }\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n      case 1:\n        return '0' + data;\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return (number < 0 ? Math.ceil(number) : Math.floor(number));\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function(base, child, extra) {\n    function F() {}\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function(source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.design = (function() {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n\n      fromICAL: function(aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n\n      toICAL: function(aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape)\n          regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function(str) {\n          switch (str) {\n          case \"\\\\\":\n            return \"\\\\\\\\\";\n          case \";\":\n            return \"\\\\;\";\n          case \",\":\n            return \"\\\\,\";\n          case \"\\n\":\n            return \"\\\\n\";\n          /* istanbul ignore next */\n          default:\n            return str;\n          }\n        });\n      }\n    };\n    return result;\n  }\n\n  // default types used multiple times\n  var DEFAULT_TYPE_TEXT = { defaultType: \"text\" };\n  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: \"text\", multiValue: \",\" };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: \"text\", structuredValue: \";\" };\n  var DEFAULT_TYPE_INTEGER = { defaultType: \"integer\" };\n  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: \"date-time\", allowedTypes: [\"date-time\", \"date\"] };\n  var DEFAULT_TYPE_DATETIME = { defaultType: \"date-time\" };\n  var DEFAULT_TYPE_URI = { defaultType: \"uri\" };\n  var DEFAULT_TYPE_UTCOFFSET = { defaultType: \"utc-offset\" };\n  var DEFAULT_TYPE_RECUR = { defaultType: \"recur\" };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: \"date-and-or-time\", allowedTypes: [\"date-time\", \"date\", \"text\"] };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n      case \"\\\\;\":\n        return \";\";\n      case \"\\\\,\":\n        return \",\";\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n      /* istanbul ignore next */\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n    if (structuredEscape)\n      newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n\n      fromICAL: function(aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n          case 'FALSE':\n            return false;\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n\n      toICAL: function(aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n        return 'FALSE';\n      }\n\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n\n      fromICAL: function(aValue) {\n        var parsed = parseFloat(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function(aValue) {\n        var parsed = parseInt(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2) +\n                 aValue.substr(7, 2);\n        }\n      },\n\n      fromICAL: function(aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2) + ':' +\n                 aValue.substr(5, 2);\n        }\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n\n    // CN just wants a param-value\n    // \"CN\": { ... }\n\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\",\n               \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\",\n               \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\",\n               \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\",\n               \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n\n    uri: {\n      // TODO\n      /* ... */\n    },\n\n    \"binary\": {\n      decorate: function(aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n\n      undecorate: function(aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {\n      // needs to be an uri\n    },\n    \"date\": {\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' +\n                 aValue.substr(4, 2) + '-' +\n                 aValue.substr(6, 2);\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) +\n                 aValue.substr(5, 2) +\n                 aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n\n      }\n    },\n    \"date-time\": {\n      fromICAL: function(aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' +\n                       aValue.substr(4, 2) + '-' +\n                       aValue.substr(6, 2) + 'T' +\n                       aValue.substr(9, 2) + ':' +\n                       aValue.substr(11, 2) + ':' +\n                       aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) +\n                       aValue.substr(5, 2) +\n                       // grab the (DDTHH) segment\n                       aValue.substr(8, 5) +\n                       // MM\n                       aValue.substr(14, 2) +\n                       // SS\n                       aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function(aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n\n      fromICAL: function(string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n\n      toICAL: function(parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n\n      decorate: function(aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function(string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n\n      toICAL: function(data) {\n        var str = \"\";\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n          var val = data[k];\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n        return str.substr(0, str.length - 1);\n      },\n\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n\n      undecorate: function(aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n\n    time: {\n      fromICAL: function(aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        }\n\n        // HH::MM::SSZ?\n        var result = aValue.substr(0, 2) + ':' +\n                     aValue.substr(2, 2) + ':' +\n                     aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n\n      toICAL: function(aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) +\n                     aValue.substr(3, 2) +\n                     aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": { defaultType: \"uri\" },\n    \"attendee\": { defaultType: \"cal-address\" },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": { defaultType: \"duration\" },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": { defaultType: \"period\", multiValue: \",\" },\n    \"geo\": { defaultType: \"float\", structuredValue: \";\" },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": { defaultType: \"cal-address\" },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function(string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": { defaultType: \"duration\", allowedTypes: [\"duration\", \"date-time\"] },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  });\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n\n    date: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function(aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n\n    time: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n        var zone = splitzone[0], value = splitzone[1];\n\n        //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' +\n                  value.substr(2, 2) + ':' +\n                  value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n\n      toICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n        var zone = splitzone[0], value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) +\n                  value.substr(3, 2) +\n                  value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n\n      _splitZone: function(aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n\n    \"date-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n\n      toICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n\n    \"date-and-or-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +\n               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n\n      toICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) +\n               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    }\n  });\n\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\",\n               \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\",\n               \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": { defaultType: \"language-tag\" },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": { defaultType: \"text\", structuredValue: \";\" },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": { defaultType: \"timestamp\" },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": { defaultType: \"uri\", allowedTypes: [\"uri\", \"text\"] },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": { defaultType: \"text\", allowedTypes: [\"text\", \"utc-offset\", \"uri\"] },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {\n      // TODO\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      fromICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\",\n               \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n\n    adr: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    label: DEFAULT_TYPE_TEXT,\n\n    tel: { defaultType: \"phone-number\" },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n\n    tz: { defaultType: \"utc-offset\", allowedTypes: [\"utc-offset\", \"text\"] },\n    geo: { defaultType: \"float\", structuredValue: \";\" },\n\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    agent: { defaultType: \"vcard\", allowedTypes: [\"vcard\", \"text\", \"uri\"] },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n\n    class: DEFAULT_TYPE_TEXT,\n    key: { defaultType: \"binary\", allowedTypes: [\"binary\", \"text\"] }\n  });\n\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function(componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n\n  return design;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\nICAL.stringify = (function() {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.component = function(component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n\n    var designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === 'vcard' && component[1].length > 0 &&\n            !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.property = function(property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n\n    var line = name;\n\n    var paramName;\n    for (paramName in params) {\n      var value = params[paramName];\n\n      /* istanbul ignore else */\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    }\n\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, multiValue, designSet, structuredValue\n      );\n    } else if (multiValue) {\n      line += stringify.multiValue(\n        property.slice(3), multiValue, valueType, null, designSet, false\n      );\n    } else if (structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, null, designSet, structuredValue\n      );\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n  stringify.propertyValue = function(value) {\n\n    if ((helpers.unescapedIndexOf(value, ',') === -1) &&\n        (helpers.unescapedIndexOf(value, ':') === -1) &&\n        (helpers.unescapedIndexOf(value, ';') === -1)) {\n\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== (len - 1)) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n  stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n  stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { '\"': \"^'\", \"\\n\": \"^n\", \"^\": \"^^\" };\n\n  return stringify;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\nICAL.parse = (function() {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n\n    state.stack = [root];\n\n    parser._eachLine(input, function(err, line) {\n      parser._handleContentLine(line, state);\n    });\n\n\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n      throw new ParserError(\n        'invalid ical body. component began but did not end'\n      );\n    }\n\n    state = null;\n\n    return (root.length == 1 ? root[0] : root);\n  }\n\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n  parser.property = function(str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n    parser._handleContentLine(str, state);\n    return state.component[1][0];\n  };\n\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n  parser.component = function(str) {\n    return parser(str);\n  };\n\n  // classes & constants\n  parser.ParserError = ParserError;\n\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n  parser._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n\n    var lastParamIndex;\n    var lastValuePos;\n\n    // name of property or begin/end\n    var name;\n    var value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    var params = {};\n\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n\n    if ((paramPos !== -1 && valuePos !== -1)) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n      if ((lastValuePos =\n        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n        state.stack.push(state.component);\n        state.component = newComponent;\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      }\n      // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError(\n        'invalid line (no token \";\" or \":\") \"' + line + '\"'\n      );\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    }\n\n    // attempt to determine value\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&\n            !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n  };\n\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n  parser._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n  parser._parseParameters = function(line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value, valuePos = -1;\n    var type, multiValue, mvdelim;\n\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while ((pos !== false) &&\n           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n        if (multiValue && pos != -1) {\n            var extendedValue = true;\n            while (extendedValue) {\n              if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n              } else {\n                extendedValue = false;\n              }\n            }\n          }\n        if (pos === -1) {\n          throw new ParserError(\n            'invalid line (no matching double quote) \"' + line + '\"'\n          );\n        }\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1;\n\n        // move to next \";\"\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && (lcname in result)) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [\n            result[lcname],\n            value\n          ];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n    return [result, value, valuePos];\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n  parser._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { \"^'\": '\"', \"^n\": \"\\n\", \"^^\": \"^\" };\n\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n    if (delim.length === 0) {\n      return buffer;\n    }\n\n    // split each piece\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n      result.push(value);\n      lastPos = pos + delim.length;\n    }\n\n    // on the last piece take the rest of string\n    value = buffer.substr(lastPos);\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n\n    return result.length == 1 ? result[0] : result;\n  };\n\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n  parser._eachLine = function(buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(\n          lastPos + 1,\n          pos - lastPos - (newlineOffset + 1)\n        );\n      } else {\n        if (line)\n          callback(null, line);\n        // push line\n        line = buffer.substr(\n          lastPos,\n          pos - lastPos - newlineOffset\n        );\n      }\n\n      lastPos = pos;\n    } while (pos !== len);\n\n    // extra ending line\n    line = line.trim();\n\n    if (line.length)\n      callback(null, line);\n  };\n\n  return parser;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Component = (function() {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n  function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function(index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(\n        this.jCal[COMPONENT_INDEX][index],\n        this\n      );\n\n      this._hydratedComponentCount++;\n      return (this._components[index] = comp);\n    },\n\n    _hydrateProperty: function(index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(\n        this.jCal[PROPERTY_INDEX][index],\n        this\n      );\n\n      this._hydratedPropertyCount++;\n      return (this._properties[index] = prop);\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function(name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      }\n\n      // ensure we return a value (strict mode)\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function(name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateComponent(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._components ||\n            (this._hydratedComponentCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function(name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function(name) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function(name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateProperty(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._properties ||\n            (this._hydratedPropertyCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n\n    _removeObjectByIndex: function(jCalIndex, cache, index) {\n      cache = cache || [];\n      // remove cached version\n      if (cache[index]) {\n        var obj = cache[index];\n        if (\"parent\" in obj) {\n            obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1);\n\n      // remove it from the jCal\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n\n    _removeObject: function(jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof(nameOrObject) === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    _removeAllObjects: function(jCalIndex, cache, name) {\n      var cached = this[cache];\n\n      // Unfortunately we have to run through all children to reset their\n      // parent property.\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1;\n\n      // descending search required because splice\n      // is used and will effect the indices.\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function(component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function(nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function(name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function(property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function(name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n\n      this.addProperty(prop);\n\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function(name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function(nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function(name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function() {\n      return ICAL.stringify.component(\n        this.jCal, this._designSet\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n  Component.fromString = function(str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Property = (function() {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n\n  var design = ICAL.design;\n\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof(jCal) === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n    this._updateType();\n  }\n\n  Property.prototype = {\n\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);\n\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function(index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      }\n\n      // for the case where there is no value.\n      if (this.jCal.length <= (VALUE_INDEX + index)) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n        return (this._values[index] = this._decorate(\n          this.jCal[VALUE_INDEX + index]\n        ));\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function(value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function(value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function(value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function(name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function(name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function(name, value) {\n      var lcname = name.toLowerCase();\n      if (typeof value === \"string\" &&\n          lcname in this._designSet.param &&\n          'multiValue' in this._designSet.param[lcname]) {\n          value = [value];\n      }\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function(name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function() {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function(type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function() {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function() {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function() {\n      if (this._values) {\n        this._values.length = 0;\n      }\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function(values) {\n      if (!this.isMultiValue) {\n        throw new Error(\n          this.name + ': does not not support mulitValue.\\n' +\n          'override isMultiValue'\n        );\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 &&\n          typeof(values[0]) === 'object' &&\n          'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function(value) {\n      this.removeAllValues();\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.stringify.property(\n        this.jCal, this._designSet, true\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n  Property.fromString = function(str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.UtcOffset = (function() {\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function() {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function(aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n\n      secs -= (this.hours * 3600);\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function() {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n\n    _normalize: function() {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n      while (secs < -43200) { // = UTC-12:00\n        secs += 97200;\n      }\n      while (secs > 50400) { // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs);\n\n      // Avoid changing the factor when on zero seconds\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") +\n              ICAL.helpers.pad2(this.hours) + ':' +\n              ICAL.helpers.pad2(this.minutes);\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n  UtcOffset.fromString = function(aString) {\n    // -05:00\n    var options = {};\n    //TODO: support seconds per rfc5545 ?\n    options.factor = (aString[0] === '+') ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n\n    return new ICAL.UtcOffset(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n  UtcOffset.fromSeconds = function(aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Binary = (function() {\n\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafa Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n\n      var r = data.length % 3;\n\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n\n    },\n\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        dec = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do { // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function() {\n      return this.value;\n    }\n  };\n\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n  Binary.fromString = function(aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function() {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function() {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.start.toICALString() + \"/\" +\n             (this.end || this.duration).toICALString();\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error(\n        'Invalid string value: \"' + str + '\" must contain a \"/\" char.'\n      );\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +\n                    86400 * this.days + 7 * 86400 * this.weeks;\n      return (this.isNegative ? -seconds : seconds);\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.isNegative = (aSeconds < 0);\n      this.days = ICAL.helpers.trunc(secs / 86400);\n\n      // If we have a flat number of weeks, use them.\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\n                         \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.toString();\n    }\n  };\n\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return (new ICAL.Duration()).fromSeconds(aSeconds);\n  };\n\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n  function parseDurationChunk(letter, number, object) {\n    var type;\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        }\n        // period\n        break;\n      case 'D':\n        type = 'days';\n        break;\n      case 'W':\n        type = 'weeks';\n        break;\n      case 'H':\n        type = 'hours';\n        break;\n      case 'M':\n        type = 'minutes';\n        break;\n      case 'S':\n        type = 'seconds';\n        break;\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error(\n          'invalid duration value: Missing number before \"' + letter + '\"'\n        );\n      }\n      var num = parseInt(number, 10);\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error(\n          'invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"'\n        );\n      }\n      object[type] = num;\n    }\n\n    return 1;\n  }\n\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n  ICAL.Duration.isValueString = function(string) {\n    return (string[0] === 'P' || string[1] === 'P');\n  };\n\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error(\n        'invalid duration value: Not enough duration components in \"' + aStr + '\"'\n      );\n    }\n\n    return new ICAL.Duration(dict);\n  };\n\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n\n(function() {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\",\n                 \"latitude\", \"longitude\"];\n\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        }\n\n        // Copy remaining passed properties\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      }\n\n      // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n      var change_num_to_use = -1;\n      var step = 1;\n\n      // TODO: replace with bin search?\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                          change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,\n                                        tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight &&\n              prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      }\n\n      // TODO return is_daylight?\n      return zone_change.utcOffset;\n    },\n\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(\n        this.changes,\n        change,\n        ICAL.Timezone._compare_change_fn\n      );\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n\n    _ensureCoverage: function(aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(\n            subcomps[compIdx], changesEndYear, this.changes\n          );\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n\n    _expandComponent: function(aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") ||\n          !aComponent.hasProperty(\"tzoffsetto\") ||\n          !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = (aComponent.name == \"daylight\");\n        changebase.utcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue()\n        );\n\n        changebase.prevUtcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue()\n        );\n\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n\n        ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                        -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n\n          var occ;\n          while ((occ = iterator.next())) {\n            change = init_changes();\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n\n            ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                            -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.tznames ? this.tznames : this.tzid);\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;\n    else if (a.year > b.year) return 1;\n\n    if (a.month < b.month) return -1;\n    else if (a.month > b.month) return 1;\n\n    if (a.day < b.day) return -1;\n    else if (a.day > b.day) return 1;\n\n    if (a.hour < b.hour) return -1;\n    else if (a.hour > b.hour) return 1;\n\n    if (a.minute < b.minute) return -1;\n    else if (a.minute > b.minute) return 1;\n\n    if (a.second < b.second) return -1;\n    else if (a.second > b.second) return 1;\n\n    return 0;\n  };\n\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate ||\n        from_zone.tzid == to_zone.tzid ||\n        from_zone == ICAL.Timezone.localTimezone ||\n        to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, - utcOffset);\n\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n\n    return null;\n  };\n\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(\n      change,\n      days,\n      hours,\n      minutes,\n      seconds,\n      change\n    );\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.TimezoneService = (function() {\n  var zones;\n\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function() {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function(tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function(tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function(name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function(tzid) {\n      return (delete zones[tzid]);\n    }\n  };\n\n  // initialize defaults\n  TimezoneService.reset();\n\n  return TimezoneService;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    /* time defaults */\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n\n  ICAL.Time.prototype = {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function() {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day,\n                                       hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && (\"isDate\" in aData)) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(\n          aData.timezone\n        );\n\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      }\n\n      // Using Zeller's algorithm\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n\n      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));\n      /* istanbul ignore else */\n      if (true /* gregorian */) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {}\n\n      // Normalize to 1 = wkst\n      h = ((h + 7 - firstDow) % 7) + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function() {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n\n      var start = 0;\n\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1;\n\n        // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        }\n\n        // set current start offset to current day.\n        start = otherDay.day;\n\n        // find the current day of week\n        var startDow = otherDay.dayOfWeek();\n\n        // calculate the difference between current\n        // day of the week and desired day of the week\n        var offset = aDayOfWeek - startDow;\n\n\n        // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n        if (offset < 0)\n          // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7;\n\n        // add offset to start so start is the same\n        // day of the week as the desired day of week.\n        start += offset;\n\n        // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n        start -= aDayOfWeek;\n\n        // set week day\n        weekday = aDayOfWeek;\n      } else {\n\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth;\n\n        // find the ends weekday\n        var endDow = otherDay.dayOfWeek();\n\n        pos++;\n\n        weekday = (endDow - aDayOfWeek);\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function(aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      }\n\n      // get pos\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      }\n      // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n      var week1;\n\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = (aDuration.isNegative ? -1 : 1);\n\n      // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = (this.zone.tzid == zone.tzid);\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone ||\n          this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function() {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' +\n                   ICAL.helpers.pad2(this.month) + '-' +\n                   ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +\n                    ICAL.helpers.pad2(this.minute) + ':' +\n                    ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n      this.adjust(0, 0, 0, 0);\n\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours,\n                                     aExtraMinutes, aExtraSeconds, aTime) {\n\n      var minutesOverflow, hoursOverflow,\n          daysOverflow = 0, yearsOverflow = 0;\n\n      var second, minute, hour, day;\n      var daysInMonth;\n\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      }\n\n\n      // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow;\n\n      // Now take care of the days (and adjust month if needed)\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n      var offset = this.utcOffset();\n\n      // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n      var ms = Date.UTC(\n        this.year,\n        this.month - 1,\n        this.day,\n        this.hour,\n        this.minute,\n        this.second - offset\n      );\n\n      // seconds\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function() {\n      var copy = [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'isDate'\n      ];\n\n      var result = Object.create(null);\n\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n\n          return val;\n        }\n      });\n\n    }\n\n    /* istanbul ignore else */\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n\n    if (month < 1 || month > 12) return days;\n\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return ((year % 4) == 0);\n    } else {\n      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));\n    }\n  };\n\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n\n    if (doy < 1) {\n      year--;\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromDateString = function(aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromDateTimeString = function(aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error(\n        'invalid date-time value: \"' + aValue + '\"'\n      );\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    }\n\n    // 2012-10-10T10:10:10(Z)?\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n\n    return time;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n\n    return t;\n  };\n\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n  ICAL.Time.getDominicalLetter = function(yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n  ICAL.Time.daysInYearPassedMonth = [\n    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],\n    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n  ];\n\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n\n(function() {\n\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function(data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n\n    this.icaltype = icaltype || \"date-and-or-time\";\n\n    this.fromData(data, zone);\n  };\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function() {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n\n    _normalize: function() {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function() {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function() {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year, m = this.month, d = this.day;\n      var h = this.hour, mm = this.minute, s = this.second;\n\n      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +\n                     (hasMonth ? p2(m) : '') +\n                     (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +\n                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +\n                     (hasMinute && hasSecond ? ':' : '') +\n                     (hasSecond ? p2(s) : '');\n\n      var zone;\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n        case \"date\":\n          return datepart;\n      }\n      return null;\n    }\n  });\n\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n    var parts = aValue.split('T');\n    var dt = parts[0], tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0], tm = splitzone[1];\n\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n\n  var REVERSE_DOW_MAP = {};\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\",\n                    \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\",\n                    \"BYMONTH\", \"BYSETPOS\"];\n\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof(data) === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function(aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return (ucname in this.parts ? this.parts[ucname].slice() : []);\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function(data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n        var kparts = this.parts[k];\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be > ' + min\n      );\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be < ' + min\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;\n  };\n\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = (num + firstDow - ICAL.Time.SUNDAY);\n    if (dow > 7) {\n      dow -= 7;\n    }\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',\n                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n\n  var optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error(\n          'invalid frequency \"' + value + '\" expected: \"' +\n          ALLOWED_FREQ.join(', ') + '\"'\n        );\n      }\n    },\n\n    COUNT: function(value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n\n    INTERVAL: function(value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n\n    UNTIL: function(value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n\n    WKST: function(value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function(value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n  ICAL.Recur.fromString = function(string) {\n    var data = ICAL.Recur._stringToData(string, false);\n    return new ICAL.Recur(data);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n  ICAL.Recur.fromData = function(aData) {\n    return new ICAL.Recur(aData);\n  };\n\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n  ICAL.Recur._stringToData = function(string, fmtIcal) {\n    var dict = Object.create(null);\n\n    // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = (fmtIcal ? lcname : ucname);\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurIterator = (function() {\n\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function(options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number)\n        this.occurrence_number = options.occurrence_number;\n\n      this.days = options.days || [];\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      }\n\n      // If the BYYEARDAY appares, no other date rule part may appear\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts ||\n            \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      }\n\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      }\n\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n      if (this.rule.freq == \"MONTHLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      }\n\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n      if (this.rule.freq == \"WEEKLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      }\n\n      // BYYEARDAY may only appear in YEARLY rules\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n          if (this.days.length > 0) {\n            break;\n          }\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        // Check every weekday in BYDAY with relative dow and pos.\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\n\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          }\n\n          // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n        this.last = tempLast.clone();\n\n        //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = (this.last ? this.last.clone() : null);\n\n      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||\n          (this.rule.until && this.last.compare(this.rule.until) > 0)) {\n\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n\n      var valid;\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n        case \"SECONDLY\":\n          this.next_second();\n          break;\n        case \"MINUTELY\":\n          this.next_minute();\n          break;\n        case \"HOURLY\":\n          this.next_hour();\n          break;\n        case \"DAILY\":\n          this.next_day();\n          break;\n        case \"WEEKLY\":\n          this.next_week();\n          break;\n        case \"MONTHLY\":\n          valid = this.next_month();\n          break;\n        case \"YEARLY\":\n          this.next_year();\n          break;\n\n        default:\n          return null;\n        }\n      } while (!this.check_contracting_rules() ||\n               this.last.compare(this.dtstart) < 0 ||\n               !valid);\n\n      // TODO is this valid?\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" +\n                        \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\",\n                               \"minute\", \"hour\", \"next_second\");\n    },\n\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\",\n                               \"monthday\", \"next_minute\");\n    },\n\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = (this.rule.freq == \"DAILY\");\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        }\n\n        // HACK should be first month of the year\n        this.last.month = 1;\n        this.last.day = 1;\n\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function(year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\n\n      // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n      var newRules = [];\n\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx];\n\n        // if this rule falls outside of given\n        // month discard it.\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        }\n\n        // negative case\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        }\n\n        // only add unique items...\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n\n      }\n\n      // unique and sort\n      return newRules.sort(function(a, b) { return a - b; });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function(isInit) {\n      var byMonthDay; // setup in initMonth\n      var byDay = this.by_data.BYDAY;\n\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n      var dayLen = byDay.length;\n\n      // we are not valid by default\n      var dataIsValid = 0;\n\n      var daysInMonth;\n      var self = this;\n      // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(\n          self.last.month, self.last.year\n        );\n\n        byMonthDay = self.normalizeByMonthDayRules(\n          self.last.year,\n          self.last.month,\n          self.by_data.BYMONTHDAY\n        );\n\n        dateLen = byMonthDay.length;\n\n        // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n        while (byMonthDay[dateIdx] <= lastDay &&\n               !(isInit && byMonthDay[dateIdx] == lastDay) &&\n               dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth();\n\n      // should come after initMonth\n      if (isInit) {\n        lastDay -= 1;\n      }\n\n      // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--;\n        // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        }\n\n        // find next date\n        var next = byMonthDay[dateIdx++];\n\n        // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        }\n\n        // Now we can loop through the day rules to see\n        // if one matches the current month date.\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n\n          this.last.day = lastDay;\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        }\n\n        // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n\n      return dataIsValid;\n    },\n\n    next_month: function next_month() {\n      var this_freq = (this.rule.freq == \"MONTHLY\");\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") ||\n                this.check_set_position(++setpos) ||\n                this.check_set_position(setpos - setpos_total - 1)) {\n\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,\n                                                  this.last.year);\n\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n\n        return end_of_data;\n      }\n    },\n\n    next_year: function next_year() {\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n\n    _nextByYearDay: function _nextByYearDay() {\n        var doy = this.days[this.days_index];\n        var year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        var next = ICAL.Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,\n                                        aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = (this.rule.freq == aInterval);\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n\n    increment_month: function increment_month() {\n      this.last.day = 1;\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n\n    increment_generic: function increment_generic(inc, aDateAttr,\n                                                  aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n\n    has_by_data: function has_by_data(aRuleType) {\n      return (aRuleType in this.rule.parts);\n    },\n\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = [];\n\n      // We need our own copy with a few keys set\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 2 &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) ||\n                  this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n\n              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;\n              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        }\n        // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&\n              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n      return 0;\n    },\n\n    expand_by_day: function expand_by_day(aYear) {\n\n      var days_list = [];\n      var tmp = this.last.clone();\n\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n\n      var start_dow = tmp.dayOfWeek();\n\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n\n        } else if (pos > 0) {\n          var first;\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n      return days_list;\n    },\n\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if ((pos == 0 && dow == this_dow) ||\n            (tt.nthWeekDay(dow, pos) == tt.day)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\n        // negative numbers are not false-y\n        return idx !== -1;\n      }\n      return false;\n    },\n\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data &&\n          ruleMapValue == icalrecur_iterator.CONTRACT) {\n\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n      return pass;\n    },\n\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n\n      return (this.check_contract_restriction(\"BYSECOND\", this.last.second) &&\n              this.check_contract_restriction(\"BYMINUTE\", this.last.minute) &&\n              this.check_contract_restriction(\"BYHOUR\", this.last.hour) &&\n              this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) &&\n              this.check_contract_restriction(\"BYWEEKNO\", weekNo) &&\n              this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) &&\n              this.check_contract_restriction(\"BYMONTH\", this.last.month) &&\n              this.check_contract_restriction(\"BYYEARDAY\", doy));\n    },\n\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var result = Object.create(null);\n\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n\n      return result;\n    }\n  };\n\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n\n  return icalrecur_iterator;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurExpansion = (function() {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') ||\n           comp.hasProperty('rrule') ||\n           comp.hasProperty('recurrence-id');\n  }\n\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function(options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function(item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof(options.complete) !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function() {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error(\n            'max tries have occured, rule may be impossible to forfill.'\n          );\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last);\n\n        // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        }\n\n        // no next rule day or recurrence rule is first.\n        if (!next || (iter && next.compare(iter.last) > 0)) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone();\n          // move to next so we can continue\n          iter.next();\n        }\n\n        // if the ruleDate is still next increment it.\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next;\n\n        // check the negative rules\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          }\n\n          // if the current rule is excluded skip it.\n          if (compare === 0) {\n            this._nextExDay();\n            continue;\n          }\n        }\n\n        //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function() {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function(component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(\n          result,\n          prop,\n          compareTime\n        );\n\n        // ordered insert\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function(component) {\n      this.ruleIterators = [];\n\n      this.last = this.dtstart.clone();\n\n      // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate');\n\n        // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n        if ((this.ruleDates[0]) &&\n            (this.ruleDates[0].compare(this.dtstart) < 0)) {\n\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(\n            this.ruleDates,\n            this.last,\n            compareTime\n          );\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter);\n\n          // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate');\n        // if we have a .last day we increment the index to beyond it.\n        this.exDateInc = ICAL.helpers.binsearchInsert(\n          this.exDates,\n          this.last,\n          compareTime\n        );\n\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function() {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function() {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function() {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter;\n\n      // loop through each iterator\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last;\n\n        // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n        if (iter.completed) {\n          len--;\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n          iters.splice(iterIdx, 1);\n          continue;\n        }\n\n        // find the most recent possible choice\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      }\n\n      // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n      return chosenIter;\n    }\n  };\n\n  return RecurExpansion;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Event = (function() {\n\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function(obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString();\n\n      // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n      this.exceptions[id] = obj;\n\n      // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n      if (obj.modifiesFuture()) {\n        var item = [\n          obj.recurrenceId.toUnixTime(), id\n        ];\n\n        // we keep them sorted so we can find the nearest\n        // value later on...\n        var idx = ICAL.helpers.binsearchInsert(\n          this.rangeExceptions,\n          item,\n          compareRangeException\n        );\n\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function() {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function(time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(\n        this.rangeExceptions,\n        [utc],\n        compareRangeException\n      );\n\n      idx -= 1;\n\n      // occurs before\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n\n      /* istanbul ignore next: sanity check only */\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function(occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(\n          occurrence\n        );\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId];\n\n          // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n          result.item = exception;\n\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone();\n\n            // zones must be same otherwise subtract may be incorrect.\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n\n          end = start.clone();\n          end.addDuration(exception.duration);\n\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function(startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function() {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function() {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function() {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n      if (!endDate) {\n          var duration = this._firstProp('duration');\n          endDate = this.startDate.clone();\n          if (duration) {\n              endDate.addDuration(duration);\n          } else if (endDate.isDate) {\n              endDate.day += 1;\n          }\n      }\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function(propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      }\n\n      // utc and local don't get a tzid\n      if (\n        time.zone === ICAL.Timezone.localTimezone ||\n        time.zone === ICAL.Timezone.utcTimezone\n      ) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n\n    _setProp: function(name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n\n    _firstProp: function(name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function() {\n      return this.component.toString();\n    }\n\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.ComponentParser = (function() {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof(options) === 'undefined') {\n      options = {};\n    }\n\n    var key;\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete: /* istanbul ignore next */ function() {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror: /* istanbul ignore next */ function(err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function(ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof(ical) === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n            break;\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n            break;\n          default:\n            continue;\n        }\n      }\n\n      //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n      this.oncomplete();\n    }\n  };\n\n  return ComponentParser;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWNhbC5qcy9idWlsZC9pY2FsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUEwQjtBQUNoQztBQUNBO0FBQ0EsSUFBSSxLQUFLLEVBS047QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsR0FBRztBQUNoQixhQUFhLGVBQWU7QUFDNUI7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEMsdUNBQXVDLHdDQUF3QztBQUMvRSwrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7O0FBRXhCO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxh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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUF1QztBQUMvQztBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy0xNS1zb2NpYWwtbWVkaWEtYXBwLy4vbm9kZV9tb2R1bGVzL2ljYWwuanMvYnVpbGQvaWNhbC5qcz8zODY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAyMSAqL1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG52YXIgSUNBTDtcbihmdW5jdGlvbigpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlMsIHdoZXJlIGV4cG9ydHMgbWF5IGJlIGRpZmZlcmVudCBlYWNoIHRpbWUuXG4gICAgSUNBTCA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MU2NyaXB0RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ25vTW9kdWxlJyBpbiBIVE1MU2NyaXB0RWxlbWVudC5wcm90b3R5cGUpIHtcbiAgICAvLyBVbnRpbCB3ZSB1c2UgRVM2IGV4cG9ydHMsIHVzaW5nIDxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiPiB3ZSBkZWZpbmUgSUNBTCBvbiB0aGUgd2luZG93IGdsb2JhbC5cbiAgICB3aW5kb3cuSUNBTCA9IElDQUwgPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgSUNBTCAhPT0gJ29iamVjdCcpIHtcbiAgICBJQ0FMID0ge307XG4gIH1cbn0pKCk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYmVmb3JlIGlDYWxlbmRhciBsaW5lIGZvbGRpbmcgc2hvdWxkIG9jY3VyXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgNzVcbiAqL1xuSUNBTC5mb2xkTGVuZ3RoID0gNzU7XG5cblxuLyoqXG4gKiBUaGUgY2hhcmFjdGVyKHMpIHRvIGJlIHVzZWQgZm9yIGEgbmV3bGluZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgYnlcbiAqIHJmYzU1NDUuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgXCJcXHJcXG5cIlxuICovXG5JQ0FMLm5ld0xpbmVDaGFyID0gJ1xcclxcbic7XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMgd2l0aGluIGljYWwuanNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSUNBTC5oZWxwZXJzID0ge1xuICAvKipcbiAgICogQ29tcGlsZXMgYSBsaXN0IG9mIGFsbCByZWZlcmVuY2VkIFRaSURzIGluIGFsbCBzdWJjb21wb25lbnRzIGFuZFxuICAgKiByZW1vdmVzIGFueSBleHRyYSBWVElNRVpPTkUgc3ViY29tcG9uZW50cy4gSW4gYWRkaXRpb24sIGlmIGFueSBUWklEc1xuICAgKiBhcmUgcmVmZXJlbmNlZCBieSBhIGNvbXBvbmVudCwgYnV0IGEgVlRJTUVaT05FIGRvZXMgbm90IGV4aXN0LFxuICAgKiBhbiBhdHRlbXB0IHdpbGwgYmUgbWFkZSB0byBnZW5lcmF0ZSBhIFZUSU1FWk9ORSB1c2luZyBJQ0FMLlRpbWV6b25lU2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gdmNhbCAgICAgVGhlIHRvcC1sZXZlbCBWQ0FMRU5EQVIgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtJQ0FMLkNvbXBvbmVudH0gICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICAgKi9cbiAgdXBkYXRlVGltZXpvbmVzOiBmdW5jdGlvbih2Y2FsKSB7XG4gICAgdmFyIGFsbHN1YnMsIHByb3BlcnRpZXMsIHZ0aW1lem9uZXMsIHJlcVR6aWQsIGksIHR6aWQ7XG5cbiAgICBpZiAoIXZjYWwgfHwgdmNhbC5uYW1lICE9PSBcInZjYWxlbmRhclwiKSB7XG4gICAgICAvL25vdCBhIHRvcC1sZXZlbCB2Y2FsZW5kYXIgY29tcG9uZW50XG4gICAgICByZXR1cm4gdmNhbDtcbiAgICB9XG5cbiAgICAvL1N0b3JlIHZ0aW1lem9uZSBzdWJjb21wb25lbnRzIGluIGFuIG9iamVjdCByZWZlcmVuY2UgYnkgdHppZC5cbiAgICAvL1N0b3JlIHByb3BlcnRpZXMgZnJvbSBldmVyeXRoaW5nIGVsc2UgaW4gYW5vdGhlciBhcnJheVxuICAgIGFsbHN1YnMgPSB2Y2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgdnRpbWV6b25lcyA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBhbGxzdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWxsc3Vic1tpXS5uYW1lID09PSBcInZ0aW1lem9uZVwiKSB7XG4gICAgICAgIHR6aWQgPSBhbGxzdWJzW2ldLmdldEZpcnN0UHJvcGVydHkoXCJ0emlkXCIpLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgdnRpbWV6b25lc1t0emlkXSA9IGFsbHN1YnNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jb25jYXQoYWxsc3Vic1tpXS5nZXRBbGxQcm9wZXJ0aWVzKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vY3JlYXRlIGFuIG9iamVjdCB3aXRoIG9uZSBlbnRyeSBmb3IgZWFjaCByZXF1aXJlZCB0elxuICAgIHJlcVR6aWQgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCh0emlkID0gcHJvcGVydGllc1tpXS5nZXRQYXJhbWV0ZXIoXCJ0emlkXCIpKSkge1xuICAgICAgICByZXFUemlkW3R6aWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlbGV0ZSBhbnkgdnRpbWV6b25lcyB0aGF0IGFyZSBub3Qgb24gdGhlIHJlcVR6aWQgbGlzdC5cbiAgICBmb3IgKGkgaW4gdnRpbWV6b25lcykge1xuICAgICAgaWYgKHZ0aW1lem9uZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgIXJlcVR6aWRbaV0pIHtcbiAgICAgICAgdmNhbC5yZW1vdmVTdWJjb21wb25lbnQodnRpbWV6b25lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jcmVhdGUgYW55IG1pc3NpbmcsIGJ1dCByZWdpc3RlcmVkIHRpbWV6b25lc1xuICAgIGZvciAoaSBpbiByZXFUemlkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcVR6aWQuaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgIXZ0aW1lem9uZXNbaV0gJiZcbiAgICAgICAgSUNBTC5UaW1lem9uZVNlcnZpY2UuaGFzKGkpXG4gICAgICApIHtcbiAgICAgICAgdmNhbC5hZGRTdWJjb21wb25lbnQoSUNBTC5UaW1lem9uZVNlcnZpY2UuZ2V0KGkpLmNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZjYWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdHlwZSBpcyBvZiB0aGUgbnVtYmVyIHR5cGUgYW5kIGFsc28gTmFOLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBudW1iZXIgaXMgc3RyaWN0bHkgTmFOXG4gICAqL1xuICBpc1N0cmljdGx5TmFOOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mKG51bWJlcikgPT09ICdudW1iZXInICYmIGlzTmFOKG51bWJlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHN0cmluZyB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIsIHdoZW4gdGhlIHZhbGlkIGlzXG4gICAqIG5vdCBhbiBpbnRlZ2VyIHRocm93cyBhIGRlY29yYXRpb24gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFJhdyBzdHJpbmcgaW5wdXRcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgUGFyc2VkIGludGVnZXJcbiAgICovXG4gIHN0cmljdFBhcnNlSW50OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG5cbiAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4ocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IGV4dHJhY3QgaW50ZWdlciBmcm9tIFwiJyArIHN0cmluZyArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBvciByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2Ugb2YgYSBnaXZlbiB0eXBlIHdpdGggdGhlIGluaXRpYWxpemF0aW9uXG4gICAqIGRhdGEgaWYgdGhlIGRhdGEgaXMgbm90IGFscmVhZHkgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSguLi4pO1xuICAgKiB2YXIgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh0aW1lLCBJQ0FMLlRpbWUpO1xuICAgKlxuICAgKiAocmVzdWx0IGluc3RhbmNlb2YgSUNBTC5UaW1lKVxuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHJlc3VsdCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoe30sIElDQUwuVGltZSk7XG4gICAqIChyZXN1bHQgaXNudGFuY2VvZiBJQ0FMLlRpbWUpXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgb2JqZWN0IGluaXRpYWxpemF0aW9uIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGUgICAgICAgb2JqZWN0IHR5cGUgKGxpa2UgSUNBTC5UaW1lKVxuICAgKiBAcmV0dXJuIHs/fSAgICAgICAgICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgZm91bmQgdHlwZS5cbiAgICovXG4gIGZvcm1hdENsYXNzVHlwZTogZnVuY3Rpb24gZm9ybWF0Q2xhc3NUeXBlKGRhdGEsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHR5cGUoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElkZW50aWNhbCB0byBpbmRleE9mIGJ1dCB3aWxsIG9ubHkgbWF0Y2ggdmFsdWVzIHdoZW4gdGhleSBhcmUgbm90IHByZWNlZGVkXG4gICAqIGJ5IGEgYmFja3NsYXNoIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgIFN0cmluZyB0byBzZWFyY2hcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaCAgICAgICAgIFZhbHVlIHRvIGxvb2sgZm9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgICAgICAgICAgICBTdGFydCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIHBvc2l0aW9uLCBvciAtMSBpZiBub3QgZm91bmRcbiAgICovXG4gIHVuZXNjYXBlZEluZGV4T2Y6IGZ1bmN0aW9uKGJ1ZmZlciwgc2VhcmNoLCBwb3MpIHtcbiAgICB3aGlsZSAoKHBvcyA9IGJ1ZmZlci5pbmRleE9mKHNlYXJjaCwgcG9zKSkgIT09IC0xKSB7XG4gICAgICBpZiAocG9zID4gMCAmJiBidWZmZXJbcG9zIC0gMV0gPT09ICdcXFxcJykge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggZm9yIGluc2VydGlvbiB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0ICAgICAgICAgICAgVGhlIGxpc3QgdG8gc2VhcmNoXG4gICAqIEBwYXJhbSB7P30gc2Vla1ZhbCAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyw/KX0gY21wZnVuYyBUaGUgY29tcGFyaXNvbiBmdW5jLCB0aGF0IGNhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlIHR3byBzZWVrVmFsc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIGluc2VydCBwb3NpdGlvblxuICAgKi9cbiAgYmluc2VhcmNoSW5zZXJ0OiBmdW5jdGlvbihsaXN0LCBzZWVrVmFsLCBjbXBmdW5jKSB7XG4gICAgaWYgKCFsaXN0Lmxlbmd0aClcbiAgICAgIHJldHVybiAwO1xuXG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaXN0Lmxlbmd0aCAtIDEsXG4gICAgICAgIG1pZCwgY21wdmFsO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgICAgY21wdmFsID0gY21wZnVuYyhzZWVrVmFsLCBsaXN0W21pZF0pO1xuXG4gICAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICBlbHNlIGlmIChjbXB2YWwgPiAwKVxuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgIHJldHVybiBtaWQ7IC8vIGluc2VydGlvbiBpcyBkaXNwbGFjaW5nLCBzbyB1c2UgbWlkIG91dHJpZ2h0LlxuICAgIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgICByZXR1cm4gbWlkICsgMTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZGVidWcgb3V0cHV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkdW1wbjogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFJQ0FMLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiAoY29uc29sZSkgIT09ICd1bmRlZmluZWQnICYmICdsb2cnIGluIGNvbnNvbGUpIHtcbiAgICAgIElDQUwuaGVscGVycy5kdW1wbiA9IGZ1bmN0aW9uIGNvbnNvbGVEdW1wbihpbnB1dCkge1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZHVtcG4gPSBmdW5jdGlvbiBnZWNrb0R1bXBuKGlucHV0KSB7XG4gICAgICAgIGR1bXAoaW5wdXQgKyAnXFxuJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIElDQUwuaGVscGVycy5kdW1wbihhcmd1bWVudHNbMF0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgcGFzc2VkIG9iamVjdCBvciBwcmltaXRpdmUuIEJ5IGRlZmF1bHQgYSBzaGFsbG93IGNsb25lIHdpbGwgYmVcbiAgICogZXhlY3V0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYVNyYyAgICAgICAgICAgIFRoZSB0aGluZyB0byBjbG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGVlcCAgICBJZiB0cnVlLCBhIGRlZXAgY2xvbmUgd2lsbCBiZSBwZXJmb3JtZWRcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgVGhlIGNvcHkgb2YgdGhlIHRoaW5nXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24oYVNyYywgYURlZXApIHtcbiAgICBpZiAoIWFTcmMgfHwgdHlwZW9mIGFTcmMgIT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGFTcmM7XG4gICAgfSBlbHNlIGlmIChhU3JjIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGFTcmMuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKFwiY2xvbmVcIiBpbiBhU3JjKSB7XG4gICAgICByZXR1cm4gYVNyYy5jbG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhU3JjKSkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKGFEZWVwID8gSUNBTC5oZWxwZXJzLmNsb25lKGFTcmNbaV0sIHRydWUpIDogYVNyY1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGFTcmMpIHtcbiAgICAgICAgLy8gdXNlcyBwcm90b3R5cGUgbWV0aG9kIHRvIGFsbG93IHVzZSBvZiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFTcmMsIG5hbWUpKSB7XG4gICAgICAgICAgaWYgKGFEZWVwKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBJQ0FMLmhlbHBlcnMuY2xvbmUoYVNyY1tuYW1lXSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGFTcmNbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybXMgaUNhbGVuZGFyIGxpbmUgZm9sZGluZy4gQSBsaW5lIGVuZGluZyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgYW5kXG4gICAqIHRoZSBuZXh0IGxpbmUgYmVnaW5zIHdpdGggYSB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBTVU1NQVJZOlRoaXMgbGluZSB3aWxsIGJlIGZvbGRcbiAgICogIGVkIHJpZ2h0IGluIHRoZSBtaWRkbGUgb2YgYSB3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYUxpbmUgICAgICBUaGUgbGluZSB0byBmb2xkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBmb2xkZWQgbGluZVxuICAgKi9cbiAgZm9sZGxpbmU6IGZ1bmN0aW9uIGZvbGRsaW5lKGFMaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIGxpbmUgPSBhTGluZSB8fCBcIlwiLCBwb3MgPSAwLCBsaW5lX2xlbmd0aCA9IDA7XG4gICAgLy9wb3MgY291bnRzIHBvc2l0aW9uIGluIGxpbmUgZm9yIHRoZSBVVEYtMTYgcHJlc2VudGF0aW9uXG4gICAgLy9saW5lX2xlbmd0aCBjb3VudHMgdGhlIGJ5dGVzIGZvciB0aGUgVVRGLTggcHJlc2VudGF0aW9uXG4gICAgd2hpbGUgKGxpbmUubGVuZ3RoKSB7XG4gICAgICB2YXIgY3AgPSBsaW5lLmNvZGVQb2ludEF0KHBvcyk7XG4gICAgICBpZiAoY3AgPCAxMjgpICsrbGluZV9sZW5ndGg7XG4gICAgICBlbHNlIGlmIChjcCA8IDIwNDgpIGxpbmVfbGVuZ3RoICs9IDI7Ly9uZWVkcyAyIFVURi04IGJ5dGVzXG4gICAgICBlbHNlIGlmIChjcCA8IDY1NTM2KSBsaW5lX2xlbmd0aCArPSAzO1xuICAgICAgZWxzZSBsaW5lX2xlbmd0aCArPSA0OyAvL2NwIGlzIGxlc3MgdGhhbiAxMTE0MTEyXG4gICAgICBpZiAobGluZV9sZW5ndGggPCBJQ0FMLmZvbGRMZW5ndGggKyAxKVxuICAgICAgICBwb3MgKz0gY3AgPiA2NTUzNSA/IDIgOiAxO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBJQ0FMLm5ld0xpbmVDaGFyICsgXCIgXCIgKyBsaW5lLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcocG9zKTtcbiAgICAgICAgcG9zID0gbGluZV9sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnN1YnN0cihJQ0FMLm5ld0xpbmVDaGFyLmxlbmd0aCArIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYWRzIHRoZSBnaXZlbiBzdHJpbmcgb3IgbnVtYmVyIHdpdGggemVyb3Mgc28gaXQgd2lsbCBoYXZlIGF0IGxlYXN0IHR3b1xuICAgKiBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGRhdGEgICAgVGhlIHN0cmluZyBvciBudW1iZXIgdG8gcGFkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICBUaGUgbnVtYmVyIHBhZGRlZCBhcyBhIHN0cmluZ1xuICAgKi9cbiAgcGFkMjogZnVuY3Rpb24gcGFkKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gaGFuZGxlIGZyYWN0aW9ucy5cbiAgICAgIGlmICh0eXBlb2YoZGF0YSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGEgPSBwYXJzZUludChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuICcwMCc7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAnMCcgKyBkYXRhO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZXMgdGhlIGdpdmVuIG51bWJlciwgY29ycmVjdGx5IGhhbmRsaW5nIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgICAgIFRoZSBudW1iZXIgdG8gdHJ1bmNhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIHRydW5jYXRlZCBudW1iZXJcbiAgICovXG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhudW1iZXIpIHtcbiAgICByZXR1cm4gKG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvb3ItbWFuJ3MgY3Jvc3MtYnJvd3NlciBpbmhlcml0YW5jZSBmb3IgSmF2YVNjcmlwdC4gRG9lc24ndCBzdXBwb3J0IGFsbFxuICAgKiB0aGUgZmVhdHVyZXMsIGJ1dCBlbm91Z2ggZm9yIG91ciB1c2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZSAgICAgVGhlIGJhc2UgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkICAgIFRoZSBjaGlsZCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhICAgICAgRXh0ZW5kcyB0aGUgcHJvdG90eXBlIHdpdGggZXh0cmEgcHJvcGVydGllc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBtZXRob2RzXG4gICAqL1xuICBpbmhlcml0czogZnVuY3Rpb24oYmFzZSwgY2hpbGQsIGV4dHJhKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBiYXNlLnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGV4dHJhLCBjaGlsZC5wcm90b3R5cGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUG9vci1tYW4ncyBjcm9zcy1icm93c2VyIG9iamVjdCBleHRlbnNpb24uIERvZXNuJ3Qgc3VwcG9ydCBhbGwgdGhlXG4gICAqIGZlYXR1cmVzLCBidXQgZW5vdWdoIGZvciBvdXIgdXNhZ2UuIE5vdGUgdGhhdCB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmVcbiAgICogbm90IG92ZXJ3cml0dGVuIHdpdGggdGhlIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgY2hpbGQgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKHBhcmVudCwge1xuICAgKiAgIFwiYmFyXCI6IDEyM1xuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAgICAgVGhlIG9iamVjdCB0byBleHRlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgICAgVGhlIG9iamVjdCB0byBleHRlbmQgd2l0aFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBSZXR1cm5zIHRoZSB0YXJnZXQuXG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFyIGRlc2NyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICBpZiAoZGVzY3IgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG59O1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuLyoqIEBuYW1lc3BhY2UgSUNBTCAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5kZXNpZ24gPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRlJPTV9JQ0FMX05FV0xJTkUgPSAvXFxcXFxcXFx8XFxcXDt8XFxcXCx8XFxcXFtObl0vZztcbiAgdmFyIFRPX0lDQUxfTkVXTElORSA9IC9cXFxcfDt8LHxcXG4vZztcbiAgdmFyIEZST01fVkNBUkRfTkVXTElORSA9IC9cXFxcXFxcXHxcXFxcLHxcXFxcW05uXS9nO1xuICB2YXIgVE9fVkNBUkRfTkVXTElORSA9IC9cXFxcfCx8XFxuL2c7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dFR5cGUoZnJvbU5ld2xpbmUsIHRvTmV3bGluZSkge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBtYXRjaGVzOiAvLiovLFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlTmV3bGluZShhVmFsdWUsIGZyb21OZXdsaW5lLCBzdHJ1Y3R1cmVkRXNjYXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgICAgIHZhciByZWdFeCA9IHRvTmV3bGluZTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgICAgICAgcmVnRXggPSBuZXcgUmVnRXhwKHJlZ0V4LnNvdXJjZSArICd8JyArIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgICAgICByZXR1cm4gYVZhbHVlLnJlcGxhY2UocmVnRXgsIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFw7XCI7XG4gICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFwsXCI7XG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0eXBlcyB1c2VkIG11bHRpcGxlIHRpbWVzXG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVCA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBtdWx0aVZhbHVlOiBcIixcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfSU5URUdFUiA9IHsgZGVmYXVsdFR5cGU6IFwiaW50ZWdlclwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSB9O1xuICB2YXIgREVGQVVMVF9UWVBFX0RBVEVUSU1FID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1VSSSA9IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9VVENPRkZTRVQgPSB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1JFQ1VSID0geyBkZWZhdWx0VHlwZTogXCJyZWN1clwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURV9BTkRPUl9USU1FID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLWFuZC1vci10aW1lXCIsIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiLCBcInRleHRcIl0gfTtcblxuICBmdW5jdGlvbiByZXBsYWNlTmV3bGluZVJlcGxhY2Uoc3RyaW5nKSB7XG4gICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgIGNhc2UgXCJcXFxcXFxcXFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcXCI7XG4gICAgICBjYXNlIFwiXFxcXDtcIjpcbiAgICAgICAgcmV0dXJuIFwiO1wiO1xuICAgICAgY2FzZSBcIlxcXFwsXCI6XG4gICAgICAgIHJldHVybiBcIixcIjtcbiAgICAgIGNhc2UgXCJcXFxcblwiOlxuICAgICAgY2FzZSBcIlxcXFxOXCI6XG4gICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmUodmFsdWUsIG5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAvLyBhdm9pZCByZWdleCB3aGVuIHBvc3NpYmxlLlxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCdcXFxcJykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmVkRXNjYXBlKVxuICAgICAgbmV3bGluZSA9IG5ldyBSZWdFeHAobmV3bGluZS5zb3VyY2UgKyAnfFxcXFxcXFxcJyArIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ld2xpbmUsIHJlcGxhY2VOZXdsaW5lUmVwbGFjZSk7XG4gIH1cblxuICB2YXIgY29tbW9uUHJvcGVydGllcyA9IHtcbiAgICBcImNhdGVnb3JpZXNcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInZlcnNpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ1aWRcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfTtcblxuICB2YXIgY29tbW9uVmFsdWVzID0ge1xuICAgIFwiYm9vbGVhblwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGFWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ1RSVUUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSAnRkFMU0UnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvL1RPRE86IHBhcnNlciB3YXJuaW5nXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJ1RSVUUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnRkFMU0UnO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBmbG9hdDoge1xuICAgICAgbWF0Y2hlczogL15bKy1dP1xcZCtcXC5cXGQrJC8sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRmxvYXQoYVZhbHVlKTtcbiAgICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwYXJzZXIgd2FybmluZ1xuICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGludGVnZXI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KGFWYWx1ZSk7XG4gICAgICAgIGlmIChJQ0FMLmhlbHBlcnMuaXNTdHJpY3RseU5hTihwYXJzZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidXRjLW9mZnNldFwiOiB7XG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDcpIHtcbiAgICAgICAgICAvLyBubyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTAwMDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMikgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDcsIDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNikge1xuICAgICAgICAgIC8vIG5vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDU6MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTowMDowMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBpY2FsUGFyYW1zID0ge1xuICAgIC8vIEFsdGhvdWdoIHRoZSBzeW50YXggaXMgRFFVT1RFIHVyaSBEUVVPVEUsIEkgZG9uJ3QgdGhpbmsgd2Ugc2hvdWxkXG4gICAgLy8gZW5mb2NlIGFueXRoaW5nIGFzaWRlIGZyb20gaXQgYmVpbmcgYSB2YWxpZCBjb250ZW50IGxpbmUuXG4gICAgLy9cbiAgICAvLyBBdCBsZWFzdCBzb21lIHBhcmFtcyByZXF1aXJlIC0gaWYgbXVsdGkgdmFsdWVzIGFyZSB1c2VkIC0gRFFVT1RFc1xuICAgIC8vIGZvciBlYWNoIG9mIGl0cyB2YWx1ZXMgLSBlLmcuIGRlbGVnYXRlZC1mcm9tPVwidXJpMVwiLFwidXJpMlwiXG4gICAgLy8gVG8gaW5kaWNhdGUgdGhpcywgSSBpbnRyb2R1Y2VkIHRoZSBuZXcgay92IHBhaXJcbiAgICAvLyBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICAvL1xuICAgIC8vIFwiQUxUUkVQXCI6IHsgLi4uIH0sXG5cbiAgICAvLyBDTiBqdXN0IHdhbnRzIGEgcGFyYW0tdmFsdWVcbiAgICAvLyBcIkNOXCI6IHsgLi4uIH1cblxuICAgIFwiY3V0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiSU5ESVZJRFVBTFwiLCBcIkdST1VQXCIsIFwiUkVTT1VSQ0VcIiwgXCJST09NXCIsIFwiVU5LTk9XTlwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG5cbiAgICBcImRlbGVnYXRlZC1mcm9tXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIFwiZGVsZWdhdGVkLXRvXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIC8vIFwiRElSXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcImVuY29kaW5nXCI6IHtcbiAgICAgIHZhbHVlczogW1wiOEJJVFwiLCBcIkJBU0U2NFwiXVxuICAgIH0sXG4gICAgLy8gXCJGTVRUWVBFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcImZidHlwZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIkZSRUVcIiwgXCJCVVNZXCIsIFwiQlVTWS1VTkFWQUlMQUJMRVwiLCBcIkJVU1ktVEVOVEFUSVZFXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICAvLyBcIkxBTkdVQUdFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcIm1lbWJlclwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gICAgfSxcbiAgICBcInBhcnRzdGF0XCI6IHtcbiAgICAgIC8vIFRPRE8gVGhlc2UgdmFsdWVzIGFyZSBhY3R1YWxseSBkaWZmZXJlbnQgcGVyLWNvbXBvbmVudFxuICAgICAgdmFsdWVzOiBbXCJORUVEUy1BQ1RJT05cIiwgXCJBQ0NFUFRFRFwiLCBcIkRFQ0xJTkVEXCIsIFwiVEVOVEFUSVZFXCIsXG4gICAgICAgICAgICAgICBcIkRFTEVHQVRFRFwiLCBcIkNPTVBMRVRFRFwiLCBcIklOLVBST0NFU1NcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicmFuZ2VcIjoge1xuICAgICAgdmFsdWVzOiBbXCJUSElTQU5ERlVUVVJFXCJdXG4gICAgfSxcbiAgICBcInJlbGF0ZWRcIjoge1xuICAgICAgdmFsdWVzOiBbXCJTVEFSVFwiLCBcIkVORFwiXVxuICAgIH0sXG4gICAgXCJyZWx0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiUEFSRU5UXCIsIFwiQ0hJTERcIiwgXCJTSUJMSU5HXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICBcInJvbGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJSRVEtUEFSVElDSVBBTlRcIiwgXCJDSEFJUlwiLFxuICAgICAgICAgICAgICAgXCJPUFQtUEFSVElDSVBBTlRcIiwgXCJOT04tUEFSVElDSVBBTlRcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicnN2cFwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXVxuICAgIH0sXG4gICAgXCJzZW50LWJ5XCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiXG4gICAgfSxcbiAgICBcInR6aWRcIjoge1xuICAgICAgbWF0Y2hlczogL15cXC8vXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJiaW5hcnlcIiwgXCJib29sZWFuXCIsIFwiY2FsLWFkZHJlc3NcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsXG4gICAgICAgICAgICAgICBcImR1cmF0aW9uXCIsIFwiZmxvYXRcIiwgXCJpbnRlZ2VyXCIsIFwicGVyaW9kXCIsIFwicmVjdXJcIiwgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICBcInRpbWVcIiwgXCJ1cmlcIiwgXCJ1dGMtb2Zmc2V0XCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbiAgdmFyIGljYWxWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fSUNBTF9ORVdMSU5FLCBUT19JQ0FMX05FV0xJTkUpLFxuXG4gICAgdXJpOiB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvKiAuLi4gKi9cbiAgICB9LFxuXG4gICAgXCJiaW5hcnlcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuQmluYXJ5LmZyb21TdHJpbmcoYVN0cmluZyk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBhQmluYXJ5LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhbC1hZGRyZXNzXCI6IHtcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGFuIHVyaVxuICAgIH0sXG4gICAgXCJkYXRlXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICAgIGlmIChkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdW5kZWNvcmF0ZXMgYSB0aW1lIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMjA5MDFcbiAgICAgICAgLy8gdG86IDIwMTItMDktMDFcbiAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIGFWYWx1ZS5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZGF0ZS10aW1lLCBlLmcuIDIwMTIwOTAxVDEzMDAwMFpcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlc1tcImRhdGUtdGltZVwiXS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKSArICctJyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNiwgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTItMDktMDFcbiAgICAgICAgLy8gdG86IDIwMTIwOTAxXG4gICAgICAgIHZhciBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPT0gMTApIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMikgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDgsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzW1wiZGF0ZS10aW1lXCJdLnRvSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vVE9ETzogc2VyaWFsaXplIHdhcm5pbmc/XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRhdGUtdGltZVwiOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgICAvLyB0bzogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGRhdGUsIGUuZy4gMjAxMjA5MDFcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKSArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoOSwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDExLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTMsIDIpO1xuXG4gICAgICAgICAgaWYgKGFWYWx1ZVsxNV0gJiYgYVZhbHVlWzE1XSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTItMDktMDFUMTM6MDA6MDBcbiAgICAgICAgLy8gdG86IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgICB2YXIgbGVuID0gYVZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuID09IDEwICYmICFkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPj0gMTkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCA0KSArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSAoRERUSEgpIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig4LCA1KSArXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIE1NXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTQsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gU1NcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxNywgMik7XG5cbiAgICAgICAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogZXJyb3JcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgICBpZiAoZGVzaWduLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGR1cmF0aW9uOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGVyaW9kOiB7XG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10uZnJvbUlDQUwocGFydHNbMF0pO1xuXG4gICAgICAgIGlmICghSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKHBhcnRzWzFdKSkge1xuICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10uZnJvbUlDQUwocGFydHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMF0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKHBhcnRzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUlDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyhwYXJ0c1sxXSkpIHtcbiAgICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMV0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCIvXCIpO1xuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21KU09OKGFWYWx1ZSwgYVByb3AsICFkZXNpZ24uc3RyaWN0KTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvSlNPTigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjdXI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUmVjdXIuX3N0cmluZ1RvRGF0YShzdHJpbmcsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2tdO1xuICAgICAgICAgIGlmIChrID09IFwidW50aWxcIikge1xuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICB2YWwgPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbCA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGsgPT0gXCJ3a3N0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB2YWwgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gay50b1VwcGVyQ2FzZSgpICsgXCI9XCIgKyB2YWwgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24gZGVjb3JhdGUoYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlJlY3VyLmZyb21EYXRhKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhUmVjdXIpIHtcbiAgICAgICAgcmV0dXJuIGFSZWN1ci50b0pTT04oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZToge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiBNTUhIU1MoWik/XG4gICAgICAgIC8vIHRvOiBISDpNTTpTUyhaKT9cbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgLy8gVE9ETzogcGFyc2VyIGV4Y2VwdGlvbj9cbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSEg6Ok1NOjpTU1o/XG4gICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMiwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKTtcblxuICAgICAgICBpZiAoYVZhbHVlWzZdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IEhIOk1NOlNTKFopP1xuICAgICAgICAvLyB0bzogTU1ISFNTKFopP1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICAvL1RPRE86IGVycm9yXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKTtcblxuICAgICAgICBpZiAoYVZhbHVlWzhdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBpY2FsUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuXG4gICAgXCJhY3Rpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJhdHRhY2hcIjogeyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9LFxuICAgIFwiYXR0ZW5kZWVcIjogeyBkZWZhdWx0VHlwZTogXCJjYWwtYWRkcmVzc1wiIH0sXG4gICAgXCJjYWxzY2FsZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNsYXNzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY29tbWVudFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNvbXBsZXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJjb250YWN0XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY3JlYXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImR0ZW5kXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHRzdGFtcFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJkdHN0YXJ0XCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHVlXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHVyYXRpb25cIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiIH0sXG4gICAgXCJleGRhdGVcIjoge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBtdWx0aVZhbHVlOiAnLCdcbiAgICB9LFxuICAgIFwiZXhydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgICBcImZyZWVidXN5XCI6IHsgZGVmYXVsdFR5cGU6IFwicGVyaW9kXCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgXCJnZW9cIjogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gICAgXCJsYXN0LW1vZGlmaWVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImxvY2F0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwibWV0aG9kXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwib3JnYW5pemVyXCI6IHsgZGVmYXVsdFR5cGU6IFwiY2FsLWFkZHJlc3NcIiB9LFxuICAgIFwicGVyY2VudC1jb21wbGV0ZVwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInByaW9yaXR5XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicHJvZGlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwicmVsYXRlZC10b1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInJlcGVhdFwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInJkYXRlXCI6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwicGVyaW9kXCJdLFxuICAgICAgbXVsdGlWYWx1ZTogJywnLFxuICAgICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAncGVyaW9kJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZWN1cnJlbmNlLWlkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwicmVzb3VyY2VzXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwicmVxdWVzdC1zdGF0dXNcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgICBcInJydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgICBcInNlcXVlbmNlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwic3RhdHVzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwic3VtbWFyeVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInRyYW5zcFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInRyaWdnZXJcIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiLCBhbGxvd2VkVHlwZXM6IFtcImR1cmF0aW9uXCIsIFwiZGF0ZS10aW1lXCJdIH0sXG4gICAgXCJ0em9mZnNldGZyb21cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgICBcInR6b2Zmc2V0dG9cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgICBcInR6dXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJ0emlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHpuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH0pO1xuXG4gIC8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbiAgdmFyIHZjYXJkVmFsdWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25WYWx1ZXMsIHtcbiAgICB0ZXh0OiBjcmVhdGVUZXh0VHlwZShGUk9NX1ZDQVJEX05FV0xJTkUsIFRPX1ZDQVJEX05FV0xJTkUpLFxuICAgIHVyaTogY3JlYXRlVGV4dFR5cGUoRlJPTV9WQ0FSRF9ORVdMSU5FLCBUT19WQ0FSRF9ORVdMSU5FKSxcblxuICAgIGRhdGU6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlXCIpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFWYWx1ZVswXSA9PSAnLScgJiYgYVZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgKyBhVmFsdWUuc3Vic3RyKDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYVZhbHVlWzBdID09ICctJyAmJiBhVmFsdWUubGVuZ3RoID09IDcpIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArIGFWYWx1ZS5zdWJzdHIoNSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhcIlRcIiArIGFWYWx1ZSwgXCJ0aW1lXCIpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgc3BsaXR6b25lID0gdmNhcmRWYWx1ZXMudGltZS5fc3BsaXRab25lKGFWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB2YWx1ZSA9IHNwbGl0em9uZVsxXTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1BMSVQ6IFwiLHNwbGl0em9uZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDIsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNCAmJiB2YWx1ZVswXSAhPSAnLScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArICc6JyArIHZhbHVlLnN1YnN0cigyLCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICsgdmFsdWUuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDUgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICAgIHpvbmUgPSB6b25lLnN1YnN0cigwLCAzKSArICc6JyArIHpvbmUuc3Vic3RyKDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBzcGxpdHpvbmUgPSB2Y2FyZFZhbHVlcy50aW1lLl9zcGxpdFpvbmUoYVZhbHVlKTtcbiAgICAgICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHZhbHVlID0gc3BsaXR6b25lWzFdO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cigzLCAyKSArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoNiwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDUgJiYgdmFsdWVbMF0gIT0gJy0nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyB2YWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAzKSArIHZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b25lLmxlbmd0aCA9PSA2ICYmICh6b25lWzBdID09ICctJyB8fCB6b25lWzBdID09ICcrJykpIHtcbiAgICAgICAgICB6b25lID0gem9uZS5zdWJzdHIoMCwgMykgKyB6b25lLnN1YnN0cig0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSArIHpvbmU7XG4gICAgICB9LFxuXG4gICAgICBfc3BsaXRab25lOiBmdW5jdGlvbihhVmFsdWUsIGlzRnJvbUljYWwpIHtcbiAgICAgICAgdmFyIGxhc3RDaGFyID0gYVZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBzaWduQ2hhciA9IGFWYWx1ZS5sZW5ndGggLSAoaXNGcm9tSWNhbCA/IDUgOiA2KTtcbiAgICAgICAgdmFyIHNpZ24gPSBhVmFsdWVbc2lnbkNoYXJdO1xuICAgICAgICB2YXIgem9uZSwgdmFsdWU7XG5cbiAgICAgICAgaWYgKGFWYWx1ZVtsYXN0Q2hhcl0gPT0gJ1onKSB7XG4gICAgICAgICAgem9uZSA9IGFWYWx1ZVtsYXN0Q2hhcl07XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWUuc3Vic3RyKDAsIGxhc3RDaGFyKTtcbiAgICAgICAgfSBlbHNlIGlmIChhVmFsdWUubGVuZ3RoID4gNiAmJiAoc2lnbiA9PSAnLScgfHwgc2lnbiA9PSAnKycpKSB7XG4gICAgICAgICAgem9uZSA9IGFWYWx1ZS5zdWJzdHIoc2lnbkNoYXIpO1xuICAgICAgICAgIHZhbHVlID0gYVZhbHVlLnN1YnN0cigwLCBzaWduQ2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgem9uZSA9IFwiXCI7XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3pvbmUsIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJkYXRlLXRpbWVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGUtdGltZVwiKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlc1snZGF0ZS1hbmQtb3ItdGltZSddLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXNbJ2RhdGUtYW5kLW9yLXRpbWUnXS50b0lDQUwoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJkYXRlLWFuZC1vci10aW1lXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlLWFuZC1vci10aW1lXCIpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICAgIHJldHVybiAocGFydHNbMF0gPyB2Y2FyZFZhbHVlcy5kYXRlLmZyb21JQ0FMKHBhcnRzWzBdKSA6ICcnKSArXG4gICAgICAgICAgICAgICAocGFydHNbMV0gPyAnVCcgKyB2Y2FyZFZhbHVlcy50aW1lLmZyb21JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pICtcbiAgICAgICAgICAgICAgIChwYXJ0c1sxXSA/ICdUJyArIHZjYXJkVmFsdWVzLnRpbWUudG9JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcblxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXN0YW1wOiBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXSxcbiAgICBcImxhbmd1YWdlLXRhZ1wiOiB7XG4gICAgICBtYXRjaGVzOiAvXlthLXpBLVowLTktXSskLyAvLyBDb3VsZCBnbyB3aXRoIGEgbW9yZSBzdHJpY3QgcmVnZXggaGVyZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHZjYXJkUGFyYW1zID0ge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwidGV4dFwiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCJcbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGUtdGltZVwiLCBcImRhdGUtYW5kLW9yLXRpbWVcIixcbiAgICAgICAgICAgICAgIFwidGltZXN0YW1wXCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIixcbiAgICAgICAgICAgICAgIFwibGFuZ3VhZ2UtdGFnXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIHZhciB2Y2FyZFByb3BlcnRpZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcbiAgICBcImFkclwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcImFubml2ZXJzYXJ5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gICAgXCJiZGF5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gICAgXCJjYWxhZHJ1cmlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImNhbHVyaVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiY2xpZW50cGlkbWFwXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gICAgXCJlbWFpbFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImZidXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJmblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImdlbmRlclwiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICAgIFwiZ2VvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJpbXBwXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJrZXlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImtpbmRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJsYW5nXCI6IHsgZGVmYXVsdFR5cGU6IFwibGFuZ3VhZ2UtdGFnXCIgfSxcbiAgICBcImxvZ29cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcIm1lbWJlclwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiblwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcIm5pY2tuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwibm90ZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcIm9yZ1wiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuICAgIFwicGhvdG9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInJlbGF0ZWRcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInJldlwiOiB7IGRlZmF1bHRUeXBlOiBcInRpbWVzdGFtcFwiIH0sXG4gICAgXCJyb2xlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwic291bmRcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInNvdXJjZVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwidGVsXCI6IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIsIGFsbG93ZWRUeXBlczogW1widXJpXCIsIFwidGV4dFwiXSB9LFxuICAgIFwidGl0bGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0elwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ0ZXh0XCIsIFwidXRjLW9mZnNldFwiLCBcInVyaVwiXSB9LFxuICAgIFwieG1sXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH0pO1xuXG4gIHZhciB2Y2FyZDNWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIGJpbmFyeTogaWNhbFZhbHVlcy5iaW5hcnksXG4gICAgZGF0ZTogdmNhcmRWYWx1ZXMuZGF0ZSxcbiAgICBcImRhdGUtdGltZVwiOiB2Y2FyZFZhbHVlc1tcImRhdGUtdGltZVwiXSxcbiAgICBcInBob25lLW51bWJlclwiOiB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvKiAuLi4gKi9cbiAgICB9LFxuICAgIHVyaTogaWNhbFZhbHVlcy51cmksXG4gICAgdGV4dDogaWNhbFZhbHVlcy50ZXh0LFxuICAgIHRpbWU6IGljYWxWYWx1ZXMudGltZSxcbiAgICB2Y2FyZDogaWNhbFZhbHVlcy50ZXh0LFxuICAgIFwidXRjLW9mZnNldFwiOiB7XG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA3KTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNyk7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHZjYXJkM1BhcmFtcyA9IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcInRleHRcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJ0ZXh0XCIsIFwidXJpXCIsIFwiZGF0ZVwiLCBcImRhdGUtdGltZVwiLCBcInBob25lLW51bWJlclwiLCBcInRpbWVcIixcbiAgICAgICAgICAgICAgIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIiwgXCJ2Y2FyZFwiLCBcImJpbmFyeVwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH1cbiAgfTtcblxuICB2YXIgdmNhcmQzUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuICAgIGZuOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBuOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBuaWNrbmFtZTogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgcGhvdG86IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG4gICAgYmRheToge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcuaW5kZXhPZignVCcpID09PSAtMSkgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRyOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBsYWJlbDogREVGQVVMVF9UWVBFX1RFWFQsXG5cbiAgICB0ZWw6IHsgZGVmYXVsdFR5cGU6IFwicGhvbmUtbnVtYmVyXCIgfSxcbiAgICBlbWFpbDogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbWFpbGVyOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICAgIHR6OiB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ1dGMtb2Zmc2V0XCIsIFwidGV4dFwiXSB9LFxuICAgIGdlbzogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG5cbiAgICB0aXRsZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgcm9sZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbG9nbzogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcbiAgICBhZ2VudDogeyBkZWZhdWx0VHlwZTogXCJ2Y2FyZFwiLCBhbGxvd2VkVHlwZXM6IFtcInZjYXJkXCIsIFwidGV4dFwiLCBcInVyaVwiXSB9LFxuICAgIG9yZzogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcblxuICAgIG5vdGU6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIHByb2RpZDogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgcmV2OiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJzb3J0LXN0cmluZ1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBzb3VuZDogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcblxuICAgIGNsYXNzOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBrZXk6IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidGV4dFwiXSB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBpQ2FsZW5kYXIgZGVzaWduIHNldFxuICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgKi9cbiAgdmFyIGljYWxTZXQgPSB7XG4gICAgdmFsdWU6IGljYWxWYWx1ZXMsXG4gICAgcGFyYW06IGljYWxQYXJhbXMsXG4gICAgcHJvcGVydHk6IGljYWxQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIHZDYXJkIDQuMCBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgdmNhcmRTZXQgPSB7XG4gICAgdmFsdWU6IHZjYXJkVmFsdWVzLFxuICAgIHBhcmFtOiB2Y2FyZFBhcmFtcyxcbiAgICBwcm9wZXJ0eTogdmNhcmRQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIHZDYXJkIDMuMCBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgdmNhcmQzU2V0ID0ge1xuICAgIHZhbHVlOiB2Y2FyZDNWYWx1ZXMsXG4gICAgcGFyYW06IHZjYXJkM1BhcmFtcyxcbiAgICBwcm9wZXJ0eTogdmNhcmQzUHJvcGVydGllc1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzaWduIGRhdGEsIHVzZWQgYnkgdGhlIHBhcnNlciB0byBkZXRlcm1pbmUgdHlwZXMgZm9yIHByb3BlcnRpZXMgYW5kXG4gICAqIG90aGVyIG1ldGFkYXRhIG5lZWRlZCB0byBwcm9kdWNlIGNvcnJlY3QgakNhcmQvakNhbCBkYXRhLlxuICAgKlxuICAgKiBAYWxpYXMgSUNBTC5kZXNpZ25cbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgdmFyIGRlc2lnbiA9IHtcbiAgICAvKipcbiAgICAgKiBBIGRlc2lnblNldCBkZXNjcmliZXMgdmFsdWUsIHBhcmFtZXRlciBhbmQgcHJvcGVydHkgZGF0YS4gSXQgaXMgdXNlZCBieVxuICAgICAqIHRoZXIgcGFyc2VyIGFuZCBzdHJpbmdpZmllciBpbiBjb21wb25lbnRzIGFuZCBwcm9wZXJ0aWVzIHRvIGRldGVybWluZSB0aGV5XG4gICAgICogc2hvdWxkIGJlIHJlcHJlc2VudGVkLlxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gZGVzaWduU2V0XG4gICAgICogQG1lbWJlck9mIElDQUwuZGVzaWduXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHZhbHVlICAgICAgIERlZmluaXRpb25zIGZvciB2YWx1ZSB0eXBlcywga2V5cyBhcmUgdHlwZSBuYW1lc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYXJhbSAgICAgICBEZWZpbml0aW9ucyBmb3IgcGFyYW1zLCBrZXlzIGFyZSBwYXJhbSBuYW1lc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9wZXJ0eSAgICBEZWZpbnRpb25zIGZvciBwcm9wZXJ0aWVzLCBrZXlzIGFyZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHNldCB0byBmYWxzZSB0byBtYWtlIHRoZSBwYXJzZXIgbW9yZSBsZW5pZW50LlxuICAgICAqL1xuICAgIHN0cmljdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNldCBmb3IgbmV3IHByb3BlcnRpZXMgYW5kIGNvbXBvbmVudHMgaWYgbm9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICBkZWZhdWx0U2V0OiBpY2FsU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdHlwZSBmb3IgdW5rbm93biBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBkZWZhdWx0VHlwZTogJ3Vua25vd24nLFxuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIGRlc2lnbiBzZXQgZm9yIGtub3duIHRvcC1sZXZlbCBjb21wb25lbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2Y2FyZCAgICAgICB2Q2FyZCBWQ0FSRFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2ZXZlbnQgICAgICBpQ2FsZW5kYXIgVkVWRU5UXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZ0b2RvICAgICAgIGlDYWxlbmRhciBWVE9ET1xuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2am91cm5hbCAgICBpQ2FsZW5kYXIgVkpPVVJOQUxcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdmFsYXJtICAgICAgaUNhbGVuZGFyIFZBTEFSTVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2dGltZXpvbmUgICBpQ2FsZW5kYXIgVlRJTUVaT05FXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRheWxpZ2h0ICAgIGlDYWxlbmRhciBEQVlMSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBzdGFuZGFyZCAgICBpQ2FsZW5kYXIgU1RBTkRBUkRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHByb3BlcnR5TmFtZSA9ICdmbic7XG4gICAgICogdmFyIGNvbXBvbmVudERlc2lnbiA9IElDQUwuZGVzaWduLmNvbXBvbmVudHMudmNhcmQ7XG4gICAgICogdmFyIHByb3BlcnR5RGV0YWlscyA9IGNvbXBvbmVudERlc2lnbi5wcm9wZXJ0eVtwcm9wZXJ0eU5hbWVdO1xuICAgICAqIGlmIChwcm9wZXJ0eURldGFpbHMuZGVmYXVsdFR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICogICAvLyBZZXAsIHN1cmUgaXMuLi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgY29tcG9uZW50czoge1xuICAgICAgdmNhcmQ6IHZjYXJkU2V0LFxuICAgICAgdmNhcmQzOiB2Y2FyZDNTZXQsXG4gICAgICB2ZXZlbnQ6IGljYWxTZXQsXG4gICAgICB2dG9kbzogaWNhbFNldCxcbiAgICAgIHZqb3VybmFsOiBpY2FsU2V0LFxuICAgICAgdmFsYXJtOiBpY2FsU2V0LFxuICAgICAgdnRpbWV6b25lOiBpY2FsU2V0LFxuICAgICAgZGF5bGlnaHQ6IGljYWxTZXQsXG4gICAgICBzdGFuZGFyZDogaWNhbFNldFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciBpQ2FsZW5kYXIgKHJmYzU1NDUvcmZjNzI2NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIGljYWxlbmRhcjogaWNhbFNldCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB2Q2FyZCAocmZjNjM1MC9yZmM3MDk1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgdmNhcmQ6IHZjYXJkU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmMyNDI1L3JmYzI0MjYvcmZjNzA5NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIHZjYXJkMzogdmNhcmQzU2V0LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVzaWduIHNldCBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudE5hbWUgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9ICAgICAgVGhlIGRlc2lnbiBzZXQgZm9yIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXREZXNpZ25TZXQ6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciBpc0luRGVzaWduID0gY29tcG9uZW50TmFtZSAmJiBjb21wb25lbnROYW1lIGluIGRlc2lnbi5jb21wb25lbnRzO1xuICAgICAgcmV0dXJuIGlzSW5EZXNpZ24gPyBkZXNpZ24uY29tcG9uZW50c1tjb21wb25lbnROYW1lXSA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVzaWduO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGpDYWwgYW5kIGpDYXJkIGRhdGEgYmFjayBpbnRvXG4gKiBpQ2FsZW5kYXIgYW5kIHZDYXJkLlxuICogQG5hbWVzcGFjZVxuICovXG5JQ0FMLnN0cmluZ2lmeSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBMSU5FX0VORElORyA9ICdcXHJcXG4nO1xuICB2YXIgREVGQVVMVF9WQUxVRV9UWVBFID0gJ3Vua25vd24nO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcbiAgdmFyIGhlbHBlcnMgPSBJQ0FMLmhlbHBlcnM7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBmdWxsIGpDYWwvakNhcmQgYXJyYXkgaW50byBhIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeVxuICAgKiBAdmFyaWF0aW9uIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGpDYWwgICAgVGhlIGpDYWwvakNhcmQgZG9jdW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgc3RyaW5naWZpZWQgaUNhbGVuZGFyL3ZDYXJkIGRvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdpZnkoakNhbCkge1xuICAgIGlmICh0eXBlb2YgakNhbFswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGNvbXBvbmVudFxuICAgICAgakNhbCA9IFtqQ2FsXTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGpDYWwubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkuY29tcG9uZW50KGpDYWxbaV0pICsgTElORV9FTkRJTkc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBqQ2FsIGNvbXBvbmVudCBhcnJheSBpbnRvIGEgSUNBTCBzdHJpbmcuXG4gICAqIFJlY3Vyc2l2ZSB3aWxsIHJlc29sdmUgc3ViLWNvbXBvbmVudHMuXG4gICAqXG4gICAqIEV4YWN0IGNvbXBvbmVudC9wcm9wZXJ0eSBvcmRlciBpcyBub3Qgc2F2ZWQgYWxsXG4gICAqIHByb3BlcnRpZXMgd2lsbCBjb21lIGJlZm9yZSBzdWJjb21wb25lbnRzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkuY29tcG9uZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudFxuICAgKiAgICAgICAgakNhbC9qQ2FyZCBmcmFnbWVudCBvZiBhIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gICAqL1xuICBzdHJpbmdpZnkuY29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50LCBkZXNpZ25TZXQpIHtcbiAgICB2YXIgbmFtZSA9IGNvbXBvbmVudFswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciByZXN1bHQgPSAnQkVHSU46JyArIG5hbWUgKyBMSU5FX0VORElORztcblxuICAgIHZhciBwcm9wcyA9IGNvbXBvbmVudFsxXTtcbiAgICB2YXIgcHJvcElkeCA9IDA7XG4gICAgdmFyIHByb3BMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB2YXIgZGVzaWduU2V0TmFtZSA9IGNvbXBvbmVudFswXTtcbiAgICAvLyByZmM2MzUwIHJlcXVpcmVzIHRoYXQgaW4gdkNhcmQgNC4wIHRoZSBmaXJzdCBjb21wb25lbnQgaXMgdGhlIFZFUlNJT05cbiAgICAvLyBjb21wb25lbnQgd2l0aCBhcyB2YWx1ZSA0LjAsIG5vdGUgdGhhdCAzLjAgZG9lcyBub3QgaGF2ZSB0aGlzIHJlcXVpcmVtZW50LlxuICAgIGlmIChkZXNpZ25TZXROYW1lID09PSAndmNhcmQnICYmIGNvbXBvbmVudFsxXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhKGNvbXBvbmVudFsxXVswXVswXSA9PT0gXCJ2ZXJzaW9uXCIgJiYgY29tcG9uZW50WzFdWzBdWzNdID09PSBcIjQuMFwiKSkge1xuICAgICAgZGVzaWduU2V0TmFtZSA9IFwidmNhcmQzXCI7XG4gICAgfVxuICAgIGRlc2lnblNldCA9IGRlc2lnblNldCB8fCBkZXNpZ24uZ2V0RGVzaWduU2V0KGRlc2lnblNldE5hbWUpO1xuXG4gICAgZm9yICg7IHByb3BJZHggPCBwcm9wTGVuOyBwcm9wSWR4KyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkucHJvcGVydHkocHJvcHNbcHJvcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgc3ViY29tcG9uZW50cyBpZiBub25lIGV4aXN0LCBlLmcuIGluIHZDYXJkLlxuICAgIHZhciBjb21wcyA9IGNvbXBvbmVudFsyXSB8fCBbXTtcbiAgICB2YXIgY29tcElkeCA9IDA7XG4gICAgdmFyIGNvbXBMZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoY29tcHNbY29tcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gJ0VORDonICsgbmFtZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHNpbmdsZSBqQ2FsL2pDYXJkIHByb3BlcnR5IHRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5XG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnR5XG4gICAqICAgICAgICBqQ2FsL2pDYXJkIHByb3BlcnR5IGFycmF5XG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBub0ZvbGRcbiAgICogICAgICAgIElmIHRydWUsIHRoZSBsaW5lIGlzIG5vdCBmb2xkZWRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5naWZ5LnByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHksIGRlc2lnblNldCwgbm9Gb2xkKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBqc05hbWUgPSBwcm9wZXJ0eVswXTtcbiAgICB2YXIgcGFyYW1zID0gcHJvcGVydHlbMV07XG5cbiAgICB2YXIgbGluZSA9IG5hbWU7XG5cbiAgICB2YXIgcGFyYW1OYW1lO1xuICAgIGZvciAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtTmFtZSkpIHtcbiAgICAgICAgdmFyIG11bHRpVmFsdWUgPSAocGFyYW1OYW1lIGluIGRlc2lnblNldC5wYXJhbSkgJiYgZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgICAgaWYgKG11bHRpVmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV0ubXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlKSB7XG4gICAgICAgICAgICBtdWx0aVZhbHVlID0gJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSk7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkubXVsdGlWYWx1ZSh2YWx1ZSwgbXVsdGlWYWx1ZSwgXCJ1bmtub3duXCIsIG51bGwsIGRlc2lnblNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxpbmUgKz0gJzsnICsgcGFyYW1OYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGxpbmUgKz0gJz0nICsgc3RyaW5naWZ5LnByb3BlcnR5VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eS5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyB2YWx1ZXMsIHdlIG11c3QgYXNzdW1lIGEgYmxhbmsgdmFsdWVcbiAgICAgIHJldHVybiBsaW5lICsgJzonO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVR5cGUgPSBwcm9wZXJ0eVsyXTtcblxuICAgIGlmICghZGVzaWduU2V0KSB7XG4gICAgICBkZXNpZ25TZXQgPSBkZXNpZ24uZGVmYXVsdFNldDtcbiAgICB9XG5cbiAgICB2YXIgcHJvcERldGFpbHM7XG4gICAgdmFyIG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gICAgdmFyIGlzRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgaWYgKGpzTmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgIHByb3BEZXRhaWxzID0gZGVzaWduU2V0LnByb3BlcnR5W2pzTmFtZV07XG5cbiAgICAgIGlmICgnbXVsdGlWYWx1ZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IHByb3BEZXRhaWxzLm11bHRpVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gcHJvcERldGFpbHMpICYmIEFycmF5LmlzQXJyYXkocHJvcGVydHlbM10pKSB7XG4gICAgICAgIHN0cnVjdHVyZWRWYWx1ZSA9IHByb3BEZXRhaWxzLnN0cnVjdHVyZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gcHJvcERldGFpbHMuZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWVUeXBlID09PSBERUZBVUxUX1ZBTFVFX1RZUEUpIHtcbiAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZVR5cGUgPT09IERFRkFVTFRfVkFMVUVfVFlQRSkge1xuICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1c2ggdGhlIFZBTFVFIHByb3BlcnR5IGlmIHR5cGUgaXMgbm90IHRoZSBkZWZhdWx0XG4gICAgLy8gZm9yIHRoZSBjdXJyZW50IHByb3BlcnR5LlxuICAgIGlmICghaXNEZWZhdWx0KSB7XG4gICAgICAvLyB2YWx1ZSB3aWxsIG5ldmVyIGNvbnRhaW4gOy86Lywgc28gd2UgZG9uJ3QgZXNjYXBlIGl0IGhlcmUuXG4gICAgICBsaW5lICs9ICc7VkFMVUU9JyArIHZhbHVlVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxpbmUgKz0gJzonO1xuXG4gICAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG11bHRpVmFsdWUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHkuc2xpY2UoMyksIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgbnVsbCwgZGVzaWduU2V0LCBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHlbM10sIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkudmFsdWUocHJvcGVydHlbM10sIHZhbHVlVHlwZSwgZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vRm9sZCA/IGxpbmUgOiBJQ0FMLmhlbHBlcnMuZm9sZGxpbmUobGluZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXNjYXBpbmcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgbWF5IGNvbnRhaW46XG4gICAqXG4gICAqICAgIENPTE9OICg6KSwgU0VNSUNPTE9OICg7KSwgb3IgQ09NTUEgKCwpXG4gICAqXG4gICAqIElmIGFueSBvZiB0aGUgYWJvdmUgYXJlIHByZXNlbnQgdGhlIHJlc3VsdCBpcyB3cmFwcGVkXG4gICAqIGluIGRvdWJsZSBxdW90ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eVZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFJhdyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBHaXZlbiBvciBlc2NhcGVkIHZhbHVlIHdoZW4gbmVlZGVkXG4gICAqL1xuICBzdHJpbmdpZnkucHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICBpZiAoKGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZih2YWx1ZSwgJywnKSA9PT0gLTEpICYmXG4gICAgICAgIChoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YodmFsdWUsICc6JykgPT09IC0xKSAmJlxuICAgICAgICAoaGVscGVycy51bmVzY2FwZWRJbmRleE9mKHZhbHVlLCAnOycpID09PSAtMSkpIHtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBpY2FsIHZhbHVlcyBpbnRvIGEgc2luZ2xlXG4gICAqIHN0cmluZyBiYXNlZCBvbiBhIHR5cGUgYW5kIGEgZGVsaW1pdGVyIHZhbHVlIChsaWtlIFwiLFwiKS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5Lm11bHRpVmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgICAgTGlzdCBvZiB2YWx1ZXMgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsaW0gICAgICBVc2VkIHRvIGpvaW4gdGhlIHZhbHVlcyAoXCIsXCIsIFwiO1wiLCBcIjpcIilcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgTG93ZWNhc2UgaWNhbCB2YWx1ZSB0eXBlXG4gICAqICAgICAgICAobGlrZSBib29sZWFuLCBkYXRlLXRpbWUsIGV0Yy4uKVxuICAgKiBAcGFyYW0gez9TdHJpbmd9IGlubmVyTXVsdGkgSWYgc2V0LCBlYWNoIHZhbHVlIHdpbGwgYWdhaW4gYmUgcHJvY2Vzc2VkXG4gICAqICAgICAgICBVc2VkIGZvciBzdHJ1Y3R1cmVkIHZhbHVlc1xuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcgZm9yIHZhbHVlXG4gICAqL1xuICBzdHJpbmdpZnkubXVsdGlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZGVsaW0sIHR5cGUsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpbm5lck11bHRpICYmIEFycmF5LmlzQXJyYXkodmFsdWVzW2ldKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUodmFsdWVzW2ldLCBpbm5lck11bHRpLCB0eXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LnZhbHVlKHZhbHVlc1tpXSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSAhPT0gKGxlbiAtIDEpKSB7XG4gICAgICAgIHJlc3VsdCArPSBkZWxpbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBzaW5nbGUgaWNhbCB2YWx1ZSBydW5zIHRoZSBhc3NvY2lhdGVkIFwidG9JQ0FMXCIgbWV0aG9kIGZyb20gdGhlXG4gICAqIGRlc2lnbiB2YWx1ZSB0eXBlIGlmIGF2YWlsYWJsZSB0byBjb252ZXJ0IHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWUgICAgICAgQSBmb3JtYXR0ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgICAgICBMb3dlcmNhc2UgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIHR5cGVcbiAgICogIChsaWtlIGJvb2xlYW4sIGRhdGUtdGltZSwgZXRjLi4pXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIGZvciBzaW5nbGUgdmFsdWVcbiAgICovXG4gIHN0cmluZ2lmeS52YWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIGlmICh0eXBlIGluIGRlc2lnblNldC52YWx1ZSAmJiAndG9JQ0FMJyBpbiBkZXNpZ25TZXQudmFsdWVbdHlwZV0pIHtcbiAgICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0udG9JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnN0cmluZ2lmeSBzbyB0aGF0XG4gICAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byB1bmVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICAgKi9cbiAgc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1tcXG5eXCJdL2csIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBSRkM2ODY4X1JFUExBQ0VfTUFQW3hdO1xuICAgIH0pO1xuICB9O1xuICB2YXIgUkZDNjg2OF9SRVBMQUNFX01BUCA9IHsgJ1wiJzogXCJeJ1wiLCBcIlxcblwiOiBcIl5uXCIsIFwiXlwiOiBcIl5eXCIgfTtcblxuICByZXR1cm4gc3RyaW5naWZ5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBwYXJzZSBpQ2FsZW5kYXIgYW5kIHZDYXJkIGRhdGEuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbklDQUwucGFyc2UgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ0hBUiA9IC9bXiBcXHRdLztcbiAgdmFyIE1VTFRJVkFMVUVfREVMSU1JVEVSID0gJywnO1xuICB2YXIgVkFMVUVfREVMSU1JVEVSID0gJzonO1xuICB2YXIgUEFSQU1fREVMSU1JVEVSID0gJzsnO1xuICB2YXIgUEFSQU1fTkFNRV9ERUxJTUlURVIgPSAnPSc7XG4gIHZhciBERUZBVUxUX1ZBTFVFX1RZUEUgPSAndW5rbm93bic7XG4gIHZhciBERUZBVUxUX1BBUkFNX1RZUEUgPSAndGV4dCc7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuICB2YXIgaGVscGVycyA9IElDQUwuaGVscGVycztcblxuICAvKipcbiAgICogQW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgICAgICAgIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqIEBtZW1iZXJvZiBJQ0FMLnBhcnNlXG4gICAqIEBleHRlbmRzIHtFcnJvcn1cbiAgICogQGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBQYXJzZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnUGFyc2VyRXJyb3InO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICBzcGxpdC5zaGlmdCgpO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3BsaXQuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUGFyc2VyRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgaUNhbGVuZGFyIG9yIHZDYXJkIGRhdGEgaW50byBhIHJhdyBqQ2FsIG9iamVjdC4gQ29uc3VsdFxuICAgKiBkb2N1bWVudGF0aW9uIG9uIHRoZSB7QHR1dG9yaWFsIGxheWVyc3xsYXllcnMgb2YgcGFyc2luZ30gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2VcbiAgICogQHZhcmlhdGlvbiBmdW5jdGlvblxuICAgKiBAdG9kbyBGaXggdGhlIEFQSSB0byBiZSBtb3JlIGNsZWFyIG9uIHRoZSByZXR1cm4gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgICAgICBUaGUgc3RyaW5nIGRhdGEgdG8gcGFyc2VcbiAgICogQHJldHVybiB7T2JqZWN0fE9iamVjdFtdfSAgQSBzaW5nbGUgakNhbCBvYmplY3QsIG9yIGFuIGFycmF5IHRoZXJlb2ZcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlcihpbnB1dCkge1xuICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgIHZhciByb290ID0gc3RhdGUuY29tcG9uZW50ID0gW107XG5cbiAgICBzdGF0ZS5zdGFjayA9IFtyb290XTtcblxuICAgIHBhcnNlci5fZWFjaExpbmUoaW5wdXQsIGZ1bmN0aW9uKGVyciwgbGluZSkge1xuICAgICAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZShsaW5lLCBzdGF0ZSk7XG4gICAgfSk7XG5cblxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIHN0aWxsIGl0ZW1zIG9uIHRoZSBzdGFja1xuICAgIC8vIHRocm93IGEgZmF0YWwgZXJyb3IsIGEgY29tcG9uZW50IHdhcyBub3QgY2xvc2VkXG4gICAgLy8gY29ycmVjdGx5IGluIHRoYXQgY2FzZS5cbiAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAnaW52YWxpZCBpY2FsIGJvZHkuIGNvbXBvbmVudCBiZWdhbiBidXQgZGlkIG5vdCBlbmQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHN0YXRlID0gbnVsbDtcblxuICAgIHJldHVybiAocm9vdC5sZW5ndGggPT0gMSA/IHJvb3RbMF0gOiByb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBpQ2FsZW5kYXIgcHJvcGVydHkgdmFsdWUgaW50byB0aGUgakNhbCBmb3IgYSBzaW5nbGUgcHJvcGVydHlcbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UucHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiAgIFRoZSBpQ2FsZW5kYXIgcHJvcGVydHkgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0PX0gZGVzaWduU2V0XG4gICAqICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnR5XG4gICAqL1xuICBwYXJzZXIucHJvcGVydHkgPSBmdW5jdGlvbihzdHIsIGRlc2lnblNldCkge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGNvbXBvbmVudDogW1tdLCBbXV0sXG4gICAgICBkZXNpZ25TZXQ6IGRlc2lnblNldCB8fCBkZXNpZ24uZGVmYXVsdFNldFxuICAgIH07XG4gICAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZShzdHIsIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUuY29tcG9uZW50WzFdWzBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcGFyc2UgYSBjb21wb25lbnQuIFlvdSBjYW4gdXNlIElDQUwucGFyc2UoKSBkaXJlY3RseVxuICAgKiBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5jb21wb25lbnRcbiAgICogQHNlZSBJQ0FMLnBhcnNlKGZ1bmN0aW9uKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgIFRoZSBpQ2FsZW5kYXIgY29tcG9uZW50IHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFRoZSBqQ2FsIE9iamVjdCBjb250YWluaW5nIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHBhcnNlci5jb21wb25lbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VyKHN0cik7XG4gIH07XG5cbiAgLy8gY2xhc3NlcyAmIGNvbnN0YW50c1xuICBwYXJzZXIuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcblxuICAvKipcbiAgICogVGhlIHN0YXRlIGZvciBwYXJzaW5nIGNvbnRlbnQgbGluZXMgZnJvbSBhbiBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgSUNBTC5wYXJzZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBwYXJzZXJTdGF0ZVxuICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0ICAgIFRoZSBkZXNpZ24gc2V0IHRvIHVzZSBmb3IgcGFyc2luZ1xuICAgKiBAcHJvcGVydHkge0lDQUwuQ29tcG9uZW50W119IHN0YWNrICAgICAgICAgICAgIFRoZSBzdGFjayBvZiBjb21wb25lbnRzIGJlaW5nIHByb2Nlc3NlZFxuICAgKiBAcHJvcGVydHkge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgICAgIFRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgc2luZ2xlIGxpbmUgb2YgaUNhbGVuZGFyL3ZDYXJkLCB1cGRhdGluZyB0aGUgc3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9oYW5kbGVDb250ZW50TGluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICAgICAgIFRoZSBjb250ZW50IGxpbmUgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge0lDQUwucGFyc2UucGFyc2VyU3RhdGV9ICAgIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBsaW5lIHBhcnNpbmdcbiAgICovXG4gIHBhcnNlci5faGFuZGxlQ29udGVudExpbmUgPSBmdW5jdGlvbihsaW5lLCBzdGF0ZSkge1xuICAgIC8vIGJyZWFrIHVwIHRoZSBwYXJ0cyBvZiB0aGUgbGluZVxuICAgIHZhciB2YWx1ZVBvcyA9IGxpbmUuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIpO1xuICAgIHZhciBwYXJhbVBvcyA9IGxpbmUuaW5kZXhPZihQQVJBTV9ERUxJTUlURVIpO1xuXG4gICAgdmFyIGxhc3RQYXJhbUluZGV4O1xuICAgIHZhciBsYXN0VmFsdWVQb3M7XG5cbiAgICAvLyBuYW1lIG9mIHByb3BlcnR5IG9yIGJlZ2luL2VuZFxuICAgIHZhciBuYW1lO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBwYXJhbXMgaXMgb25seSBvdmVycmlkZGVuIGlmIHBhcmFtUG9zICE9PSAtMS5cbiAgICAvLyB3ZSBjYW4ndCBkbyBwYXJhbXMgPSBwYXJhbXMgfHwge30gbGF0ZXIgb25cbiAgICAvLyBiZWNhdXNlIGl0IHNhY3JpZmljZXMgb3BzLlxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERpZmZlcmVudCBwcm9wZXJ0eSBjYXNlc1xuICAgICAqXG4gICAgICpcbiAgICAgKiAxLiBSUlVMRTpGUkVRPWZvb1xuICAgICAqICAgIC8vIEZSRVE9IGlzIG5vdCBhIHBhcmFtIGJ1dCB0aGUgdmFsdWVcbiAgICAgKlxuICAgICAqIDIuIEFUVEVOREVFO1JPTEU9UkVRLVBBUlRJQ0lQQU5UO1xuICAgICAqICAgIC8vIFJPTEU9IGlzIGEgcGFyYW0gYmVjYXVzZSA6IGhhcyBub3QgaGFwcGVuZWQgeWV0XG4gICAgICovXG4gICAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgICAgLy8gdmFsdWUgZGVsaW1pdGVyIHRoZW4gaXQgaXMgbm90IGEgcGFyYW1ldGVyLlxuXG4gICAgaWYgKChwYXJhbVBvcyAhPT0gLTEgJiYgdmFsdWVQb3MgIT09IC0xKSkge1xuICAgICAgLy8gd2hlbiB0aGUgcGFyYW1ldGVyIGRlbGltaXRlciBpcyBhZnRlciB0aGVcbiAgICAgIC8vIHZhbHVlIGRlbGltaXRlciB0aGVuIGl0IGlzIG5vdCBhIHBhcmFtZXRlci5cbiAgICAgIGlmIChwYXJhbVBvcyA+IHZhbHVlUG9zKSB7XG4gICAgICAgIHBhcmFtUG9zID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFBhcmFtcztcbiAgICBpZiAocGFyYW1Qb3MgIT09IC0xKSB7XG4gICAgICBuYW1lID0gbGluZS5zdWJzdHJpbmcoMCwgcGFyYW1Qb3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBwYXJzZWRQYXJhbXMgPSBwYXJzZXIuX3BhcnNlUGFyYW1ldGVycyhsaW5lLnN1YnN0cmluZyhwYXJhbVBvcyksIDAsIHN0YXRlLmRlc2lnblNldCk7XG4gICAgICBpZiAocGFyc2VkUGFyYW1zWzJdID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIkludmFsaWQgcGFyYW1ldGVycyBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0gcGFyc2VkUGFyYW1zWzBdO1xuICAgICAgbGFzdFBhcmFtSW5kZXggPSBwYXJzZWRQYXJhbXNbMV0ubGVuZ3RoICsgcGFyc2VkUGFyYW1zWzJdICsgcGFyYW1Qb3M7XG4gICAgICBpZiAoKGxhc3RWYWx1ZVBvcyA9XG4gICAgICAgIGxpbmUuc3Vic3RyaW5nKGxhc3RQYXJhbUluZGV4KS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUikpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGxhc3RQYXJhbUluZGV4ICsgbGFzdFZhbHVlUG9zICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciB2YWx1ZSBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWVQb3MgIT09IC0xKSB7XG4gICAgICAvLyB3aXRob3V0IHBhcm1ldGVycyAoQkVHSU46VkNBRU5EQVIsIENMQVNTOlBVQkxJQylcbiAgICAgIG5hbWUgPSBsaW5lLnN1YnN0cmluZygwLCB2YWx1ZVBvcykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gbGluZS5zdWJzdHJpbmcodmFsdWVQb3MgKyAxKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdiZWdpbicpIHtcbiAgICAgICAgdmFyIG5ld0NvbXBvbmVudCA9IFt2YWx1ZS50b0xvd2VyQ2FzZSgpLCBbXSwgW11dO1xuICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc3RhdGUuY29tcG9uZW50LnB1c2gobmV3Q29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb21wb25lbnRbMl0ucHVzaChuZXdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUuY29tcG9uZW50KTtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50ID0gbmV3Q29tcG9uZW50O1xuICAgICAgICBpZiAoIXN0YXRlLmRlc2lnblNldCkge1xuICAgICAgICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbi5nZXREZXNpZ25TZXQoc3RhdGUuY29tcG9uZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlbmQnKSB7XG4gICAgICAgIHN0YXRlLmNvbXBvbmVudCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiBpdCBpcyBub3QgYmVnaW4vZW5kLCB0aGVuIHRoaXMgaXMgYSBwcm9wZXJ0eSB3aXRoIGFuIGVtcHR5IHZhbHVlLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogSW52YWxpZCBsaW5lLlxuICAgICAgICogVGhlIHJhdGlvbmFsIHRvIHRocm93IGFuIGVycm9yIGlzIHdlIHdpbGxcbiAgICAgICAqIG5ldmVyIGJlIGNlcnRhaW4gdGhhdCB0aGUgcmVzdCBvZiB0aGUgZmlsZVxuICAgICAgICogaXMgc2FuZSBhbmQgaXQgaXMgdW5saWtlbHkgdGhhdCB3ZSBjYW4gc2VyaWFsaXplXG4gICAgICAgKiB0aGUgcmVzdWx0IGNvcnJlY3RseSBlaXRoZXIuXG4gICAgICAgKi9cbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgbGluZSAobm8gdG9rZW4gXCI7XCIgb3IgXCI6XCIpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVR5cGU7XG4gICAgdmFyIG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHByb3BlcnR5RGV0YWlscztcblxuICAgIGlmIChuYW1lIGluIHN0YXRlLmRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgcHJvcGVydHlEZXRhaWxzID0gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5W25hbWVdO1xuXG4gICAgICBpZiAoJ211bHRpVmFsdWUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICBtdWx0aVZhbHVlID0gcHJvcGVydHlEZXRhaWxzLm11bHRpVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgnc3RydWN0dXJlZFZhbHVlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgc3RydWN0dXJlZFZhbHVlID0gcHJvcGVydHlEZXRhaWxzLnN0cnVjdHVyZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICYmICdkZXRlY3RUeXBlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRldGVjdFR5cGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0dGVtcHQgdG8gZGV0ZXJtaW5lIHZhbHVlXG4gICAgaWYgKCF2YWx1ZVR5cGUpIHtcbiAgICAgIGlmICghKCd2YWx1ZScgaW4gcGFyYW1zKSkge1xuICAgICAgICBpZiAocHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlVHlwZSA9IERFRkFVTFRfVkFMVUVfVFlQRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcG9zc2libGUgdG8gYXZvaWQgdGhpcz9cbiAgICAgICAgdmFsdWVUeXBlID0gcGFyYW1zLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIHBhcmFtcy52YWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE5vdGUgb24gYHZhciByZXN1bHRgIGp1Z2dsaW5nOlxuICAgICAqXG4gICAgICogSSBvYnNlcnZlZCB0aGF0IGJ1aWxkaW5nIHRoZSBhcnJheSBpbiBwaWVjZXMgaGFzIGFkdmVyc2VcbiAgICAgKiBlZmZlY3RzIG9uIHBlcmZvcm1hbmNlLCBzbyB3aGVyZSBwb3NzaWJsZSB3ZSBpbmxpbmUgdGhlIGNyZWF0aW9uLlxuICAgICAqIEl0IGlzIGEgbGl0dGxlIHVnbHkgYnV0IHJlc3VsdGVkIGluIH4yMDAwIGFkZGl0aW9uYWwgb3BzL3NlYy5cbiAgICAgKi9cblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgW10sIG11bHRpVmFsdWUsIHN0YXRlLmRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIHJlc3VsdCA9IFtuYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICAgIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlXTtcbiAgICAgIHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBtdWx0aVZhbHVlLCB2YWx1ZVR5cGUsIHJlc3VsdCwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB2YWx1ZVR5cGUsIHN0YXRlLmRlc2lnblNldCwgZmFsc2UpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfVxuICAgIC8vIHJmYzYzNTAgcmVxdWlyZXMgdGhhdCBpbiB2Q2FyZCA0LjAgdGhlIGZpcnN0IGNvbXBvbmVudCBpcyB0aGUgVkVSU0lPTlxuICAgIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gICAgaWYgKHN0YXRlLmNvbXBvbmVudFswXSA9PT0gJ3ZjYXJkJyAmJiBzdGF0ZS5jb21wb25lbnRbMV0ubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAhKG5hbWUgPT09ICd2ZXJzaW9uJyAmJiB2YWx1ZSA9PT0gJzQuMCcpKSB7XG4gICAgICBzdGF0ZS5kZXNpZ25TZXQgPSBkZXNpZ24uZ2V0RGVzaWduU2V0KFwidmNhcmQzXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5jb21wb25lbnRbMV0ucHVzaChyZXN1bHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHZhbHVlIGZyb20gdGhlIHJhdyB2YWx1ZSBpbnRvIHRoZSBqQ2FyZC9qQ2FsIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcGFyc2VWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgICAgICAgT3JpZ2luYWwgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgIFR5cGUgb2YgdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgdmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSB2YXJpZXMgb24gdHlwZVxuICAgKi9cbiAgcGFyc2VyLl9wYXJzZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICdmcm9tSUNBTCcgaW4gZGVzaWduU2V0LnZhbHVlW3R5cGVdKSB7XG4gICAgICByZXR1cm4gZGVzaWduU2V0LnZhbHVlW3R5cGVdLmZyb21JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHBhcmFtZXRlcnMgZnJvbSBhIHN0cmluZyB0byBvYmplY3QuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZVBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgICAgICAgICAgIEEgc2luZ2xlIHVuZm9sZGVkIGxpbmVcbiAgICogQHBhcmFtIHtOdW1lcmljfSBzdGFydCAgICAgICAgIFBvc2l0aW9uIHRvIHN0YXJ0IGxvb2tpbmcgZm9yIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7T2JqZWN0fSBrZXkvdmFsdWUgcGFpcnNcbiAgICovXG4gIHBhcnNlci5fcGFyc2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGRlc2lnblNldCkge1xuICAgIHZhciBsYXN0UGFyYW0gPSBzdGFydDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZGVsaW0gPSBQQVJBTV9OQU1FX0RFTElNSVRFUjtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIG5hbWUsIGxjbmFtZTtcbiAgICB2YXIgdmFsdWUsIHZhbHVlUG9zID0gLTE7XG4gICAgdmFyIHR5cGUsIG11bHRpVmFsdWUsIG12ZGVsaW07XG5cbiAgICAvLyBmaW5kIHRoZSBuZXh0ICc9JyBzaWduXG4gICAgLy8gdXNlIGxhc3RQYXJhbSBhbmQgcG9zIHRvIGZpbmQgbmFtZVxuICAgIC8vIGNoZWNrIGlmIFwiIGlzIHVzZWQgaWYgc28gZ2V0IHZhbHVlIGZyb20gXCItPlwiXG4gICAgLy8gdGhlbiBpbmNyZW1lbnQgcG9zIHRvIGZpbmQgbmV4dCA7XG5cbiAgICB3aGlsZSAoKHBvcyAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgIChwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgZGVsaW0sIHBvcyArIDEpKSAhPT0gLTEpIHtcblxuICAgICAgbmFtZSA9IGxpbmUuc3Vic3RyKGxhc3RQYXJhbSArIDEsIHBvcyAtIGxhc3RQYXJhbSAtIDEpO1xuICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiRW1wdHkgcGFyYW1ldGVyIG5hbWUgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG12ZGVsaW0gPSBmYWxzZTtcbiAgICAgIG11bHRpVmFsdWUgPSBmYWxzZTtcblxuICAgICAgaWYgKGxjbmFtZSBpbiBkZXNpZ25TZXQucGFyYW0gJiYgZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0udmFsdWVUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gREVGQVVMVF9QQVJBTV9UWVBFO1xuICAgICAgfVxuXG4gICAgICBpZiAobGNuYW1lIGluIGRlc2lnblNldC5wYXJhbSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgICAgaWYgKGRlc2lnblNldC5wYXJhbVtsY25hbWVdLm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSkge1xuICAgICAgICAgIG12ZGVsaW0gPSBwYXJzZXIuX3JmYzY4NjhFc2NhcGUoJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dENoYXIgPSBsaW5lW3BvcyArIDFdO1xuICAgICAgaWYgKG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICAgIHZhbHVlUG9zID0gcG9zICsgMjtcbiAgICAgICAgcG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsICdcIicsIHZhbHVlUG9zKTtcbiAgICAgICAgaWYgKG11bHRpVmFsdWUgJiYgcG9zICE9IC0xKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW5kZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ZW5kZWRWYWx1ZSkge1xuICAgICAgICAgICAgICBpZiAobGluZVtwb3MgKyAxXSA9PSBtdWx0aVZhbHVlICYmIGxpbmVbcG9zICsgMl0gPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCAnXCInLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAgICAgJ2ludmFsaWQgbGluZSAobm8gbWF0Y2hpbmcgZG91YmxlIHF1b3RlKSBcIicgKyBsaW5lICsgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cih2YWx1ZVBvcywgcG9zIC0gdmFsdWVQb3MpO1xuICAgICAgICBsYXN0UGFyYW0gPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgUEFSQU1fREVMSU1JVEVSLCBwb3MpO1xuICAgICAgICBpZiAobGFzdFBhcmFtID09PSAtMSkge1xuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZVBvcyA9IHBvcyArIDE7XG5cbiAgICAgICAgLy8gbW92ZSB0byBuZXh0IFwiO1wiXG4gICAgICAgIHZhciBuZXh0UG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFBBUkFNX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgICB2YXIgcHJvcFZhbHVlUG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFZBTFVFX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgICBpZiAocHJvcFZhbHVlUG9zICE9PSAtMSAmJiBuZXh0UG9zID4gcHJvcFZhbHVlUG9zKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGRlbGltaXRlciBpbiB0aGUgcHJvcGVydHkgdmFsdWUsIGxldCdzIHN0b3AgaGVyZVxuICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBubyBcIjtcIlxuICAgICAgICAgIGlmIChwcm9wVmFsdWVQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBuZXh0UG9zID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RQYXJhbSA9IG5leHRQb3M7XG4gICAgICAgICAgcG9zID0gbmV4dFBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gbGluZS5zdWJzdHIodmFsdWVQb3MsIG5leHRQb3MgLSB2YWx1ZVBvcyk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gcGFyc2VyLl9yZmM2ODY4RXNjYXBlKHZhbHVlKTtcbiAgICAgIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICAgIHZhciBkZWxpbWl0ZXIgPSBtdmRlbGltIHx8IG11bHRpVmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGRlbGltaXRlciwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11bHRpVmFsdWUgJiYgKGxjbmFtZSBpbiByZXN1bHQpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtsY25hbWVdKSkge1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdID0gW1xuICAgICAgICAgICAgcmVzdWx0W2xjbmFtZV0sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsY25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcmVzdWx0LCB2YWx1ZSwgdmFsdWVQb3NdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHJmYzY4NjguIEV4cG9zaW5nIHRoaXMgb24gSUNBTC5wYXJzZSBzbyB0aGF0XG4gICAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9yZmM2ODY4RXNjYXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGVzY2FwZWQgdmFsdWVcbiAgICovXG4gIHBhcnNlci5fcmZjNjg2OEVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVwbGFjZSgvXFxeWyduXl0vZywgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFJGQzY4NjhfUkVQTEFDRV9NQVBbeF07XG4gICAgfSk7XG4gIH07XG4gIHZhciBSRkM2ODY4X1JFUExBQ0VfTUFQID0geyBcIl4nXCI6ICdcIicsIFwiXm5cIjogXCJcXG5cIiwgXCJeXlwiOiBcIl5cIiB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIG11bHRpIHZhbHVlIHN0cmluZy4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGVpdGhlciBmb3IgcGFyc2luZ1xuICAgKiBhY3R1YWwgbXVsdGktdmFsdWUgcHJvcGVydHkncyB2YWx1ZXMsIG9yIGZvciBoYW5kbGluZyBwYXJhbWV0ZXIgdmFsdWVzLiBJdFxuICAgKiBjYW4gYmUgdXNlZCBmb3IgYm90aCBtdWx0aS12YWx1ZSBwcm9wZXJ0aWVzIGFuZCBzdHJ1Y3R1cmVkIHZhbHVlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZU11bHRpVmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgVGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBmdWxsIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWxpbSAgICAgIFRoZSBtdWx0aS12YWx1ZSBkZWxpbWl0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgVGhlIHZhbHVlIHR5cGUgdG8gYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7QXJyYXkuPD8+fSByZXN1bHQgICAgICAgIFRoZSBhcnJheSB0byBhcHBlbmQgcmVzdWx0cyB0bywgdmFyaWVzIG9uIHZhbHVlIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlubmVyTXVsdGkgVGhlIGlubmVyIGRlbGltaXRlciB0byBzcGxpdCBlYWNoIHZhbHVlIHdpdGhcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldCAgIFRoZSBkZXNpZ24gZGF0YSBmb3IgdGhpcyB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/fEFycmF5Ljw/Pn0gICAgICAgICAgICBFaXRoZXIgYW4gYXJyYXkgb2YgcmVzdWx0cywgb3IgdGhlIGZpcnN0IHJlc3VsdFxuICAgKi9cbiAgcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUgPSBmdW5jdGlvbihidWZmZXIsIGRlbGltLCB0eXBlLCByZXN1bHQsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGxhc3RQb3MgPSAwO1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoZGVsaW0ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IGVhY2ggcGllY2VcbiAgICB3aGlsZSAoKHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihidWZmZXIsIGRlbGltLCBsYXN0UG9zKSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJzdHIobGFzdFBvcywgcG9zIC0gbGFzdFBvcyk7XG4gICAgICBpZiAoaW5uZXJNdWx0aSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBpbm5lck11bHRpLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIGxhc3RQb3MgPSBwb3MgKyBkZWxpbS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gb24gdGhlIGxhc3QgcGllY2UgdGFrZSB0aGUgcmVzdCBvZiBzdHJpbmdcbiAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJzdHIobGFzdFBvcyk7XG4gICAgaWYgKGlubmVyTXVsdGkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGlubmVyTXVsdGksIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBjb21wbGV0ZSBidWZmZXIgb2YgaUNhbGVuZGFyL3ZDYXJkIGRhdGEgbGluZSBieSBsaW5lLCBjb3JyZWN0bHlcbiAgICogdW5mb2xkaW5nIGNvbnRlbnQuIEVhY2ggbGluZSB3aWxsIGJlIHByb2Nlc3NlZCB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fZWFjaExpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYnVmZmVyIHRvIHByb2Nlc3NcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/U3RyaW5nLCBTdHJpbmcpfSBjYWxsYmFjayAgICBUaGUgY2FsbGJhY2sgZm9yIGVhY2ggbGluZVxuICAgKi9cbiAgcGFyc2VyLl9lYWNoTGluZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB2YXIgbGFzdFBvcyA9IGJ1ZmZlci5zZWFyY2goQ0hBUik7XG4gICAgdmFyIHBvcyA9IGxhc3RQb3M7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGZpcnN0Q2hhcjtcblxuICAgIHZhciBuZXdsaW5lT2Zmc2V0O1xuXG4gICAgZG8ge1xuICAgICAgcG9zID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIGxhc3RQb3MpICsgMTtcblxuICAgICAgaWYgKHBvcyA+IDEgJiYgYnVmZmVyW3BvcyAtIDJdID09PSAnXFxyJykge1xuICAgICAgICBuZXdsaW5lT2Zmc2V0ID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld2xpbmVPZmZzZXQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgIHBvcyA9IGxlbjtcbiAgICAgICAgbmV3bGluZU9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Q2hhciA9IGJ1ZmZlcltsYXN0UG9zXTtcblxuICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gJyAnIHx8IGZpcnN0Q2hhciA9PT0gJ1xcdCcpIHtcbiAgICAgICAgLy8gYWRkIHRvIGxpbmVcbiAgICAgICAgbGluZSArPSBidWZmZXIuc3Vic3RyKFxuICAgICAgICAgIGxhc3RQb3MgKyAxLFxuICAgICAgICAgIHBvcyAtIGxhc3RQb3MgLSAobmV3bGluZU9mZnNldCArIDEpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZSlcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBsaW5lKTtcbiAgICAgICAgLy8gcHVzaCBsaW5lXG4gICAgICAgIGxpbmUgPSBidWZmZXIuc3Vic3RyKFxuICAgICAgICAgIGxhc3RQb3MsXG4gICAgICAgICAgcG9zIC0gbGFzdFBvcyAtIG5ld2xpbmVPZmZzZXRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICB9IHdoaWxlIChwb3MgIT09IGxlbik7XG5cbiAgICAvLyBleHRyYSBlbmRpbmcgbGluZVxuICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgIGlmIChsaW5lLmxlbmd0aClcbiAgICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xuICB9O1xuXG4gIHJldHVybiBwYXJzZXI7XG5cbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Db21wb25lbnQgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgUFJPUEVSVFlfSU5ERVggPSAxO1xuICB2YXIgQ09NUE9ORU5UX0lOREVYID0gMjtcbiAgdmFyIE5BTUVfSU5ERVggPSAwO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFdyYXBzIGEgakNhbCBjb21wb25lbnQsIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGFkZCwgcmVtb3ZlIGFuZFxuICAgKiB1cGRhdGUgc3ViY29tcG9uZW50cyBhbmQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gakNhbCAgICAgICAgIFJhdyBqQ2FsIGNvbXBvbmVudCBkYXRhIE9SIG5hbWUgb2YgbmV3XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gcGFyZW50ICAgICBQYXJlbnQgY29tcG9uZW50IHRvIGFzc29jaWF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KGpDYWwsIHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBqQ2FsIHNwZWMgKG5hbWUsIHByb3BlcnRpZXMsIGNvbXBvbmVudHMpXG4gICAgICBqQ2FsID0gW2pDYWwsIFtdLCBbXV07XG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGZvciBsZWdhY3kgcmVhc29ucy5cbiAgICB0aGlzLmpDYWwgPSBqQ2FsO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgfVxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSHlkcmF0ZWQgcHJvcGVydGllcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgX3Byb3BlcnRpZXMgYXJyYXkgYXQgdGhlIHNhbWVcbiAgICAgKiBwb3NpdGlvbiBhcyBpbiB0aGUgakNhbCBhcnJheSwgc28gaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgYXJyYXkgY29udGFpbnNcbiAgICAgKiB1bmRlZmluZWQgdmFsdWVzIGZvciB1bmh5ZHJkYXRlZCBwcm9wZXJ0aWVzLiBUbyBhdm9pZCBpdGVyYXRpbmcgdGhlXG4gICAgICogYXJyYXkgd2hlbiBjaGVja2luZyBpZiBhbGwgcHJvcGVydGllcyBoYXZlIGJlZW4gaHlkcmF0ZWQsIHdlIHNhdmUgdGhlXG4gICAgICogY291bnQgaGVyZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgY291bnQgYXMgZm9yIF9oeWRyYXRlZFByb3BlcnR5Q291bnQsIGJ1dCBmb3Igc3ViY29tcG9uZW50c1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oeWRyYXRlZENvbXBvbmVudENvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbTkFNRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIGNvbXBvbmVudCwgZS5nLiBpY2FsZW5kYXIgdnMgdmNhcmRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgX2Rlc2lnblNldCgpIHtcbiAgICAgIHZhciBwYXJlbnREZXNpZ24gPSB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5fZGVzaWduU2V0O1xuICAgICAgcmV0dXJuIHBhcmVudERlc2lnbiB8fCBJQ0FMLmRlc2lnbi5nZXREZXNpZ25TZXQodGhpcy5uYW1lKTtcbiAgICB9LFxuXG4gICAgX2h5ZHJhdGVDb21wb25lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXAgPSBuZXcgQ29tcG9uZW50KFxuICAgICAgICB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXVtpbmRleF0sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQrKztcbiAgICAgIHJldHVybiAodGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wKTtcbiAgICB9LFxuXG4gICAgX2h5ZHJhdGVQcm9wZXJ0eTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkoXG4gICAgICAgIHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF1baW5kZXhdLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQrKztcbiAgICAgIHJldHVybiAodGhpcy5fcHJvcGVydGllc1tpbmRleF0gPSBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgZmlyc3Qgc3ViIGNvbXBvbmVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBPcHRpb25hbCBuYW1lIHRvIGZpbHRlciBieVxuICAgICAqIEByZXR1cm4gez9JQ0FMLkNvbXBvbmVudH0gICAgIFRoZSBmb3VuZCBzdWJjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRGaXJzdFN1YmNvbXBvbmVudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgICAgdmFyIGxlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvbXBzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIHdlIHJldHVybiBhIHZhbHVlIChzdHJpY3QgbW9kZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgc3ViIGNvbXBvbmVudHMsIG9wdGlvbmFsbHkgZmlsdGVyaW5nIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgICAgICBPcHRpb25hbCBuYW1lIHRvIGZpbHRlciBieVxuICAgICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50W119ICAgICAgIFRoZSBmb3VuZCBzdWIgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGdldEFsbFN1YmNvbXBvbmVudHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBqQ2FsTGVuID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IGNvbXBzW2ldW05BTUVfSU5ERVhdKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50cyB8fFxuICAgICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHMgfHwgW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSB3aGVuIGEgbmFtZWQgcHJvcGVydHkgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gcHJvcGVydHkgaXMgZm91bmRcbiAgICAgKi9cbiAgICBoYXNQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gMCBpcyBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGZpcnN0IHByb3BlcnR5LCBvcHRpb25hbGx5IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7P0lDQUwuUHJvcGVydHl9ICAgICBUaGUgZm91bmQgcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXRGaXJzdFByb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZVByb3BlcnR5KDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IHByb3BlcnR5J3MgdmFsdWUsIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4gez9TdHJpbmd9ICAgICAgICBUaGUgZm91bmQgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0Rmlyc3RQcm9wZXJ0eShuYW1lKTtcbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcHJvcGVydGllcyBpbiB0aGUgY29tcG9uZW50LCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eVtdfSAgICBMaXN0IG9mIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRBbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgakNhbExlbiA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gcHJvcHNbaV1bTkFNRV9JTkRFWF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMgfHxcbiAgICAgICAgICAgICh0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcyB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZU9iamVjdEJ5SW5kZXg6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIGluZGV4KSB7XG4gICAgICBjYWNoZSA9IGNhY2hlIHx8IFtdO1xuICAgICAgLy8gcmVtb3ZlIGNhY2hlZCB2ZXJzaW9uXG4gICAgICBpZiAoY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciBvYmogPSBjYWNoZVtpbmRleF07XG4gICAgICAgIGlmIChcInBhcmVudFwiIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FjaGUuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGpDYWxcbiAgICAgIHRoaXMuakNhbFtqQ2FsSW5kZXhdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVPYmplY3Q6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIG5hbWVPck9iamVjdCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmpDYWxbakNhbEluZGV4XTtcbiAgICAgIHZhciBsZW4gPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzW2NhY2hlXTtcblxuICAgICAgaWYgKHR5cGVvZihuYW1lT3JPYmplY3QpID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWVPck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FjaGVkKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FjaGVkW2ldICYmIGNhY2hlZFtpXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF9yZW1vdmVBbGxPYmplY3RzOiBmdW5jdGlvbihqQ2FsSW5kZXgsIGNhY2hlLCBuYW1lKSB7XG4gICAgICB2YXIgY2FjaGVkID0gdGhpc1tjYWNoZV07XG5cbiAgICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgaGF2ZSB0byBydW4gdGhyb3VnaCBhbGwgY2hpbGRyZW4gdG8gcmVzZXQgdGhlaXJcbiAgICAgIC8vIHBhcmVudCBwcm9wZXJ0eS5cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5qQ2FsW2pDYWxJbmRleF07XG4gICAgICB2YXIgaSA9IG9iamVjdHMubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gZGVzY2VuZGluZyBzZWFyY2ggcmVxdWlyZWQgYmVjYXVzZSBzcGxpY2VcbiAgICAgIC8vIGlzIHVzZWQgYW5kIHdpbGwgZWZmZWN0IHRoZSBpbmRpY2VzLlxuICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICghbmFtZSB8fCBvYmplY3RzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNpbmdsZSBzdWIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICBUaGUgY29tcG9uZW50IHRvIGFkZFxuICAgICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50fSAgICAgICAgICAgICAgICAgVGhlIHBhc3NlZCBpbiBjb21wb25lbnRcbiAgICAgKi9cbiAgICBhZGRTdWJjb21wb25lbnQ6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQucGFyZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5wYXJlbnQucmVtb3ZlU3ViY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHggPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5wdXNoKGNvbXBvbmVudC5qQ2FsKTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbaWR4IC0gMV0gPSBjb21wb25lbnQ7XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50Kys7XG4gICAgICBjb21wb25lbnQucGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzaW5nbGUgY29tcG9uZW50IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIGEgc3BlY2lmaWNcbiAgICAgKiBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fFN0cmluZ30gbmFtZU9yQ29tcCAgICBOYW1lIG9mIGNvbXBvbmVudCwgb3IgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGNvbXAgaXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVN1YmNvbXBvbmVudDogZnVuY3Rpb24obmFtZU9yQ29tcCkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVPYmplY3QoQ09NUE9ORU5UX0lOREVYLCAnX2NvbXBvbmVudHMnLCBuYW1lT3JDb21wKTtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIG9yIChpZiBnaXZlbikgYWxsIGNvbXBvbmVudHMgYnkgYSBwYXJ0aWN1bGFyXG4gICAgICogbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgIExvd2VyY2FzZSBjb21wb25lbnQgbmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUFsbFN1YmNvbXBvbmVudHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWUpO1xuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB7QGxpbmsgSUNBTC5Qcm9wZXJ0eX0gdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gcHJvcGVydHkgICAgICBUaGUgcHJvcGVydHkgdG8gYWRkXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgIFRoZSBwYXNzZWQgaW4gcHJvcGVydHlcbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghKHByb3BlcnR5IGluc3RhbmNlb2YgSUNBTC5Qcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBpbnN0YW5jZSBvZiBJQ0FMLlByb3BlcnR5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eS5wYXJlbnQpIHtcbiAgICAgICAgcHJvcGVydHkucGFyZW50LnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ucHVzaChwcm9wZXJ0eS5qQ2FsKTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbaWR4IC0gMV0gPSBwcm9wZXJ0eTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgICAgcHJvcGVydHkucGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSBwcm9wZXJ0eSB3aXRoIGEgdmFsdWUgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IHZhbHVlICAgICAgICBQcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGFkZFByb3BlcnR5V2l0aFZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHByb3Auc2V0VmFsdWUodmFsdWUpO1xuXG4gICAgICB0aGlzLmFkZFByb3BlcnR5KHByb3ApO1xuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHdpbGwgdXBkYXRlIG9yIGNyZWF0ZSBhIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBuYW1lXG4gICAgICogYW5kIHNldHMgaXRzIHZhbHVlLiBJZiBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3QsXG4gICAgICogb25seSB0aGUgZmlyc3QgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IHZhbHVlICAgICAgICBQcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHVwZGF0ZVByb3BlcnR5V2l0aFZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmdldEZpcnN0UHJvcGVydHkobmFtZSk7XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHByb3Auc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuYWRkUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNpbmdsZSBwcm9wZXJ0eSBieSBuYW1lIG9yIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWNcbiAgICAgKiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuUHJvcGVydHl9IG5hbWVPclByb3AgICAgIFByb3BlcnR5IG5hbWUgb3IgaW5zdGFuY2UgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgd2hlbiBkZWxldGVkXG4gICAgICovXG4gICAgcmVtb3ZlUHJvcGVydHk6IGZ1bmN0aW9uKG5hbWVPclByb3ApIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlT2JqZWN0KFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lT3JQcm9wKTtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LCBvcHRpb25hbGx5XG4gICAgICogZmlsdGVyZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIFRydWUsIHdoZW4gZGVsZXRlZFxuICAgICAqL1xuICAgIHJlbW92ZUFsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhQUk9QRVJUWV9JTkRFWCwgJ19wcm9wZXJ0aWVzJywgbmFtZSk7XG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC4gVGhlIHJldHVybmVkIG9iamVjdFxuICAgICAqIGlzIGEgbGl2ZSBqQ2FsIG9iamVjdCBhbmQgc2hvdWxkIGJlIGNsb25lZCBpZiBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLnN0cmluZ2lmeS5jb21wb25lbnQoXG4gICAgICAgIHRoaXMuakNhbCwgdGhpcy5fZGVzaWduU2V0XG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHtAbGluayBJQ0FMLkNvbXBvbmVudH0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHRvIHBhcnNlXG4gICAqL1xuICBDb21wb25lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50KElDQUwucGFyc2UuY29tcG9uZW50KHN0cikpO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgTkFNRV9JTkRFWCA9IDA7XG4gIHZhciBQUk9QX0lOREVYID0gMTtcbiAgdmFyIFRZUEVfSU5ERVggPSAyO1xuICB2YXIgVkFMVUVfSU5ERVggPSAzO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBQcm92aWRlcyBhIGxheWVyIG9uIHRvcCBvZiB0aGUgcmF3IGpDYWwgb2JqZWN0IGZvciBtYW5pcHVsYXRpbmcgYSBzaW5nbGVcbiAgICogcHJvcGVydHksIHdpdGggaXRzIHBhcmFtZXRlcnMgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBtdXRhdGlvbnMgZG9uZSBpbiB0aGUgd3JhcHBlclxuICAgKiBkaXJlY3RseSBtdXRhdGUgdGhlIGpDYWwgb2JqZWN0IHVzZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgbmV3IHByb3BlcnRpZXMgYnkgcGFzc2luZ1xuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgKGFzIGEgU3RyaW5nKS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlByb3BlcnR5XG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgcmVwcmVzZW50YXRpb24gT1JcbiAgICogIHRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IHBhcmVudCAgICBQYXJlbnQgY29tcG9uZW50XG4gICAqL1xuICBmdW5jdGlvbiBQcm9wZXJ0eShqQ2FsLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblxuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXZSBhcmUgY3JlYXRpbmcgdGhlIHByb3BlcnR5IGJ5IG5hbWUgYW5kIG5lZWQgdG8gZGV0ZWN0IHRoZSB0eXBlXG4gICAgICB0aGlzLmpDYWwgPSBbakNhbCwge30sIGRlc2lnbi5kZWZhdWx0VHlwZV07XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuakNhbCA9IGpDYWw7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgfVxuXG4gIFByb3BlcnR5LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB0eXBlIGZvciB0aGlzIHByb3BlcnR5XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbVFlQRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgcHJvcGVydHksIGluIGxvd2VyY2FzZS5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBjb21wb25lbnQgZm9yIHRoaXMgcHJvcGVydHkuXG4gICAgICogQHR5cGUge0lDQUwuQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH0sXG5cbiAgICBzZXQgcGFyZW50KHApIHtcbiAgICAgIC8vIEJlZm9yZSBzZXR0aW5nIHRoZSBwYXJlbnQsIGNoZWNrIGlmIHRoZSBkZXNpZ24gc2V0IGhhcyBjaGFuZ2VkLiBJZiBpdFxuICAgICAgLy8gaGFzLCB3ZSBsYXRlciBuZWVkIHRvIHVwZGF0ZSB0aGUgdHlwZSBpZiBpdCB3YXMgdW5rbm93biBiZWZvcmUuXG4gICAgICB2YXIgZGVzaWduU2V0Q2hhbmdlZCA9ICF0aGlzLl9wYXJlbnQgfHwgKHAgJiYgcC5fZGVzaWduU2V0ICE9IHRoaXMuX3BhcmVudC5fZGVzaWduU2V0KTtcblxuICAgICAgdGhpcy5fcGFyZW50ID0gcDtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PSBkZXNpZ24uZGVmYXVsdFR5cGUgJiYgZGVzaWduU2V0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIHByb3BlcnR5LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBfZGVzaWduU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX2Rlc2lnblNldCA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0eXBlIG1ldGFkYXRhIGZyb20gdGhlIGN1cnJlbnQgakNhbCB0eXBlIGFuZCBkZXNpZ24gc2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVzaWduU2V0ID0gdGhpcy5fZGVzaWduU2V0O1xuXG4gICAgICBpZiAodGhpcy50eXBlIGluIGRlc2lnblNldC52YWx1ZSkge1xuICAgICAgICB2YXIgZGVzaWduVHlwZSA9IGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdO1xuXG4gICAgICAgIGlmICgnZGVjb3JhdGUnIGluIGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgICAgICB0aGlzLmlzTXVsdGlWYWx1ZSA9ICgnbXVsdGlWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICAgIHRoaXMuaXNTdHJ1Y3R1cmVkVmFsdWUgPSAoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEh5ZHJhdGUgYSBzaW5nbGUgdmFsdWUuIFRoZSBhY3Qgb2YgaHlkcmF0aW5nIG1lYW5zIHR1cm5pbmcgdGhlIHJhdyBqQ2FsXG4gICAgICogdmFsdWUgaW50byBhIHBvdGVudGlhbGx5IHdyYXBwZWQgb2JqZWN0LCBmb3IgZXhhbXBsZSB7QGxpbmsgSUNBTC5UaW1lfS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIGh5ZHJhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgIFRoZSBkZWNvcmF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgX2h5ZHJhdGVWYWx1ZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl92YWx1ZXMgJiYgdGhpcy5fdmFsdWVzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgICAgaWYgKHRoaXMuakNhbC5sZW5ndGggPD0gKFZBTFVFX0lOREVYICsgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RlY29yYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKFxuICAgICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XVxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRlIGEgc2luZ2xlIHZhbHVlLCByZXR1cm5pbmcgaXRzIHdyYXBwZWQgb2JqZWN0LiBUaGlzIGlzIHVzZWQgYnlcbiAgICAgKiB0aGUgaHlkcmF0ZSBmdW5jdGlvbiB0byBhY3R1YWxseSB3cmFwIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSAgICAgICAgIFRoZSB2YWx1ZSB0byBkZWNvcmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBUaGUgZGVjb3JhdGVkIHZhbHVlXG4gICAgICovXG4gICAgX2RlY29yYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLmRlY29yYXRlKHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5kZWNvcmF0ZSBhIHNpbmdsZSB2YWx1ZSwgcmV0dXJuaW5nIGl0cyByYXcgakNhbCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gdW5kZWNvcmF0ZVxuICAgICAqIEByZXR1cm4gez99ICAgICAgICAgICAgICAgICAgIFRoZSB1bmRlY29yYXRlZCB2YWx1ZVxuICAgICAqL1xuICAgIF91bmRlY29yYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLnVuZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2hpbGUgYWxzbyBoeWRyYXRpbmcgaXQuIFRoZSBwYXNzZWRcbiAgICAgKiB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgZGVjb3JhdGVkIG9yIHVuZGVjb3JhdGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAgIFRoZSBpbmRleCB0byBzZXQgaXQgYXRcbiAgICAgKi9cbiAgICBfc2V0RGVjb3JhdGVkVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAnaWNhbHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgIC8vIGRlY29yYXRlZCB2YWx1ZVxuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF0gPSB0aGlzLl91bmRlY29yYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdmFsdWVcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB0aGlzLl9kZWNvcmF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuakNhbFtQUk9QX0lOREVYXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBmaXJzdCBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdldFBhcmFtZXRlcihuYW1lKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICBuYW1lICAgICBUaGUgcGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsdWUgICAgVGhlIHBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIHNldFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBsY25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgbGNuYW1lIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbSAmJlxuICAgICAgICAgICdtdWx0aVZhbHVlJyBpbiB0aGlzLl9kZXNpZ25TZXQucGFyYW1bbGNuYW1lXSkge1xuICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgVGhlIHBhcmFtZXRlciBuYW1lXG4gICAgICovXG4gICAgcmVtb3ZlUGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvbiB0aGlzIHByb3BlcnR5J3MgbmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICAgIHZhciBkZXNpZ25TZXQgPSB0aGlzLl9kZXNpZ25TZXQ7XG5cbiAgICAgIGlmIChuYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgICB2YXIgZGV0YWlscyA9IGRlc2lnblNldC5wcm9wZXJ0eVtuYW1lXTtcbiAgICAgICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gZGV0YWlscykge1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzaWduLmRlZmF1bHRUeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHR5cGUgb2YgcHJvcGVydHkgYW5kIGNsZWFycyBvdXQgYW55IGV4aXN0aW5nIHZhbHVlcyBvZiB0aGUgY3VycmVudFxuICAgICAqIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgTmV3IGlDQUwgdHlwZSAoc2VlIGRlc2lnbi4qLnZhbHVlcylcbiAgICAgKi9cbiAgICByZXNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0eXBlO1xuICAgICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgRmlyc3QgcHJvcGVydHkgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlVmFsdWUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHZhbHVlcyBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGlzIGNyZWF0ZXMgYW4gYXJyYXkgZHVyaW5nIGVhY2ggY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBMaXN0IG9mIHZhbHVlc1xuICAgICAqL1xuICAgIGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5qQ2FsLmxlbmd0aCAtIFZBTFVFX0lOREVYO1xuXG4gICAgICBpZiAobGVuIDwgMSkge1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSBmb3IgYSBwcm9wZXJ0eSB0byBoYXZlIG5vIHZhbHVlLlxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9oeWRyYXRlVmFsdWUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICByZW1vdmVBbGxWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3ZhbHVlcykge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuakNhbC5sZW5ndGggPSAzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5LiAgV2lsbCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlcy5cbiAgICAgKiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgZm9yIG11bHRpLXZhbHVlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICAgQW4gYXJyYXkgb2YgdmFsdWVzXG4gICAgICovXG4gICAgc2V0VmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIGlmICghdGhpcy5pc011bHRpVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIHRoaXMubmFtZSArICc6IGRvZXMgbm90IG5vdCBzdXBwb3J0IG11bGl0VmFsdWUuXFxuJyArXG4gICAgICAgICAgJ292ZXJyaWRlIGlzTXVsdGlWYWx1ZSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzLnJlbW92ZUFsbFZhbHVlcygpO1xuXG4gICAgICBpZiAobGVuID4gMCAmJlxuICAgICAgICAgIHR5cGVvZih2YWx1ZXNbMF0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICdpY2FsdHlwZScgaW4gdmFsdWVzWzBdKSB7XG4gICAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlc1swXS5pY2FsdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9zZXREZWNvcmF0ZWRWYWx1ZSh2YWx1ZXNbaV0sIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaV0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuIElmIHRoaXMgaXMgYSBtdWx0aS12YWx1ZVxuICAgICAqIHByb3BlcnR5LCBhbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgICAgIE5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgJ2ljYWx0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlc2V0VHlwZSh2YWx1ZS5pY2FsdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIHRoaXMuX3NldERlY29yYXRlZFZhbHVlKHZhbHVlLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gICAgICogaXMgYSBsaXZlIGpDYWwgb2JqZWN0IGFuZCBzaG91bGQgYmUgY2xvbmVkIGlmIG1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eShcbiAgICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXQsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4ge0BsaW5rIElDQUwuUHJvcGVydHl9IGJ5IHBhcnNpbmcgdGhlIHBhc3NlZCBpQ2FsZW5kYXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGlDYWxlbmRhciBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXQ9fSBkZXNpZ25TZXQgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIGlDYWxlbmRhciBwcm9wZXJ0eVxuICAgKi9cbiAgUHJvcGVydHkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgZGVzaWduU2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShJQ0FMLnBhcnNlLnByb3BlcnR5KHN0ciwgZGVzaWduU2V0KSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb3BlcnR5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlV0Y09mZnNldCA9IChmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIFwiZHVyYXRpb25cIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb25cbiAgICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuVXRjT2Zmc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICBUaGUgaG91cnMgZm9yIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmZhY3RvciAgVGhlIGZhY3RvciBmb3IgdGhlIHV0Yy1vZmZzZXQsIGVpdGhlciAtMSBvciAxXG4gICAqL1xuICBmdW5jdGlvbiBVdGNPZmZzZXQoYURhdGEpIHtcbiAgICB0aGlzLmZyb21EYXRhKGFEYXRhKTtcbiAgfVxuXG4gIFV0Y09mZnNldC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaG91cnMgaW4gdGhlIHV0Yy1vZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGhvdXJzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZXMgaW4gdGhlIHV0Yy1vZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1pbnV0ZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2lnbiBvZiB0aGUgdXRjIG9mZnNldCwgMSBmb3IgcG9zaXRpdmUgb2Zmc2V0LCAtMSBmb3IgbmVnYXRpdmVcbiAgICAgKiBvZmZzZXRzLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZmFjdG9yOiAxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInV0Yy1vZmZzZXRcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInV0Yy1vZmZzZXRcIixcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdXRjIG9mZnNldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlV0Y09mZnNldH0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgVGhlIGhvdXJzIGZvciB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24oYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYURhdGEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChhRGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBhRGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc2Vjb25kcyB2YWx1ZS4gVGhlIHNlY29uZHNcbiAgICAgKiB2YWx1ZSBpcyB0cnVuY2F0ZWQgdG8gdGhlIG1pbnV0ZS4gT2Zmc2V0cyBhcmUgd3JhcHBlZCB3aGVuIHRoZSB3b3JsZFxuICAgICAqIGVuZHMsIHRoZSBob3VyIGFmdGVyIFVUQysxNDowMCBpcyBVVEMtMTI6MDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgICBUaGUgc2Vjb25kcyB0byBjb252ZXJ0IGludG8gYW4gb2Zmc2V0XG4gICAgICovXG4gICAgZnJvbVNlY29uZHM6IGZ1bmN0aW9uKGFTZWNvbmRzKSB7XG4gICAgICB2YXIgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgICAgdGhpcy5mYWN0b3IgPSBhU2Vjb25kcyA8IDAgPyAtMSA6IDE7XG4gICAgICB0aGlzLmhvdXJzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyAzNjAwKTtcblxuICAgICAgc2VjcyAtPSAodGhpcy5ob3VycyAqIDM2MDApO1xuICAgICAgdGhpcy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyA2MCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY3VycmVudCBvZmZzZXQgdG8gYSB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgb2Zmc2V0IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB0b1NlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yICogKDYwICogdGhpcy5taW51dGVzICsgMzYwMCAqIHRoaXMuaG91cnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHRoaXMgdXRjIG9mZnNldCB3aXRoIGFub3RoZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlV0Y09mZnNldH0gb3RoZXIgICAgICAgIFRoZSBvdGhlciBvZmZzZXQgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmUob3RoZXIpIHtcbiAgICAgIHZhciBhID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBiID0gb3RoZXIudG9TZWNvbmRzKCk7XG4gICAgICByZXR1cm4gKGEgPiBiKSAtIChiID4gYSk7XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUmFuZ2U6IDk3MjAwIHNlY29uZHMgKHdpdGggMSBob3VyIGluYmV0d2VlbilcbiAgICAgIHZhciBzZWNzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLmZhY3RvcjtcbiAgICAgIHdoaWxlIChzZWNzIDwgLTQzMjAwKSB7IC8vID0gVVRDLTEyOjAwXG4gICAgICAgIHNlY3MgKz0gOTcyMDA7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc2VjcyA+IDUwNDAwKSB7IC8vID0gVVRDKzE0OjAwXG4gICAgICAgIHNlY3MgLT0gOTcyMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJvbVNlY29uZHMoc2Vjcyk7XG5cbiAgICAgIC8vIEF2b2lkIGNoYW5naW5nIHRoZSBmYWN0b3Igd2hlbiBvbiB6ZXJvIHNlY29uZHNcbiAgICAgIGlmIChzZWNzID09IDApIHtcbiAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ3V0Yy1vZmZzZXQnXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHV0Yy1vZmZzZXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy5mYWN0b3IgPT0gMSA/IFwiK1wiIDogXCItXCIpICtcbiAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5ob3VycykgKyAnOicgK1xuICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLm1pbnV0ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhU3RyaW5nICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgVGhlIGNyZWF0ZWQgdXRjLW9mZnNldCBpbnN0YW5jZVxuICAgKi9cbiAgVXRjT2Zmc2V0LmZyb21TdHJpbmcgPSBmdW5jdGlvbihhU3RyaW5nKSB7XG4gICAgLy8gLTA1OjAwXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAvL1RPRE86IHN1cHBvcnQgc2Vjb25kcyBwZXIgcmZjNTU0NSA/XG4gICAgb3B0aW9ucy5mYWN0b3IgPSAoYVN0cmluZ1swXSA9PT0gJysnKSA/IDEgOiAtMTtcbiAgICBvcHRpb25zLmhvdXJzID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFTdHJpbmcuc3Vic3RyKDEsIDIpKTtcbiAgICBvcHRpb25zLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zdWJzdHIoNCwgMikpO1xuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlV0Y09mZnNldChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGNvbnZlcnRcbiAgICovXG4gIFV0Y09mZnNldC5mcm9tU2Vjb25kcyA9IGZ1bmN0aW9uKGFTZWNvbmRzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFV0Y09mZnNldCgpO1xuICAgIGluc3RhbmNlLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIFV0Y09mZnNldDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5CaW5hcnkgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVwcmVzZW50cyB0aGUgQklOQVJZIHZhbHVlIHR5cGUsIHdoaWNoIGNvbnRhaW5zIGV4dHJhIG1ldGhvZHMgZm9yXG4gICAqIGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkJpbmFyeVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgYmluYXJ5IGRhdGEgZm9yIHRoaXMgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEJpbmFyeShhVmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gYVZhbHVlO1xuICB9XG5cbiAgQmluYXJ5LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAZGVmYXVsdCBcImJpbmFyeVwiXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwiYmluYXJ5XCIsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZGVjb2RlIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgVGhlIGJhc2U2NC1kZWNvZGVkIHZhbHVlXG4gICAgICovXG4gICAgZGVjb2RlVmFsdWU6IGZ1bmN0aW9uIGRlY29kZVZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2I2NF9kZWNvZGUodGhpcy52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHBhc3NlZCBwYXJhbWV0ZXIgd2l0aCBiYXNlNjQgYW5kIHNldHMgdGhlIGludGVybmFsXG4gICAgICogdmFsdWUgdG8gdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICBUaGUgcmF3IGJpbmFyeSB2YWx1ZSB0byBlbmNvZGVcbiAgICAgKi9cbiAgICBzZXRFbmNvZGVkVmFsdWU6IGZ1bmN0aW9uIHNldEVuY29kZWRWYWx1ZShhVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9iNjRfZW5jb2RlKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIF9iNjRfZW5jb2RlOiBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGRhdGEpIHtcbiAgICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gICAgICAvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogQmF5cm9uIEd1ZXZhcmFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBQZWxsZW50ZXNxdWUgTWFsZXN1YWRhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBSYWZhxYIgS3VrYXdza2kgKGh0dHA6Ly9rdWthd3NraS5wbClcbiAgICAgIC8vICogICAgIGV4YW1wbGUgMTogYmFzZTY0X2VuY29kZSgnS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAgICAgLy8gKiAgICAgcmV0dXJucyAxOiAnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PSdcbiAgICAgIC8vIG1vemlsbGEgaGFzIHRoaXMgbmF0aXZlXG4gICAgICAvLyAtIGJ1dCBicmVha3MgaW4gMi4wLjAuMTIhXG4gICAgICAvL2lmICh0eXBlb2YgdGhpcy53aW5kb3dbJ2F0b2InXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyAgICByZXR1cm4gYXRvYihkYXRhKTtcbiAgICAgIC8vfVxuICAgICAgdmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiArXG4gICAgICAgICAgICAgICAgXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgIHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICAgIGFjID0gMCxcbiAgICAgICAgZW5jID0gXCJcIixcbiAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgICAgdmFyIHIgPSBkYXRhLmxlbmd0aCAlIDM7XG5cbiAgICAgIHJldHVybiAociA/IGVuYy5zbGljZSgwLCByIC0gMykgOiBlbmMpICsgJz09PScuc2xpY2UociB8fCAzKTtcblxuICAgIH0sXG5cbiAgICBfYjY0X2RlY29kZTogZnVuY3Rpb24gYmFzZTY0X2RlY29kZShkYXRhKSB7XG4gICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgICAgLy8gKyAgICAgIGlucHV0IGJ5OiBBbWFuIEd1cHRhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9kZWNvZGUoJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG4gICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydidG9hJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gICAgcmV0dXJuIGJ0b2EoZGF0YSk7XG4gICAgICAvL31cbiAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGRlYyA9IFwiXCIsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkYXRhICs9ICcnO1xuXG4gICAgICBkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG4gICAgICAgIGgxID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGgyID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGg0ID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgYml0cyA9IGgxIDw8IDE4IHwgaDIgPDwgMTIgfCBoMyA8PCA2IHwgaDQ7XG5cbiAgICAgICAgbzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcbiAgICAgICAgbzIgPSBiaXRzID4+IDggJiAweGZmO1xuICAgICAgICBvMyA9IGJpdHMgJiAweGZmO1xuXG4gICAgICAgIGlmIChoMyA9PSA2NCkge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xKTtcbiAgICAgICAgfSBlbHNlIGlmIChoNCA9PSA2NCkge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yLCBvMyk7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGRlYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgIHJldHVybiBkZWM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBiaW5hcnkgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0cmluZyAgICAgICAgVGhlIGJpbmFyeSB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybiB7SUNBTC5CaW5hcnl9ICAgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgaW5zdGFuY2VcbiAgICovXG4gIEJpbmFyeS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oYVN0cmluZykge1xuICAgIHJldHVybiBuZXcgQmluYXJ5KGFTdHJpbmcpO1xuICB9O1xuXG4gIHJldHVybiBCaW5hcnk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInBlcmlvZFwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgcGFzc2VkIGRhdGEgb2JqZWN0IGNhbm5vdCBjb250YWluIGJvdGggYW5kIGVuZCBkYXRlIGFuZCBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gYURhdGEuc3RhcnQgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gYURhdGEuZW5kICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb249fSBhRGF0YS5kdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHBlcmlvZFxuICAgKi9cbiAgSUNBTC5QZXJpb2QgPSBmdW5jdGlvbiBpY2FscGVyaW9kKGFEYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuXG4gICAgaWYgKGFEYXRhICYmICdzdGFydCcgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5zdGFydCAmJiAhKGFEYXRhLnN0YXJ0IGluc3RhbmNlb2YgSUNBTC5UaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuc3RhcnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLlRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnQgPSBhRGF0YS5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgYURhdGEuZW5kICYmIGFEYXRhLmR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhY2NlcHQgYm90aCBlbmQgYW5kIGR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdlbmQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuZW5kICYmICEoYURhdGEuZW5kIGluc3RhbmNlb2YgSUNBTC5UaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZW5kIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCA9IGFEYXRhLmVuZDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgJ2R1cmF0aW9uJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmR1cmF0aW9uICYmICEoYURhdGEuZHVyYXRpb24gaW5zdGFuY2VvZiBJQ0FMLkR1cmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZHVyYXRpb24gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLkR1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmR1cmF0aW9uID0gYURhdGEuZHVyYXRpb247XG4gICAgfVxuICB9O1xuXG4gIElDQUwuUGVyaW9kLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBzdGFydDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZW5kOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7SUNBTC5EdXJhdGlvbn1cbiAgICAgKi9cbiAgICBkdXJhdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJpY2FscGVyaW9kXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHBlcmlvZFwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInBlcmlvZFwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwicGVyaW9kXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuUGVyaW9kfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgPyB0aGlzLnN0YXJ0LmNsb25lKCkgOiBudWxsLFxuICAgICAgICBlbmQ6IHRoaXMuZW5kID8gdGhpcy5lbmQuY2xvbmUoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uID8gdGhpcy5kdXJhdGlvbi5jbG9uZSgpIDogbnVsbFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2QsIGVpdGhlciBkaXJlY3RseSBvciBieSBzdWJ0cmFjdGluZ1xuICAgICAqIHN0YXJ0IGZyb20gZW5kIGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAgICovXG4gICAgZ2V0RHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQuc3VidHJhY3REYXRlKHRoaXMuc3RhcnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBlbmQgZGF0ZSBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgYWRkaW5nXG4gICAgICogZHVyYXRpb24gdG8gc3RhcnQgZGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgVGhlIGNhbGN1bGF0ZWQgZW5kIGRhdGVcbiAgICAgKi9cbiAgICBnZXRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyBcIi9cIiArICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5zdGFydC50b1N0cmluZygpLCAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbikudG9TdHJpbmcoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQudG9JQ0FMU3RyaW5nKCkgKyBcIi9cIiArXG4gICAgICAgICAgICAgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvSUNBTFN0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5QZXJpb2R9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gcHJvcCAgICBUaGUgcHJvcGVydHkgdGhpcyBwZXJpb2Qgd2lsbCBiZSBvblxuICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICAgICAgVGhlIGNyZWF0ZWQgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlBlcmlvZC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHByb3ApIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgc3RyaW5nIHZhbHVlOiBcIicgKyBzdHIgKyAnXCIgbXVzdCBjb250YWluIGEgXCIvXCIgY2hhci4nXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgc3RhcnQ6IElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcocGFydHNbMF0sIHByb3ApXG4gICAgfTtcblxuICAgIHZhciBlbmQgPSBwYXJ0c1sxXTtcblxuICAgIGlmIChJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcoZW5kKSkge1xuICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IElDQUwuRHVyYXRpb24uZnJvbVN0cmluZyhlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmVuZCA9IElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoZW5kLCBwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuUGVyaW9kKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlBlcmlvZH0gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqIFRoZSBwYXNzZWQgZGF0YSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYm90aCBhbmQgZW5kIGRhdGUgYW5kIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLmVuZCAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbURhdGEgPSBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgIHJldHVybiBuZXcgSUNBTC5QZXJpb2QoYURhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHBlcmlvZCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBqQ2FsIGRhdGEgYXJyYXkuIFRoZSBmaXJzdFxuICAgKiBtZW1iZXIgaXMgYWx3YXlzIHRoZSBzdGFydCBkYXRlIHN0cmluZywgdGhlIHNlY29uZCBtZW1iZXIgaXMgZWl0aGVyIGFcbiAgICogZHVyYXRpb24gb3IgZW5kIGRhdGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZyxTdHJpbmc+fSBhRGF0YSAgICBUaGUgakNhbCBkYXRhIGFycmF5XG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gYVByb3AgICAgICAgICAgIFRoZSBwcm9wZXJ0eSB0aGlzIGpDYWwgZGF0YSBpcyBvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFMZW5pZW50ICAgICAgICAgICAgICBJZiB0cnVlLCBkYXRhIHZhbHVlIGNhbiBiZSBib3RoIGRhdGUgYW5kIGRhdGUtdGltZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICAgICAgICAgICAgICBUaGUgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlBlcmlvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uKGFEYXRhLCBhUHJvcCwgYUxlbmllbnQpIHtcbiAgICBmdW5jdGlvbiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcCkge1xuICAgICAgaWYgKGFMZW5pZW50KSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcoYURhdGFbMV0pKSB7XG4gICAgICByZXR1cm4gSUNBTC5QZXJpb2QuZnJvbURhdGEoe1xuICAgICAgICBzdGFydDogZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFEYXRhWzBdLCBhUHJvcCksXG4gICAgICAgIGR1cmF0aW9uOiBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoYURhdGFbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBlbmQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVsxXSwgYVByb3ApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIERVUkFUSU9OX0xFVFRFUlMgPSAvKFtQRFdITVRTXXsxLDF9KS87XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcImR1cmF0aW9uXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEud2Vla3MgICAgICAgICBEdXJhdGlvbiBpbiB3ZWVrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5taW51dGVzICAgICAgIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uID0gZnVuY3Rpb24gaWNhbGR1cmF0aW9uKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfTtcblxuICBJQ0FMLkR1cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgd2Vla3MgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHdlZWtzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRheXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGRheXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF5cyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgaG91cnM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgbWludXRlczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzZWNvbmRzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZHMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbGR1cmF0aW9uXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbGR1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiZHVyYXRpb25cIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcImR1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gSUNBTC5EdXJhdGlvbi5mcm9tRGF0YSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIHZhbHVlIGV4cHJlc3NlZCBhcyBhIG51bWJlciBvZiBzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHRvU2Vjb25kczogZnVuY3Rpb24gdG9TZWNvbmRzKCkge1xuICAgICAgdmFyIHNlY29uZHMgPSB0aGlzLnNlY29uZHMgKyA2MCAqIHRoaXMubWludXRlcyArIDM2MDAgKiB0aGlzLmhvdXJzICtcbiAgICAgICAgICAgICAgICAgICAgODY0MDAgKiB0aGlzLmRheXMgKyA3ICogODY0MDAgKiB0aGlzLndlZWtzO1xuICAgICAgcmV0dXJuICh0aGlzLmlzTmVnYXRpdmUgPyAtc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgcGFzc2VkIHNlY29uZHMgdmFsdWUgaW50byB0aGlzIGR1cmF0aW9uIG9iamVjdC4gQWZ0ZXJ3YXJkcyxcbiAgICAgKiBtZW1iZXJzIGxpa2Uge0BsaW5rIElDQUwuRHVyYXRpb24jZGF5cyBkYXlzfSBhbmQge0BsaW5rIElDQUwuRHVyYXRpb24jd2Vla3Mgd2Vla3N9IHdpbGwgYmUgc2V0IHVwXG4gICAgICogYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgIFRoZSBkdXJhdGlvbiB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgICBSZXR1cm5zIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmcm9tU2Vjb25kczogZnVuY3Rpb24gZnJvbVNlY29uZHMoYVNlY29uZHMpIHtcbiAgICAgIHZhciBzZWNzID0gTWF0aC5hYnMoYVNlY29uZHMpO1xuXG4gICAgICB0aGlzLmlzTmVnYXRpdmUgPSAoYVNlY29uZHMgPCAwKTtcbiAgICAgIHRoaXMuZGF5cyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gODY0MDApO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZmxhdCBudW1iZXIgb2Ygd2Vla3MsIHVzZSB0aGVtLlxuICAgICAgaWYgKHRoaXMuZGF5cyAlIDcgPT0gMCkge1xuICAgICAgICB0aGlzLndlZWtzID0gdGhpcy5kYXlzIC8gNztcbiAgICAgICAgdGhpcy5kYXlzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2Vla3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZWNzIC09ICh0aGlzLmRheXMgKyA3ICogdGhpcy53ZWVrcykgKiA4NjQwMDtcblxuICAgICAgdGhpcy5ob3VycyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gMzYwMCk7XG4gICAgICBzZWNzIC09IHRoaXMuaG91cnMgKiAzNjAwO1xuXG4gICAgICB0aGlzLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDYwKTtcbiAgICAgIHNlY3MgLT0gdGhpcy5taW51dGVzICogNjA7XG5cbiAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgICAgdmFyIHByb3BzVG9Db3B5ID0gW1wid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwiaXNOZWdhdGl2ZVwiXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvQ29weSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFwcm9wc1RvQ29weS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1RvQ29weVtrZXldO1xuICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHRvIHRoZSBkZWZhdWx0IHZhbHVlcywgaS5lLiBQVDBTXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLndlZWtzID0gMDtcbiAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgICB0aGlzLmhvdXJzID0gMDtcbiAgICAgIHRoaXMubWludXRlcyA9IDA7XG4gICAgICB0aGlzLnNlY29uZHMgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgZHVyYXRpb24gaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYU90aGVyICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYU90aGVyKSB7XG4gICAgICB2YXIgdGhpc1NlY29uZHMgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIG90aGVyU2Vjb25kcyA9IGFPdGhlci50b1NlY29uZHMoKTtcbiAgICAgIHJldHVybiAodGhpc1NlY29uZHMgPiBvdGhlclNlY29uZHMpIC0gKHRoaXNTZWNvbmRzIDwgb3RoZXJTZWNvbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZHVyYXRpb24gaW5zdGFuY2UuIEZvciBleGFtcGxlLCBhIGR1cmF0aW9uIHdpdGggYSB2YWx1ZVxuICAgICAqIG9mIDYxIHNlY29uZHMgd2lsbCBiZSBub3JtYWxpemVkIHRvIDEgbWludXRlIGFuZCAxIHNlY29uZC5cbiAgICAgKi9cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgIHRoaXMuZnJvbVNlY29uZHModGhpcy50b1NlY29uZHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkdXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudG9TZWNvbmRzKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gXCJQVDBTXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSkgc3RyICs9IFwiLVwiO1xuICAgICAgICBzdHIgKz0gXCJQXCI7XG4gICAgICAgIGlmICh0aGlzLndlZWtzKSBzdHIgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgICAgICBpZiAodGhpcy5kYXlzKSBzdHIgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaG91cnMgfHwgdGhpcy5taW51dGVzIHx8IHRoaXMuc2Vjb25kcykge1xuICAgICAgICAgIHN0ciArPSBcIlRcIjtcbiAgICAgICAgICBpZiAodGhpcy5ob3Vycykgc3RyICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICAgICAgICBpZiAodGhpcy5taW51dGVzKSBzdHIgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgICAgICAgaWYgKHRoaXMuc2Vjb25kcykgc3RyICs9IHRoaXMuc2Vjb25kcyArIFwiU1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLkR1cmF0aW9uIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIHNlY29uZHMgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgICBUaGUgbmV3bHkgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tU2Vjb25kcyA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbl9mcm9tX3NlY29uZHMoYVNlY29uZHMpIHtcbiAgICByZXR1cm4gKG5ldyBJQ0FMLkR1cmF0aW9uKCkpLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBhIGNodW5rIG9mIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsZXR0ZXIgdHlwZSBvZiBkdXJhdGlvbiBjaHVua1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbnVtYmVyIG51bWVyaWMgdmFsdWUgb3IgLS8rXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWN0IHRhcmdldCB0byBhc3NpZ24gdmFsdWVzIHRvXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUR1cmF0aW9uQ2h1bmsobGV0dGVyLCBudW1iZXIsIG9iamVjdCkge1xuICAgIHZhciB0eXBlO1xuICAgIHN3aXRjaCAobGV0dGVyKSB7XG4gICAgICBjYXNlICdQJzpcbiAgICAgICAgaWYgKG51bWJlciAmJiBudW1iZXIgPT09ICctJykge1xuICAgICAgICAgIG9iamVjdC5pc05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmlvZFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0QnOlxuICAgICAgICB0eXBlID0gJ2RheXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1cnOlxuICAgICAgICB0eXBlID0gJ3dlZWtzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIJzpcbiAgICAgICAgdHlwZSA9ICdob3Vycyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIHR5cGUgPSAnbWludXRlcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIHR5cGUgPSAnc2Vjb25kcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gTm90IGEgdmFsaWQgY2h1bmtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghbnVtYmVyICYmIG51bWJlciAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE1pc3NpbmcgbnVtYmVyIGJlZm9yZSBcIicgKyBsZXR0ZXIgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgbnVtID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4obnVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IEludmFsaWQgbnVtYmVyIFwiJyArIG51bWJlciArICdcIiBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb2JqZWN0W3R5cGVdID0gbnVtO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGlDYWxlbmRhciBkdXJhdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgVGhlIHJhdyBpY2FsIHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiBpY2FsIHR5cGVcbiAgICovXG4gIElDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiAoc3RyaW5nWzBdID09PSAnUCcgfHwgc3RyaW5nWzFdID09PSAnUCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLkR1cmF0aW9ufSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0ciAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgIFRoZSBjcmVhdGVkIGR1cmF0aW9uIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9zdHJpbmcoYVN0cikge1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgY2h1bmtzID0gMDtcblxuICAgIHdoaWxlICgocG9zID0gYVN0ci5zZWFyY2goRFVSQVRJT05fTEVUVEVSUykpICE9PSAtMSkge1xuICAgICAgdmFyIHR5cGUgPSBhU3RyW3Bvc107XG4gICAgICB2YXIgbnVtZXJpYyA9IGFTdHIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICBhU3RyID0gYVN0ci5zdWJzdHIocG9zICsgMSk7XG5cbiAgICAgIGNodW5rcyArPSBwYXJzZUR1cmF0aW9uQ2h1bmsodHlwZSwgbnVtZXJpYywgZGljdCk7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcyA8IDIpIHtcbiAgICAgIC8vIFRoZXJlIG11c3QgYmUgYXQgbGVhc3QgYSBjaHVuayB3aXRoIFwiUFwiIGFuZCBzb21lIHVuaXQgY2h1bmtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE5vdCBlbm91Z2ggZHVyYXRpb24gY29tcG9uZW50cyBpbiBcIicgKyBhU3RyICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuRHVyYXRpb24oZGljdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBhRGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgICAgICAgIFRoZSBjcmVhdGVhZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tRGF0YSA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbl9mcm9tX2RhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuRHVyYXRpb24oYURhdGEpO1xuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDEyICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBPUFRJT05TID0gW1widHppZFwiLCBcImxvY2F0aW9uXCIsIFwidHpuYW1lc1wiLFxuICAgICAgICAgICAgICAgICBcImxhdGl0dWRlXCIsIFwibG9uZ2l0dWRlXCJdO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRpbWV6b25lIHJlcHJlc2VudGF0aW9uLCBjcmVhdGVkIGJ5IHBhc3NpbmcgaW4gYSB0emlkIGFuZCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB2Y2FsZW5kYXI7XG4gICAqIHZhciB0aW1lem9uZUNvbXAgPSB2Y2FsZW5kYXIuZ2V0Rmlyc3RTdWJjb21wb25lbnQoJ3Z0aW1lem9uZScpO1xuICAgKiB2YXIgdHppZCA9IHRpbWV6b25lQ29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICpcbiAgICogdmFyIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUoe1xuICAgKiAgIGNvbXBvbmVudDogdGltZXpvbmVDb21wLFxuICAgKiAgIHR6aWRcbiAgICogfSk7XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fE9iamVjdH0gZGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xJQ0FMLkNvbXBvbmVudH0gZGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGRhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIElDQUwuVGltZXpvbmUgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmUoZGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB0aGlzLmZyb21EYXRhKGRhdGEpO1xuICB9O1xuXG4gIElDQUwuVGltZXpvbmUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGltZXpvbmUgaWRlbnRpZmllclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdHppZDogXCJcIixcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGxvY2F0aW9uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBsb2NhdGlvbjogXCJcIixcblxuICAgIC8qKlxuICAgICAqIEFsdGVybmF0aXZlIHRpbWV6b25lIG5hbWUsIGZvciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0em5hbWVzOiBcIlwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbGF0aXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxhdGl0dWRlOiAwLjAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSBsb25naXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxvbmdpdHVkZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZ0aW1lem9uZSBjb21wb25lbnQgZm9yIHRoaXMgdGltZXpvbmUuXG4gICAgICogQHR5cGUge0lDQUwuQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGNvbXBvbmVudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB5ZWFyIHRoaXMgdGltZXpvbmUgaGFzIGJlZW4gZXhwYW5kZWQgdG8uIEFsbCB0aW1lem9uZSB0cmFuc2l0aW9uXG4gICAgICogZGF0ZXMgdW50aWwgdGhpcyB5ZWFyIGFyZSBrbm93biBhbmQgY2FuIGJlIHVzZWQgZm9yIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZXhwYW5kZWRVbnRpbFllYXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHRpbWV6b25lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHRpbWV6b25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgICAqICAgICAgICBJZiBhRGF0YSBpcyBhIHNpbXBsZSBvYmplY3QsIHRoZW4gdGhpcyBtZW1iZXIgY2FuIGJlIHNldCB0byBlaXRoZXIgYVxuICAgICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IDA7XG4gICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcblxuICAgICAgaWYgKGFEYXRhIGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRWl0aGVyIGEgY29tcG9uZW50IGlzIHBhc3NlZCBkaXJlY3RseVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIGluIHRoZSBkYXRhIG9iamVjdFxuICAgICAgICBpZiAoYURhdGEgJiYgXCJjb21wb25lbnRcIiBpbiBhRGF0YSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYURhdGEuY29tcG9uZW50ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIHdhcyBwYXNzZWQsIHBhcnNlIGl0IGFzIGEgY29tcG9uZW50XG4gICAgICAgICAgICB2YXIgakNhbCA9IElDQUwucGFyc2UoYURhdGEuY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IElDQUwuQ29tcG9uZW50KGpDYWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYURhdGEuY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHdhcyBhIGNvbXBvbmVudCBhbHJlYWR5LCB0aGVuIGp1c3Qgc2V0IGl0XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhLmNvbXBvbmVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgbnVsbCBvdXQgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgcmVtYWluaW5nIHBhc3NlZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPUFRJT05TKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoT1BUSU9OUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IE9QVElPTlNba2V5XTtcbiAgICAgICAgICAgIGlmIChhRGF0YSAmJiBwcm9wIGluIGFEYXRhKSB7XG4gICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvbmVudCBidXQgbm8gVFpJRCwgYXR0ZW1wdCB0byBnZXQgaXQgZnJvbSB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCAmJiAhdGhpcy50emlkKSB7XG4gICAgICAgIHRoaXMudHppZCA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHV0Y09mZnNldCB0aGUgZ2l2ZW4gdGltZSB3b3VsZCBvY2N1ciBpbiB0aGlzIHRpbWV6b25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHR0ICAgICAgICBUaGUgdGltZSB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHV0YyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24gdXRjT2Zmc2V0KHR0KSB7XG4gICAgICBpZiAodGhpcyA9PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lIHx8IHRoaXMgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnN1cmVDb3ZlcmFnZSh0dC55ZWFyKTtcblxuICAgICAgaWYgKCF0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRfY2hhbmdlID0ge1xuICAgICAgICB5ZWFyOiB0dC55ZWFyLFxuICAgICAgICBtb250aDogdHQubW9udGgsXG4gICAgICAgIGRheTogdHQuZGF5LFxuICAgICAgICBob3VyOiB0dC5ob3VyLFxuICAgICAgICBtaW51dGU6IHR0Lm1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiB0dC5zZWNvbmRcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFuZ2VfbnVtID0gdGhpcy5fZmluZE5lYXJieUNoYW5nZSh0dF9jaGFuZ2UpO1xuICAgICAgdmFyIGNoYW5nZV9udW1fdG9fdXNlID0gLTE7XG4gICAgICB2YXIgc3RlcCA9IDE7XG5cbiAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBiaW4gc2VhcmNoP1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgY2hhbmdlID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtXSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjaGFuZ2UudXRjT2Zmc2V0IDwgY2hhbmdlLnByZXZVdGNPZmZzZXQpIHtcbiAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLCBjaGFuZ2UudXRjT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNtcCA9IElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgY2hhbmdlKTtcblxuICAgICAgICBpZiAoY21wID49IDApIHtcbiAgICAgICAgICBjaGFuZ2VfbnVtX3RvX3VzZSA9IGNoYW5nZV9udW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT0gLTEgJiYgY2hhbmdlX251bV90b191c2UgIT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZV9udW0gKz0gc3RlcDtcblxuICAgICAgICBpZiAoY2hhbmdlX251bSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VfbnVtID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2VdO1xuICAgICAgdmFyIHV0Y09mZnNldF9jaGFuZ2UgPSB6b25lX2NoYW5nZS51dGNPZmZzZXQgLSB6b25lX2NoYW5nZS5wcmV2VXRjT2Zmc2V0O1xuXG4gICAgICBpZiAodXRjT2Zmc2V0X2NoYW5nZSA8IDAgJiYgY2hhbmdlX251bV90b191c2UgPiAwKSB7XG4gICAgICAgIHZhciB0bXBfY2hhbmdlID0gSUNBTC5oZWxwZXJzLmNsb25lKHpvbmVfY2hhbmdlLCB0cnVlKTtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKHRtcF9jaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wX2NoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcblxuICAgICAgICBpZiAoSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4odHRfY2hhbmdlLCB0bXBfY2hhbmdlKSA8IDApIHtcbiAgICAgICAgICB2YXIgcHJldl96b25lX2NoYW5nZSA9IHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtX3RvX3VzZSAtIDFdO1xuXG4gICAgICAgICAgdmFyIHdhbnRfZGF5bGlnaHQgPSBmYWxzZTsgLy8gVE9ET1xuXG4gICAgICAgICAgaWYgKHpvbmVfY2hhbmdlLmlzX2RheWxpZ2h0ICE9IHdhbnRfZGF5bGlnaHQgJiZcbiAgICAgICAgICAgICAgcHJldl96b25lX2NoYW5nZS5pc19kYXlsaWdodCA9PSB3YW50X2RheWxpZ2h0KSB7XG4gICAgICAgICAgICB6b25lX2NoYW5nZSA9IHByZXZfem9uZV9jaGFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8gcmV0dXJuIGlzX2RheWxpZ2h0P1xuICAgICAgcmV0dXJuIHpvbmVfY2hhbmdlLnV0Y09mZnNldDtcbiAgICB9LFxuXG4gICAgX2ZpbmROZWFyYnlDaGFuZ2U6IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9maW5kX25lYXJieV9jaGFuZ2UoY2hhbmdlKSB7XG4gICAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IG1hdGNoXG4gICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5jaGFuZ2VzLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuXG4gICAgICApO1xuXG4gICAgICBpZiAoaWR4ID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWR4O1xuICAgIH0sXG5cbiAgICBfZW5zdXJlQ292ZXJhZ2U6IGZ1bmN0aW9uKGFZZWFyKSB7XG4gICAgICBpZiAoSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPT0gLTEpIHtcbiAgICAgICAgdmFyIHRvZGF5ID0gSUNBTC5UaW1lLm5vdygpO1xuICAgICAgICBJQ0FMLlRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhciA9IHRvZGF5LnllYXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VzRW5kWWVhciA9IGFZZWFyO1xuICAgICAgaWYgKGNoYW5nZXNFbmRZZWFyIDwgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIpIHtcbiAgICAgICAgY2hhbmdlc0VuZFllYXIgPSBJQ0FMLlRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhcjtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlc0VuZFllYXIgKz0gSUNBTC5UaW1lem9uZS5FWFRSQV9DT1ZFUkFHRTtcblxuICAgICAgaWYgKGNoYW5nZXNFbmRZZWFyID4gSUNBTC5UaW1lem9uZS5NQVhfWUVBUikge1xuICAgICAgICBjaGFuZ2VzRW5kWWVhciA9IElDQUwuVGltZXpvbmUuTUFYX1lFQVI7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCB8fCB0aGlzLmV4cGFuZGVkVW50aWxZZWFyIDwgYVllYXIpIHtcbiAgICAgICAgdmFyIHN1YmNvbXBzID0gdGhpcy5jb21wb25lbnQuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgICAgICB2YXIgY29tcExlbiA9IHN1YmNvbXBzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbXBJZHggPSAwO1xuXG4gICAgICAgIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgICAgICAgdGhpcy5fZXhwYW5kQ29tcG9uZW50KFxuICAgICAgICAgICAgc3ViY29tcHNbY29tcElkeF0sIGNoYW5nZXNFbmRZZWFyLCB0aGlzLmNoYW5nZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNvcnQoSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4pO1xuICAgICAgICB0aGlzLmV4cGFuZGVkVW50aWxZZWFyID0gY2hhbmdlc0VuZFllYXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9leHBhbmRDb21wb25lbnQ6IGZ1bmN0aW9uKGFDb21wb25lbnQsIGFZZWFyLCBjaGFuZ2VzKSB7XG4gICAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJkdHN0YXJ0XCIpIHx8XG4gICAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldHRvXCIpIHx8XG4gICAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdHN0YXJ0ID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwiZHRzdGFydFwiKS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICB2YXIgY2hhbmdlO1xuXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0X3R6b2Zmc2V0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0LmZhY3RvciAqIChvZmZzZXQuaG91cnMgKiAzNjAwICsgb2Zmc2V0Lm1pbnV0ZXMgKiA2MCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRfY2hhbmdlcygpIHtcbiAgICAgICAgdmFyIGNoYW5nZWJhc2UgPSB7fTtcbiAgICAgICAgY2hhbmdlYmFzZS5pc19kYXlsaWdodCA9IChhQ29tcG9uZW50Lm5hbWUgPT0gXCJkYXlsaWdodFwiKTtcbiAgICAgICAgY2hhbmdlYmFzZS51dGNPZmZzZXQgPSBjb252ZXJ0X3R6b2Zmc2V0KFxuICAgICAgICAgIGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInR6b2Zmc2V0dG9cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICAgICk7XG5cbiAgICAgICAgY2hhbmdlYmFzZS5wcmV2VXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWJhc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJydWxlXCIpICYmICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwicmRhdGVcIikpIHtcbiAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG4gICAgICAgIGNoYW5nZS55ZWFyID0gZHRzdGFydC55ZWFyO1xuICAgICAgICBjaGFuZ2UubW9udGggPSBkdHN0YXJ0Lm1vbnRoO1xuICAgICAgICBjaGFuZ2UuZGF5ID0gZHRzdGFydC5kYXk7XG4gICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICAgIGNoYW5nZS5zZWNvbmQgPSBkdHN0YXJ0LnNlY29uZDtcblxuICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0gYUNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKFwicmRhdGVcIik7XG4gICAgICAgIGZvciAodmFyIHJkYXRla2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShyZGF0ZWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmRhdGUgPSBwcm9wc1tyZGF0ZWtleV07XG4gICAgICAgICAgdmFyIHRpbWUgPSByZGF0ZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG5cbiAgICAgICAgICBjaGFuZ2UueWVhciA9IHRpbWUueWVhcjtcbiAgICAgICAgICBjaGFuZ2UubW9udGggPSB0aW1lLm1vbnRoO1xuICAgICAgICAgIGNoYW5nZS5kYXkgPSB0aW1lLmRheTtcblxuICAgICAgICAgIGlmICh0aW1lLmlzRGF0ZSkge1xuICAgICAgICAgICAgY2hhbmdlLmhvdXIgPSBkdHN0YXJ0LmhvdXI7XG4gICAgICAgICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgICAgIGlmIChkdHN0YXJ0LnpvbmUgIT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gdGltZS5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IHRpbWUubWludXRlO1xuICAgICAgICAgICAgY2hhbmdlLnNlY29uZCA9IHRpbWUuc2Vjb25kO1xuXG4gICAgICAgICAgICBpZiAodGltZS56b25lICE9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJydWxlID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwicnJ1bGVcIik7XG5cbiAgICAgICAgaWYgKHJydWxlKSB7XG4gICAgICAgICAgcnJ1bGUgPSBycnVsZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG5cbiAgICAgICAgICBpZiAocnJ1bGUudW50aWwgJiYgcnJ1bGUudW50aWwuem9uZSA9PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICBycnVsZS51bnRpbC5hZGp1c3QoMCwgMCwgMCwgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgcnJ1bGUudW50aWwuem9uZSA9IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBycnVsZS5pdGVyYXRvcihkdHN0YXJ0KTtcblxuICAgICAgICAgIHZhciBvY2M7XG4gICAgICAgICAgd2hpbGUgKChvY2MgPSBpdGVyYXRvci5uZXh0KCkpKSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmIChvY2MueWVhciA+IGFZZWFyIHx8ICFvY2MpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYW5nZS55ZWFyID0gb2NjLnllYXI7XG4gICAgICAgICAgICBjaGFuZ2UubW9udGggPSBvY2MubW9udGg7XG4gICAgICAgICAgICBjaGFuZ2UuZGF5ID0gb2NjLmRheTtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gb2NjLmhvdXI7XG4gICAgICAgICAgICBjaGFuZ2UubWludXRlID0gb2NjLm1pbnV0ZTtcbiAgICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSBvY2Muc2Vjb25kO1xuICAgICAgICAgICAgY2hhbmdlLmlzRGF0ZSA9IG9jYy5pc0RhdGU7XG5cbiAgICAgICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0aW1lem9uZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnR6bmFtZXMgPyB0aGlzLnR6bmFtZXMgOiB0aGlzLnR6aWQpO1xuICAgIH1cbiAgfTtcblxuICBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbiA9IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9jb21wYXJlX2NoYW5nZV9mbihhLCBiKSB7XG4gICAgaWYgKGEueWVhciA8IGIueWVhcikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEueWVhciA+IGIueWVhcikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5tb250aCA8IGIubW9udGgpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1vbnRoID4gYi5tb250aCkgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5kYXkgPCBiLmRheSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuZGF5ID4gYi5kYXkpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuaG91ciA8IGIuaG91cikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuaG91ciA+IGIuaG91cikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5taW51dGUgPCBiLm1pbnV0ZSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEubWludXRlID4gYi5taW51dGUpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuc2Vjb25kIDwgYi5zZWNvbmQpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnNlY29uZCA+IGIuc2Vjb25kKSByZXR1cm4gMTtcblxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBkYXRlL3RpbWUgZnJvbSBvbmUgem9uZSB0byB0aGUgbmV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHR0ICAgICAgICAgICAgICAgICAgVGhlIHRpbWUgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IGZyb21fem9uZSAgICAgICBUaGUgc291cmNlIHpvbmUgdG8gY29udmVydCBmcm9tXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdG9fem9uZSAgICAgICAgIFRoZSB0YXJnZXQgem9uZSB0byBjb252ZXJ0IHRvXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBjb252ZXJ0ZWQgZGF0ZS90aW1lIG9iamVjdFxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5jb252ZXJ0X3RpbWUgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfY29udmVydF90aW1lKHR0LCBmcm9tX3pvbmUsIHRvX3pvbmUpIHtcbiAgICBpZiAodHQuaXNEYXRlIHx8XG4gICAgICAgIGZyb21fem9uZS50emlkID09IHRvX3pvbmUudHppZCB8fFxuICAgICAgICBmcm9tX3pvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRvX3pvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICB0dC56b25lID0gdG9fem9uZTtcbiAgICAgIHJldHVybiB0dDtcbiAgICB9XG5cbiAgICB2YXIgdXRjT2Zmc2V0ID0gZnJvbV96b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIC0gdXRjT2Zmc2V0KTtcblxuICAgIHV0Y09mZnNldCA9IHRvX3pvbmUudXRjT2Zmc2V0KHR0KTtcbiAgICB0dC5hZGp1c3QoMCwgMCwgMCwgdXRjT2Zmc2V0KTtcblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZXpvbmUgaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fE9iamVjdH0gYURhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLmxvY2F0aW9uICBUaGUgdGltZXpvbmUgbG9jYXRpb253XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9mcm9tRGF0YShhRGF0YSkge1xuICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWV6b25lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21EYXRhKGFEYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIFVUQyB0aW1lem9uZVxuICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSA9IElDQUwuVGltZXpvbmUuZnJvbURhdGEoe1xuICAgIHR6aWQ6IFwiVVRDXCJcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBsb2NhbCB0aW1lem9uZVxuICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lID0gSUNBTC5UaW1lem9uZS5mcm9tRGF0YSh7XG4gICAgdHppZDogXCJmbG9hdGluZ1wiXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGp1c3QgYSB0aW1lem9uZSBjaGFuZ2Ugb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlICAgICBUaGUgdGltZXpvbmUgY2hhbmdlIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF5cyAgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlcyAgICBUaGUgZXh0cmEgYW1vdW50IG9mIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBzZWNvbmRzXG4gICAqL1xuICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfYWRqdXN0X2NoYW5nZShjaGFuZ2UsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgcmV0dXJuIElDQUwuVGltZS5wcm90b3R5cGUuYWRqdXN0LmNhbGwoXG4gICAgICBjaGFuZ2UsXG4gICAgICBkYXlzLFxuICAgICAgaG91cnMsXG4gICAgICBtaW51dGVzLFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGNoYW5nZVxuICAgICk7XG4gIH07XG5cbiAgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPSAtMTtcbiAgSUNBTC5UaW1lem9uZS5NQVhfWUVBUiA9IDIwMzU7IC8vIFRPRE8gdGhpcyBpcyBiZWNhdXNlIG9mIHRpbWVfdCwgd2hpY2ggd2UgZG9uJ3QgbmVlZC4gU3RpbGwgdXNlZnVsbD9cbiAgSUNBTC5UaW1lem9uZS5FWFRSQV9DT1ZFUkFHRSA9IDU7XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuVGltZXpvbmVTZXJ2aWNlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgem9uZXM7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogU2luZ2xldG9uIGNsYXNzIHRvIGNvbnRhaW4gdGltZXpvbmVzLiAgUmlnaHQgbm93IGl0IGlzIGFsbCBtYW51YWwgcmVnaXN0cnkgaW5cbiAgICogdGhlIGZ1dHVyZSB3ZSBtYXkgdXNlIHRoaXMgY2xhc3MgdG8gZG93bmxvYWQgdGltZXpvbmUgaW5mb3JtYXRpb24gb3IgaGFuZGxlXG4gICAqIGxvYWRpbmcgcHJlLWV4cGFuZGVkIHRpbWV6b25lcy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAYWxpYXMgSUNBTC5UaW1lem9uZVNlcnZpY2VcbiAgICovXG4gIHZhciBUaW1lem9uZVNlcnZpY2UgPSB7XG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHpvbmVzKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHpvbmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciB1dGMgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuXG4gICAgICB6b25lcy5aID0gdXRjO1xuICAgICAgem9uZXMuVVRDID0gdXRjO1xuICAgICAgem9uZXMuR01UID0gdXRjO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGltZXpvbmUgaWQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0emlkICAgICBUaW1lem9uZSBpZGVudGlmaWVyIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIEZhbHNlLCB3aGVuIG5vdCBwcmVzZW50XG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbih0emlkKSB7XG4gICAgICByZXR1cm4gISF6b25lc1t0emlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlRpbWV6b25lfSBUaGUgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbih0emlkKSB7XG4gICAgICByZXR1cm4gem9uZXNbdHppZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHRpbWV6b25lIG9iamVjdCBvciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWVcbiAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRpbWV6b25lLiBEZWZhdWx0cyB0byB0aGUgY29tcG9uZW50J3MgVFpJRCBpZiBub3RcbiAgICAgKiAgICAgICAgcGFzc2VkLlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8SUNBTC5UaW1lem9uZX0gem9uZVxuICAgICAqICAgICAgICBUaGUgaW5pdGlhbGl6ZWQgem9uZSBvciB2dGltZXpvbmUuXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIHRpbWV6b25lKSB7XG4gICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChuYW1lLm5hbWUgPT09ICd2dGltZXpvbmUnKSB7XG4gICAgICAgICAgdGltZXpvbmUgPSBuZXcgSUNBTC5UaW1lem9uZShuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGltZXpvbmUudHppZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZXpvbmUgaW5zdGFuY2VvZiBJQ0FMLlRpbWV6b25lKSB7XG4gICAgICAgIHpvbmVzW25hbWVdID0gdGltZXpvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aW1lem9uZSBtdXN0IGJlIElDQUwuVGltZXpvbmUgb3IgSUNBTC5Db21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlRpbWV6b25lfSBUaGUgcmVtb3ZlZCB0aW1lem9uZSwgb3IgbnVsbCBpZiBub3QgcmVnaXN0ZXJlZFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuIChkZWxldGUgem9uZXNbdHppZF0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXG4gIFRpbWV6b25lU2VydmljZS5yZXNldCgpO1xuXG4gIHJldHVybiBUaW1lem9uZVNlcnZpY2U7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBpQ2FsZW5kYXIgVGltZSByZXByZXNlbnRhdGlvbiAoc2ltaWxhciB0byBKUyBEYXRlIG9iamVjdCkuICBGdWxseVxuICAgKiBpbmRlcGVuZGVudCBvZiBzeXN0ZW0gKE9TKSB0aW1lem9uZSAvIHRpbWUuICBVbmxpa2UgSlMgRGF0ZSwgdGhlIG1vbnRoXG4gICAqIEphbnVhcnkgaXMgMSwgbm90IHplcm8uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gICAqICAgeWVhcjogMjAxMixcbiAgICogICBtb250aDogMTAsXG4gICAqICAgZGF5OiAxMVxuICAgKiAgIG1pbnV0ZTogMCxcbiAgICogICBzZWNvbmQ6IDAsXG4gICAqICAgaXNEYXRlOiBmYWxzZVxuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogQGFsaWFzIElDQUwuVGltZVxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1vbnRoICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1pbnV0ZSAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGRhdGEuaXNEYXRlICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGUgKGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gem9uZSB0aW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgSUNBTC5UaW1lID0gZnVuY3Rpb24gaWNhbHRpbWUoZGF0YSwgem9uZSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyogdGltZSBkZWZhdWx0cyAqL1xuICAgIHRpbWUueWVhciA9IDA7XG4gICAgdGltZS5tb250aCA9IDE7XG4gICAgdGltZS5kYXkgPSAxO1xuICAgIHRpbWUuaG91ciA9IDA7XG4gICAgdGltZS5taW51dGUgPSAwO1xuICAgIHRpbWUuc2Vjb25kID0gMDtcbiAgICB0aW1lLmlzRGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5mcm9tRGF0YShkYXRhLCB6b25lKTtcbiAgfTtcblxuICBJQ0FMLlRpbWUuX2Rvd0NhY2hlID0ge307XG4gIElDQUwuVGltZS5fd25DYWNoZSA9IHt9O1xuXG4gIElDQUwuVGltZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHRpbWVcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJpY2FsdGltZVwiLFxuICAgIF9jYWNoZWRVbml4VGltZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LiBUaGlzIHZhbHVlIG1heSBjaGFuZ2UgYW5kXG4gICAgICogaXMgc3RyaWN0bHkgZGVmaW5lZCBieSB0aGUge0BsaW5rIElDQUwuVGltZSNpc0RhdGUgaXNEYXRlfSBtZW1iZXIuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImRhdGUtdGltZVwiXG4gICAgICovXG4gICAgZ2V0IGljYWx0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNEYXRlID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lem9uZSBmb3IgdGhpcyB0aW1lLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV6b25lfVxuICAgICAqL1xuICAgIHpvbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB1c2VzIHRvIGluZGljYXRlIHRoYXQgYSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBhbmQgdGhlIG5leHQgcmVhZFxuICAgICAqIG9wZXJhdGlvbiBtdXN0IGF0dGVtcHQgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZSAoZm9yIGV4YW1wbGUgY2hhbmdpbmcgdGhlXG4gICAgICogZGF5IHRvIDMzKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlbmRpbmdOb3JtYWxpemF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdGltZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5UaW1lKHRoaXMuX3RpbWUsIHRoaXMuem9uZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIGVwb2NoIHRpbWVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gaWNhbHRpbWVfcmVzZXQoKSB7XG4gICAgICB0aGlzLmZyb21EYXRhKElDQUwuVGltZS5lcG9jaFRpbWUpO1xuICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHRpbWUgaW5zdGFuY2UgdG8gdGhlIGdpdmVuIGRhdGUvdGltZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICAgICAgICBUaGUgeWVhciB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICAgICAgICBUaGUgbW9udGggdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRheSAgICAgICAgICAgICAgVGhlIGRheSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG91ciAgICAgICAgICAgICBUaGUgaG91ciB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlICAgICAgICAgICBUaGUgbWludXRlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgICAgICAgICAgIFRoZSBzZWNvbmQgdG8gc2V0XG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSB0aW1lem9uZSAgVGhlIHRpbWV6b25lIHRvIHNldFxuICAgICAqL1xuICAgIHJlc2V0VG86IGZ1bmN0aW9uIGljYWx0aW1lX3Jlc2V0VG8oeWVhciwgbW9udGgsIGRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCB0aW1lem9uZSkge1xuICAgICAgdGhpcy5mcm9tRGF0YSh7XG4gICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgICAgem9uZTogdGltZXpvbmVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgSmF2YXNjcmlwdCBkYXRlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/RGF0ZX0gYURhdGUgICAgIFRoZSBKYXZhc2NyaXB0IERhdGUgdG8gcmVhZCwgb3IgbnVsbCB0byByZXNldFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlVVRDICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICAgKi9cbiAgICBmcm9tSlNEYXRlOiBmdW5jdGlvbiBpY2FsdGltZV9mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICAgIGlmICghYURhdGUpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHVzZVVUQykge1xuICAgICAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgICAgICAgdGhpcy55ZWFyID0gYURhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgdGhpcy5ob3VyID0gYURhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgICAgdGhpcy55ZWFyID0gYURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgdGhpcy5ob3VyID0gYURhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubW9udGggICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lPX0gYVpvbmUgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgICBpZiAoYURhdGEpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFEYXRhKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFEYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBpY2FsIHR5cGUgY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2ljYWx0eXBlJykgY29udGludWU7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBhRGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYVpvbmUpIHtcbiAgICAgICAgdGhpcy56b25lID0gYVpvbmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhRGF0YSAmJiAhKFwiaXNEYXRlXCIgaW4gYURhdGEpKSB7XG4gICAgICAgIHRoaXMuaXNEYXRlID0gIShcImhvdXJcIiBpbiBhRGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGFEYXRhICYmIChcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgICB0aGlzLmlzRGF0ZSA9IGFEYXRhLmlzRGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFEYXRhICYmIFwidGltZXpvbmVcIiBpbiBhRGF0YSkge1xuICAgICAgICB2YXIgem9uZSA9IElDQUwuVGltZXpvbmVTZXJ2aWNlLmdldChcbiAgICAgICAgICBhRGF0YS50aW1lem9uZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmUgfHwgSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgfVxuXG4gICAgICBpZiAoYURhdGEgJiYgXCJ6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgICAgdGhpcy56b25lID0gYURhdGEuem9uZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnpvbmUpIHtcbiAgICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkYXkgb2Ygd2Vlay5cbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWUud2Vla0RheX1cbiAgICAgKi9cbiAgICBkYXlPZldlZWs6IGZ1bmN0aW9uIGljYWx0aW1lX2RheU9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgZG93Q2FjaGVLZXkgPSAodGhpcy55ZWFyIDw8IDEyKSArICh0aGlzLm1vbnRoIDw8IDgpICsgKHRoaXMuZGF5IDw8IDMpICsgZmlyc3REb3c7XG4gICAgICBpZiAoZG93Q2FjaGVLZXkgaW4gSUNBTC5UaW1lLl9kb3dDYWNoZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzaW5nIFplbGxlcidzIGFsZ29yaXRobVxuICAgICAgdmFyIHEgPSB0aGlzLmRheTtcbiAgICAgIHZhciBtID0gdGhpcy5tb250aCArICh0aGlzLm1vbnRoIDwgMyA/IDEyIDogMCk7XG4gICAgICB2YXIgWSA9IHRoaXMueWVhciAtICh0aGlzLm1vbnRoIDwgMyA/IDEgOiAwKTtcblxuICAgICAgdmFyIGggPSAocSArIFkgKyBJQ0FMLmhlbHBlcnMudHJ1bmMoKChtICsgMSkgKiAyNikgLyAxMCkgKyBJQ0FMLmhlbHBlcnMudHJ1bmMoWSAvIDQpKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodHJ1ZSAvKiBncmVnb3JpYW4gKi8pIHtcbiAgICAgICAgaCArPSBJQ0FMLmhlbHBlcnMudHJ1bmMoWSAvIDEwMCkgKiA2ICsgSUNBTC5oZWxwZXJzLnRydW5jKFkgLyA0MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCArPSA1O1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgdG8gMSA9IHdrc3RcbiAgICAgIGggPSAoKGggKyA3IC0gZmlyc3REb3cpICUgNykgKyAxO1xuICAgICAgSUNBTC5UaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV0gPSBoO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHllYXIuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGRheU9mWWVhcjogZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgICAgdmFyIGlzX2xlYXAgPSAoSUNBTC5UaW1lLmlzTGVhcFllYXIodGhpcy55ZWFyKSA/IDEgOiAwKTtcbiAgICAgIHZhciBkaXlwbSA9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGg7XG4gICAgICByZXR1cm4gZGl5cG1baXNfbGVhcF1bdGhpcy5tb250aCAtIDFdICsgdGhpcy5kYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogd2Vlay4gVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZiB0aGlzXG4gICAgICogaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAgICovXG4gICAgc3RhcnRPZldlZWs6IGZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGFXZWVrU3RhcnQpIHtcbiAgICAgIHZhciBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5IC09ICgodGhpcy5kYXlPZldlZWsoKSArIDcgLSBmaXJzdERvdykgJSA3KTtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZSB3ZWVrLlxuICAgICAqIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpcyBpcyBhXG4gICAgICogZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIHdlZWsgKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZldlZWs6IGZ1bmN0aW9uIGVuZE9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSArPSAoNyAtIHRoaXMuZGF5T2ZXZWVrKCkgKyBmaXJzdERvdyAtIElDQUwuVGltZS5TVU5EQVkpICUgNztcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogbW9udGguIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICAgKi9cbiAgICBzdGFydE9mTW9udGg6IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMTtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZVxuICAgICAqIG1vbnRoLiAgVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZk1vbnRoOiBmdW5jdGlvbiBlbmRPZk1vbnRoKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgocmVzdWx0Lm1vbnRoLCByZXN1bHQueWVhcik7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHllYXIuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgICAqL1xuICAgIHN0YXJ0T2ZZZWFyOiBmdW5jdGlvbiBzdGFydE9mWWVhcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMTtcbiAgICAgIHJlc3VsdC5tb250aCA9IDE7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiB5ZWFyLiAgVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgICAqL1xuICAgIGVuZE9mWWVhcjogZnVuY3Rpb24gZW5kT2ZZZWFyKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgPSAzMTtcbiAgICAgIHJlc3VsdC5tb250aCA9IDEyO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyc3QgY2FsY3VsYXRlcyB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIHRoZW4gcmV0dXJucyB0aGUgZGF5IG9mIHllYXIgZm9yXG4gICAgICogdGhpcyBkYXRlLiBJZiB0aGUgZGF5IGZhbGxzIGludG8gdGhlIHByZXZpb3VzIHllYXIsIHRoZSBkYXkgaXMgemVybyBvciBuZWdhdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhRmlyc3REYXlPZldlZWtcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVGhlIGNhbGN1bGF0ZWQgZGF5IG9mIHllYXJcbiAgICAgKi9cbiAgICBzdGFydERveVdlZWs6IGZ1bmN0aW9uIHN0YXJ0RG95V2VlayhhRmlyc3REYXlPZldlZWspIHtcbiAgICAgIHZhciBmaXJzdERvdyA9IGFGaXJzdERheU9mV2VlayB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5kYXlPZldlZWsoKSAtIGZpcnN0RG93O1xuICAgICAgaWYgKGRlbHRhIDwgMCkgZGVsdGEgKz0gNztcbiAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpIC0gZGVsdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGN1cnJlbnQgeWVhci4gTGV0dGVycyByYW5nZSBmcm9tIEEgLSBHXG4gICAgICogZm9yIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlyICAgICAgICAgICBUaGUgeWVhciB0byByZXRyaWV2ZSB0aGUgbGV0dGVyIGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAgICovXG4gICAgZ2V0RG9taW5pY2FsTGV0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyKHRoaXMueWVhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBudGhXZWVrRGF5IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IG1vbnRoIChub3QgZGF5KS4gIFRoZVxuICAgICAqIHJldHVybmVkIHZhbHVlIGlzIGEgZGF5IHJlbGF0aXZlIHRoZSBtb250aCB0aGF0IHRoaXMgbW9udGggYmVsb25ncyB0byBzb1xuICAgICAqIDEgd291bGQgaW5kaWNhdGUgdGhlIGZpcnN0IG9mIHRoZSBtb250aCBhbmQgNDAgd291bGQgaW5kaWNhdGUgYSBkYXkgaW5cbiAgICAgKiB0aGUgZm9sbG93aW5nIG1vbnRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZldlZWsgICBEYXkgb2YgdGhlIHdlZWsgc2VlIHRoZSBkYXkgbmFtZSBjb25zdGFudHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgIE50aCBvY2N1cnJlbmNlIG9mIGEgZ2l2ZW4gd2VlayBkYXkgdmFsdWVzXG4gICAgICogICAgICAgIG9mIDEgYW5kIDAgYm90aCBpbmRpY2F0ZSB0aGUgZmlyc3Qgd2Vla2RheSBvZiB0aGF0IHR5cGUuIGFQb3MgbWF5XG4gICAgICogICAgICAgIGJlIGVpdGhlciBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBudW1lcmljIHZhbHVlIGluZGljYXRpbmcgYSBkYXkgcmVsYXRpdmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICB0byB0aGUgY3VycmVudCBtb250aCBvZiB0aGlzIHRpbWUgb2JqZWN0XG4gICAgICovXG4gICAgbnRoV2Vla0RheTogZnVuY3Rpb24gaWNhbHRpbWVfbnRoV2Vla0RheShhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5tb250aCwgdGhpcy55ZWFyKTtcbiAgICAgIHZhciB3ZWVrZGF5O1xuICAgICAgdmFyIHBvcyA9IGFQb3M7XG5cbiAgICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICAgIHZhciBvdGhlckRheSA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIG90aGVyRGF5LmRheSA9IDE7XG5cbiAgICAgICAgLy8gYmVjYXVzZSAwIG1lYW5zIG5vIHBvc2l0aW9uIGhhcyBiZWVuIGdpdmVuXG4gICAgICAgIC8vIDEgYW5kIDAgaW5kaWNhdGUgdGhlIHNhbWUgZGF5LlxuICAgICAgICBpZiAocG9zICE9IDApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4dHJhIG51bWVyaWMgdmFsdWVcbiAgICAgICAgICBwb3MtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjdXJyZW50IHN0YXJ0IG9mZnNldCB0byBjdXJyZW50IGRheS5cbiAgICAgICAgc3RhcnQgPSBvdGhlckRheS5kYXk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBkYXkgb2Ygd2Vla1xuICAgICAgICB2YXIgc3RhcnREb3cgPSBvdGhlckRheS5kYXlPZldlZWsoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50XG4gICAgICAgIC8vIGRheSBvZiB0aGUgd2VlayBhbmQgZGVzaXJlZCBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdmFyIG9mZnNldCA9IGFEYXlPZldlZWsgLSBzdGFydERvdztcblxuXG4gICAgICAgIC8vIGlmIHRoZSBvZmZzZXQgZ29lcyBpbnRvIHRoZSBwYXN0XG4gICAgICAgIC8vIHdlZWsgd2UgYWRkIDcgc28gaXQgZ29lcyBpbnRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHdlZWsuIFdlIG9ubHkgd2FudCB0byBnbyBmb3J3YXJkIGluIHRpbWUgaGVyZS5cbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgLy8gdGhpcyBpcyByZWFsbHkgaW1wb3J0YW50IG90aGVyd2lzZSB3ZSB3b3VsZFxuICAgICAgICAgIC8vIGVuZCB1cCB3aXRoIGRhdGVzIGZyb20gaW4gdGhlIHBhc3QuXG4gICAgICAgICAgb2Zmc2V0ICs9IDc7XG5cbiAgICAgICAgLy8gYWRkIG9mZnNldCB0byBzdGFydCBzbyBzdGFydCBpcyB0aGUgc2FtZVxuICAgICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYXMgdGhlIGRlc2lyZWQgZGF5IG9mIHdlZWsuXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcblxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgKGFuZCBtdWx0aXBseSlcbiAgICAgICAgLy8gdGhlIG51bWVyaWMgdmFsdWUgb2YgdGhlIGRheSB3ZSBzdWJ0cmFjdCBpdFxuICAgICAgICAvLyBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbiBzbyBub3QgdG8gYWRkIGl0IHR3aWNlLlxuICAgICAgICBzdGFydCAtPSBhRGF5T2ZXZWVrO1xuXG4gICAgICAgIC8vIHNldCB3ZWVrIGRheVxuICAgICAgICB3ZWVrZGF5ID0gYURheU9mV2VlaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdGhlbiB3ZSBzZXQgaXQgdG8gdGhlIGxhc3QgZGF5IGluIHRoZSBjdXJyZW50IG1vbnRoXG4gICAgICAgIG90aGVyRGF5LmRheSA9IGRheXNJbk1vbnRoO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGVuZHMgd2Vla2RheVxuICAgICAgICB2YXIgZW5kRG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgcG9zKys7XG5cbiAgICAgICAgd2Vla2RheSA9IChlbmREb3cgLSBhRGF5T2ZXZWVrKTtcblxuICAgICAgICBpZiAod2Vla2RheSA8IDApIHtcbiAgICAgICAgICB3ZWVrZGF5ICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICB3ZWVrZGF5ID0gZGF5c0luTW9udGggLSB3ZWVrZGF5O1xuICAgICAgfVxuXG4gICAgICB3ZWVrZGF5ICs9IHBvcyAqIDc7XG5cbiAgICAgIHJldHVybiBzdGFydCArIHdlZWtkYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBjdXJyZW50IHRpbWUgaXMgdGhlIG50aCB3ZWVrZGF5LCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgICAqIG1vbnRoLiAgV2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIHdoZW4gcnVsZSByZXNvbHZlcyBvdXRzaWRlIG9mIGN1cnJlbnRcbiAgICAgKiBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXl9IGFEYXlPZldlZWsgICAgICAgRGF5IG9mIHdlZWsgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgICAgICAgICAgICAgICAgIFJlbGF0aXZlIHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlLCBpZiBpdCBpcyB0aGUgbnRoIHdlZWtkYXlcbiAgICAgKi9cbiAgICBpc050aFdlZWtEYXk6IGZ1bmN0aW9uKGFEYXlPZldlZWssIGFQb3MpIHtcbiAgICAgIHZhciBkb3cgPSB0aGlzLmRheU9mV2VlaygpO1xuXG4gICAgICBpZiAoYVBvcyA9PT0gMCAmJiBkb3cgPT09IGFEYXlPZldlZWspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBwb3NcbiAgICAgIHZhciBkYXkgPSB0aGlzLm50aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcyk7XG5cbiAgICAgIGlmIChkYXkgPT09IHRoaXMuZGF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIElTTyA4NjAxIHdlZWsgbnVtYmVyLiBUaGUgZmlyc3Qgd2VlayBvZiBhIHllYXIgaXMgdGhlXG4gICAgICogd2VlayB0aGF0IGNvbnRhaW5zIHRoZSBmaXJzdCBUaHVyc2RheS4gVGhlIHllYXIgY2FuIGhhdmUgNTMgd2Vla3MsIGlmXG4gICAgICogSmFudWFyeSAxc3QgaXMgYSBGcmlkYXkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoZXJlIGFyZSByZWdpb25zIHdoZXJlIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGlzIHRoZSBvbmUgdGhhdFxuICAgICAqIHN0YXJ0cyBvbiBKYW51YXJ5IDFzdCwgd2hpY2ggbWF5IG9mZnNldCB0aGUgd2VlayBudW1iZXIuIEFsc28sIGlmIGFcbiAgICAgKiBkaWZmZXJlbnQgd2VlayBzdGFydCBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCBhbHNvIGFmZmVjdCB0aGUgd2Vla1xuICAgICAqIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzZWUgSUNBTC5UaW1lLndlZWtPbmVTdGFydHNcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5fSBhV2Vla1N0YXJ0ICAgICAgICBUaGUgd2Vla2RheSB0aGUgd2VlayBzdGFydHMgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBJU08gd2VlayBudW1iZXJcbiAgICAgKi9cbiAgICB3ZWVrTnVtYmVyOiBmdW5jdGlvbiB3ZWVrTnVtYmVyKGFXZWVrU3RhcnQpIHtcbiAgICAgIHZhciB3bkNhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGFXZWVrU3RhcnQ7XG4gICAgICBpZiAod25DYWNoZUtleSBpbiBJQ0FMLlRpbWUuX3duQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY291cnRlc3R5IG9mIEp1bGlhbiBCdWNrbmFsbCwgcHVibGlzaGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICAgLy8gaHR0cDovL3d3dy5ib3lldC5jb20vYXJ0aWNsZXMvcHVibGlzaGVkYXJ0aWNsZXMvY2FsY3VsYXRpbmd0aGVpc293ZWVrbnVtYi5odG1sXG4gICAgICAvLyBwbHVzIHNvbWUgZml4ZXMgdG8gYmUgYWJsZSB0byB1c2UgZGlmZmVyZW50IHdlZWsgc3RhcnRzLlxuICAgICAgdmFyIHdlZWsxO1xuXG4gICAgICB2YXIgZHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICBkdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgdmFyIGlzb3llYXIgPSB0aGlzLnllYXI7XG5cbiAgICAgIGlmIChkdC5tb250aCA9PSAxMiAmJiBkdC5kYXkgPiAyNSkge1xuICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIgKyAxLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICAgIHdlZWsxID0gSUNBTC5UaW1lLndlZWtPbmVTdGFydHMoaXNveWVhciwgYVdlZWtTdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNveWVhcisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICBpZiAoZHQuY29tcGFyZSh3ZWVrMSkgPCAwKSB7XG4gICAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cygtLWlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXlzQmV0d2VlbiA9IChkdC5zdWJ0cmFjdERhdGUod2VlazEpLnRvU2Vjb25kcygpIC8gODY0MDApO1xuICAgICAgdmFyIGFuc3dlciA9IElDQUwuaGVscGVycy50cnVuYyhkYXlzQmV0d2VlbiAvIDcpICsgMTtcbiAgICAgIElDQUwuVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XSA9IGFuc3dlcjtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGR1cmF0aW9uIHRvIHRoZSBjdXJyZW50IHRpbWUuIFRoZSBpbnN0YW5jZSBpcyBtb2RpZmllZCBpblxuICAgICAqIHBsYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9ufSBhRHVyYXRpb24gICAgICAgICBUaGUgZHVyYXRpb24gdG8gYWRkXG4gICAgICovXG4gICAgYWRkRHVyYXRpb246IGZ1bmN0aW9uIGljYWx0aW1lX2FkZChhRHVyYXRpb24pIHtcbiAgICAgIHZhciBtdWx0ID0gKGFEdXJhdGlvbi5pc05lZ2F0aXZlID8gLTEgOiAxKTtcblxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gb3B0aW1pemF0aW9ucyBpdCBpcyBtdWNoXG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBncmFiIGFsbCB0aGUgdmFsdWVzIHVwIGZyb250XG4gICAgICAvLyB0aGVuIHNldCB0aGVtIGRpcmVjdGx5ICh3aGljaCB3aWxsIGF2b2lkIGEgbm9ybWFsaXphdGlvbiBjYWxsKS5cbiAgICAgIC8vIFNvIHdlIGRvbid0IGFjdHVhbGx5IG5vcm1hbGl6ZSB1bnRpbCB3ZSBuZWVkIGl0LlxuICAgICAgdmFyIHNlY29uZCA9IHRoaXMuc2Vjb25kO1xuICAgICAgdmFyIG1pbnV0ZSA9IHRoaXMubWludXRlO1xuICAgICAgdmFyIGhvdXIgPSB0aGlzLmhvdXI7XG4gICAgICB2YXIgZGF5ID0gdGhpcy5kYXk7XG5cbiAgICAgIHNlY29uZCArPSBtdWx0ICogYUR1cmF0aW9uLnNlY29uZHM7XG4gICAgICBtaW51dGUgKz0gbXVsdCAqIGFEdXJhdGlvbi5taW51dGVzO1xuICAgICAgaG91ciArPSBtdWx0ICogYUR1cmF0aW9uLmhvdXJzO1xuICAgICAgZGF5ICs9IG11bHQgKiBhRHVyYXRpb24uZGF5cztcbiAgICAgIGRheSArPSBtdWx0ICogNyAqIGFEdXJhdGlvbi53ZWVrcztcblxuICAgICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgICB0aGlzLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgICAgIHRoaXMuaG91ciA9IGhvdXI7XG4gICAgICB0aGlzLmRheSA9IGRheTtcblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzIChfZXhjbHVkaW5nXyB0aW1lem9uZSkuICBVc2VmdWwgZm9yIGZpbmRpbmdcbiAgICAgKiB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0aW1lIG9iamVjdHMgZXhjbHVkaW5nIHRoZWlyXG4gICAgICogdGltZXpvbmUgZGlmZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYURhdGUgICAgIFRoZSBkYXRlIHRvIHN1YnN0cmFjdFxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgVGhlIGRpZmZlcmVuY2UgYXMgYSBkdXJhdGlvblxuICAgICAqL1xuICAgIHN1YnRyYWN0RGF0ZTogZnVuY3Rpb24gaWNhbHRpbWVfc3VidHJhY3QoYURhdGUpIHtcbiAgICAgIHZhciB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpICsgdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgIHZhciBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKSArIGFEYXRlLnV0Y09mZnNldCgpO1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHRoZSBkYXRlIGRldGFpbHMsIHRha2luZyB0aW1lem9uZXMgaW50byBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFEYXRlICBUaGUgZGF0ZSB0byBzdWJ0cmFjdFxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICBUaGUgZGlmZmVyZW5jZSBpbiBkdXJhdGlvblxuICAgICAqL1xuICAgIHN1YnRyYWN0RGF0ZVR6OiBmdW5jdGlvbiBpY2FsdGltZV9zdWJ0cmFjdF9hYnMoYURhdGUpIHtcbiAgICAgIHZhciB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIG90aGVyID0gYURhdGUudG9Vbml4VGltZSgpO1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoZSBJQ0FMLlRpbWUgaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYU90aGVyICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmUob3RoZXIpIHtcbiAgICAgIHZhciBhID0gdGhpcy50b1VuaXhUaW1lKCk7XG4gICAgICB2YXIgYiA9IG90aGVyLnRvVW5peFRpbWUoKTtcblxuICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgIGlmIChiID4gYSkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIG9ubHkgdGhlIGRhdGUgcGFydCBvZiB0aGlzIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IG90aGVyICAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdHogICAgICAgICAgICBUaGUgdGltZXpvbmUgdG8gY29tcGFyZSBpblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlRGF0ZU9ubHlUejogZnVuY3Rpb24gaWNhbHRpbWVfY29tcGFyZURhdGVPbmx5VHoob3RoZXIsIHR6KSB7XG4gICAgICBmdW5jdGlvbiBjbXAoYXR0cikge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLl9jbXBfYXR0cihhLCBiLCBhdHRyKTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gdGhpcy5jb252ZXJ0VG9ab25lKHR6KTtcbiAgICAgIHZhciBiID0gb3RoZXIuY29udmVydFRvWm9uZSh0eik7XG4gICAgICB2YXIgcmMgPSAwO1xuXG4gICAgICBpZiAoKHJjID0gY21wKFwieWVhclwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgICAgaWYgKChyYyA9IGNtcChcIm1vbnRoXCIpKSAhPSAwKSByZXR1cm4gcmM7XG4gICAgICBpZiAoKHJjID0gY21wKFwiZGF5XCIpKSAhPSAwKSByZXR1cm4gcmM7XG5cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW5zdGFuY2UgaW50byBhbm90aGVyIHRpbWV6b25lLiBUaGUgcmV0dXJuZWQgSUNBTC5UaW1lXG4gICAgICogaW5zdGFuY2UgaXMgYWx3YXlzIGEgY29weS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gem9uZSAgICAgIFRoZSB6b25lIHRvIGNvbnZlcnQgdG9cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICBUaGUgY29weSwgY29udmVydGVkIHRvIHRoZSB6b25lXG4gICAgICovXG4gICAgY29udmVydFRvWm9uZTogZnVuY3Rpb24gY29udmVydFRvWm9uZSh6b25lKSB7XG4gICAgICB2YXIgY29weSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHZhciB6b25lX2VxdWFscyA9ICh0aGlzLnpvbmUudHppZCA9PSB6b25lLnR6aWQpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNEYXRlICYmICF6b25lX2VxdWFscykge1xuICAgICAgICBJQ0FMLlRpbWV6b25lLmNvbnZlcnRfdGltZShjb3B5LCB0aGlzLnpvbmUsIHpvbmUpO1xuICAgICAgfVxuXG4gICAgICBjb3B5LnpvbmUgPSB6b25lO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIFVUQyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lIGluIHRoZSB0aW1lem9uZSBpdCBpc1xuICAgICAqIGluLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVVRDIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgICovXG4gICAgdXRjT2Zmc2V0OiBmdW5jdGlvbiB1dGNfb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMuem9uZSA9PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgICB0aGlzLnpvbmUgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFJGQyA1NTQ1IGNvbXBsaWFudCBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBpY2FsIGRhdGUvZGF0ZS10aW1lXG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMTApIHtcbiAgICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZVsnZGF0ZS10aW1lJ10udG9JQ0FMKHN0cmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlLmRhdGUudG9JQ0FMKHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYWwgZm9ybVxuICAgICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMueWVhciArICctJyArXG4gICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5tb250aCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuZGF5KTtcblxuICAgICAgaWYgKCF0aGlzLmlzRGF0ZSkge1xuICAgICAgICAgIHJlc3VsdCArPSAnVCcgKyBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5taW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5zZWNvbmQpO1xuXG4gICAgICAgIGlmICh0aGlzLnpvbmUgPT09IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIGEgSmF2YXNjcmlwdCBkYXRlXG4gICAgICogQHJldHVybiB7RGF0ZX1cbiAgICAgKi9cbiAgICB0b0pTRGF0ZTogZnVuY3Rpb24gdG9KU0RhdGUoKSB7XG4gICAgICBpZiAodGhpcy56b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxLCB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b1VuaXhUaW1lKCkgKiAxMDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24gaWNhbHRpbWVfbm9ybWFsaXplKCkge1xuICAgICAgdmFyIGlzRGF0ZSA9IHRoaXMuX3RpbWUuaXNEYXRlO1xuICAgICAgaWYgKHRoaXMuX3RpbWUuaXNEYXRlKSB7XG4gICAgICAgIHRoaXMuX3RpbWUuaG91ciA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWUubWludXRlID0gMDtcbiAgICAgICAgdGhpcy5fdGltZS5zZWNvbmQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIGRhdGUvdGltZSBieSB0aGUgZ2l2ZW4gb2Zmc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhRGF5cyAgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGRheXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhSG91cnMgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGhvdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYU1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYVNlY29uZHMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhVGltZSAgICAgICAgICAgVGhlIHRpbWUgdG8gYWRqdXN0LCBkZWZhdWx0cyB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRqdXN0OiBmdW5jdGlvbiBpY2FsdGltZV9hZGp1c3QoYUV4dHJhRGF5cywgYUV4dHJhSG91cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUV4dHJhTWludXRlcywgYUV4dHJhU2Vjb25kcywgYVRpbWUpIHtcblxuICAgICAgdmFyIG1pbnV0ZXNPdmVyZmxvdywgaG91cnNPdmVyZmxvdyxcbiAgICAgICAgICBkYXlzT3ZlcmZsb3cgPSAwLCB5ZWFyc092ZXJmbG93ID0gMDtcblxuICAgICAgdmFyIHNlY29uZCwgbWludXRlLCBob3VyLCBkYXk7XG4gICAgICB2YXIgZGF5c0luTW9udGg7XG5cbiAgICAgIHZhciB0aW1lID0gYVRpbWUgfHwgdGhpcy5fdGltZTtcblxuICAgICAgaWYgKCF0aW1lLmlzRGF0ZSkge1xuICAgICAgICBzZWNvbmQgPSB0aW1lLnNlY29uZCArIGFFeHRyYVNlY29uZHM7XG4gICAgICAgIHRpbWUuc2Vjb25kID0gc2Vjb25kICUgNjA7XG4gICAgICAgIG1pbnV0ZXNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNvbmQgLyA2MCk7XG4gICAgICAgIGlmICh0aW1lLnNlY29uZCA8IDApIHtcbiAgICAgICAgICB0aW1lLnNlY29uZCArPSA2MDtcbiAgICAgICAgICBtaW51dGVzT3ZlcmZsb3ctLTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pbnV0ZSA9IHRpbWUubWludXRlICsgYUV4dHJhTWludXRlcyArIG1pbnV0ZXNPdmVyZmxvdztcbiAgICAgICAgdGltZS5taW51dGUgPSBtaW51dGUgJSA2MDtcbiAgICAgICAgaG91cnNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhtaW51dGUgLyA2MCk7XG4gICAgICAgIGlmICh0aW1lLm1pbnV0ZSA8IDApIHtcbiAgICAgICAgICB0aW1lLm1pbnV0ZSArPSA2MDtcbiAgICAgICAgICBob3Vyc092ZXJmbG93LS07XG4gICAgICAgIH1cblxuICAgICAgICBob3VyID0gdGltZS5ob3VyICsgYUV4dHJhSG91cnMgKyBob3Vyc092ZXJmbG93O1xuXG4gICAgICAgIHRpbWUuaG91ciA9IGhvdXIgJSAyNDtcbiAgICAgICAgZGF5c092ZXJmbG93ID0gSUNBTC5oZWxwZXJzLnRydW5jKGhvdXIgLyAyNCk7XG4gICAgICAgIGlmICh0aW1lLmhvdXIgPCAwKSB7XG4gICAgICAgICAgdGltZS5ob3VyICs9IDI0O1xuICAgICAgICAgIGRheXNPdmVyZmxvdy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy8gQWRqdXN0IG1vbnRoIGFuZCB5ZWFyIGZpcnN0LCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB3aGF0IG1vbnRoIHRoZSBkYXlcbiAgICAgIC8vIGlzIGluIGJlZm9yZSBhZGp1c3RpbmcgaXQuXG4gICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgIHllYXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoKHRpbWUubW9udGggLSAxKSAvIDEyKTtcbiAgICAgIH0gZWxzZSBpZiAodGltZS5tb250aCA8IDEpIHtcbiAgICAgICAgeWVhcnNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyh0aW1lLm1vbnRoIC8gMTIpIC0gMTtcbiAgICAgIH1cblxuICAgICAgdGltZS55ZWFyICs9IHllYXJzT3ZlcmZsb3c7XG4gICAgICB0aW1lLm1vbnRoIC09IDEyICogeWVhcnNPdmVyZmxvdztcblxuICAgICAgLy8gTm93IHRha2UgY2FyZSBvZiB0aGUgZGF5cyAoYW5kIGFkanVzdCBtb250aCBpZiBuZWVkZWQpXG4gICAgICBkYXkgPSB0aW1lLmRheSArIGFFeHRyYURheXMgKyBkYXlzT3ZlcmZsb3c7XG5cbiAgICAgIGlmIChkYXkgPiAwKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICAgIGlmIChkYXkgPD0gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUubW9udGgrKztcbiAgICAgICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgICAgICB0aW1lLnllYXIrKztcbiAgICAgICAgICAgIHRpbWUubW9udGggPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRheSA8PSAwKSB7XG4gICAgICAgICAgaWYgKHRpbWUubW9udGggPT0gMSkge1xuICAgICAgICAgICAgdGltZS55ZWFyLS07XG4gICAgICAgICAgICB0aW1lLm1vbnRoID0gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWUubW9udGgtLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXkgKz0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRpbWUubW9udGgsIHRpbWUueWVhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGltZS5kYXkgPSBkYXk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdW5peCB0aW1lLCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiBKYW51YXJ5IDFzdCwgMTk3MC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgICAgVGhlIHNlY29uZHMgdG8gc2V0IHVwIHdpdGhcbiAgICAgKi9cbiAgICBmcm9tVW5peFRpbWU6IGZ1bmN0aW9uIGZyb21Vbml4VGltZShzZWNvbmRzKSB7XG4gICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgdmFyIGVwb2NoID0gSUNBTC5UaW1lLmVwb2NoVGltZS5jbG9uZSgpO1xuICAgICAgZXBvY2guYWRqdXN0KDAsIDAsIDAsIHNlY29uZHMpO1xuXG4gICAgICB0aGlzLnllYXIgPSBlcG9jaC55ZWFyO1xuICAgICAgdGhpcy5tb250aCA9IGVwb2NoLm1vbnRoO1xuICAgICAgdGhpcy5kYXkgPSBlcG9jaC5kYXk7XG4gICAgICB0aGlzLmhvdXIgPSBlcG9jaC5ob3VyO1xuICAgICAgdGhpcy5taW51dGUgPSBlcG9jaC5taW51dGU7XG4gICAgICB0aGlzLnNlY29uZCA9IE1hdGguZmxvb3IoZXBvY2guc2Vjb25kKTtcblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBzZWNvbmRzIHNpbmNlIEphbnVhcnkgMXN0IDE5NzAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgU2Vjb25kcyBzaW5jZSAxOTcwXG4gICAgICovXG4gICAgdG9Vbml4VGltZTogZnVuY3Rpb24gdG9Vbml4VGltZSgpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZWRVbml4VGltZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVW5peFRpbWU7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcblxuICAgICAgLy8gd2UgdXNlIHRoZSBvZmZzZXQgdHJpY2sgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGFyZSBnZXR0aW5nIHRoZSBhY3R1YWwgVVRDIHRpbWVcbiAgICAgIHZhciBtcyA9IERhdGUuVVRDKFxuICAgICAgICB0aGlzLnllYXIsXG4gICAgICAgIHRoaXMubW9udGggLSAxLFxuICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgdGhpcy5ob3VyLFxuICAgICAgICB0aGlzLm1pbnV0ZSxcbiAgICAgICAgdGhpcy5zZWNvbmQgLSBvZmZzZXRcbiAgICAgICk7XG5cbiAgICAgIC8vIHNlY29uZHNcbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbXMgLyAxMDAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aW1lIHRvIGludG8gT2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRoZW4gcmUtY3JlYXRlZFxuICAgICAqIHVzaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdG9KU09OIHdpbGwgYXV0b21hdGljYWxseSBiZSBjYWxsZWRcbiAgICAgKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG15dGltZSk7XG4gICAgICpcbiAgICAgKiB2YXIgZGVzZXJpYWxpemVkID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgKlxuICAgICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZShkZXNlcmlhbGl6ZWQpO1xuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdpc0RhdGUnXG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IGNvcHkubGVuZ3RoO1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IGNvcHlbaV07XG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnpvbmUpIHtcbiAgICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGhpcy56b25lLnR6aWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH07XG5cbiAgKGZ1bmN0aW9uIHNldHVwTm9ybWFsaXplQXR0cmlidXRlcygpIHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIHJ1biBiZWZvcmUgYW55IGluc3RhbmNlcyBhcmUgY3JlYXRlZCFcbiAgICBmdW5jdGlvbiBkZWZpbmVBdHRyKGF0dHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJQ0FMLlRpbWUucHJvdG90eXBlLCBhdHRyLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0VGltZUF0dHIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVbYXR0cl07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0VGltZUF0dHIodmFsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXNEYXRlIHdpbGwgYmUgc2V0IGFuZCBpZiB3YXMgbm90IHNldCB0byBub3JtYWxpemUgZGF0ZS5cbiAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBsb3NpbmcgZGF5cyB3aGVuIHNlY29uZHMsIG1pbnV0ZXMgYW5kIGhvdXJzIGFyZSB6ZXJvZWRcbiAgICAgICAgICAvLyB3aGF0IG5vcm1hbGl6ZSB3aWxsIGRvIHdoZW4gdGltZSBpcyBhIGRhdGUuXG4gICAgICAgICAgaWYgKGF0dHIgPT09IFwiaXNEYXRlXCIgJiYgdmFsICYmICF0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fdGltZVthdHRyXSA9IHZhbDtcblxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoXCJkZWZpbmVQcm9wZXJ0eVwiIGluIE9iamVjdCkge1xuICAgICAgZGVmaW5lQXR0cihcInllYXJcIik7XG4gICAgICBkZWZpbmVBdHRyKFwibW9udGhcIik7XG4gICAgICBkZWZpbmVBdHRyKFwiZGF5XCIpO1xuICAgICAgZGVmaW5lQXR0cihcImhvdXJcIik7XG4gICAgICBkZWZpbmVBdHRyKFwibWludXRlXCIpO1xuICAgICAgZGVmaW5lQXR0cihcInNlY29uZFwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJpc0RhdGVcIik7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXlzIGluIHRoZSBnaXZlbiBtb250aFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICBUaGUgbW9udGggdG8gY2hlY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgVGhlIHllYXIgdG8gY2hlY2tcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aFxuICAgKi9cbiAgSUNBTC5UaW1lLmRheXNJbk1vbnRoID0gZnVuY3Rpb24gaWNhbHRpbWVfZGF5c0luTW9udGgobW9udGgsIHllYXIpIHtcbiAgICB2YXIgX2RheXNJbk1vbnRoID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuICAgIHZhciBkYXlzID0gMzA7XG5cbiAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHJldHVybiBkYXlzO1xuXG4gICAgZGF5cyA9IF9kYXlzSW5Nb250aFttb250aF07XG5cbiAgICBpZiAobW9udGggPT0gMikge1xuICAgICAgZGF5cyArPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5cztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqL1xuICBJQ0FMLlRpbWUuaXNMZWFwWWVhciA9IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIGlmICh5ZWFyIDw9IDE3NTIpIHtcbiAgICAgIHJldHVybiAoKHllYXIgJSA0KSA9PSAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgoKHllYXIgJSA0ID09IDApICYmICh5ZWFyICUgMTAwICE9IDApKSB8fCAoeWVhciAlIDQwMCA9PSAwKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSUNBTC5UaW1lIGZyb20gdGhlIGRheSBvZiB5ZWFyIGFuZCB5ZWFyLiBUaGUgZGF0ZSBpcyByZXR1cm5lZFxuICAgKiBpbiBmbG9hdGluZyB0aW1lem9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZlllYXIgICAgIFRoZSBkYXkgb2YgeWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgVGhlIHllYXIgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBpblxuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaW5zdGFuY2Ugd2l0aCB0aGUgY2FsY3VsYXRlZCBkYXRlXG4gICAqL1xuICBJQ0FMLlRpbWUuZnJvbURheU9mWWVhciA9IGZ1bmN0aW9uIGljYWx0aW1lX2Zyb21EYXlPZlllYXIoYURheU9mWWVhciwgYVllYXIpIHtcbiAgICB2YXIgeWVhciA9IGFZZWFyO1xuICAgIHZhciBkb3kgPSBhRGF5T2ZZZWFyO1xuICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IGZhbHNlO1xuICAgIHZhciBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuXG4gICAgaWYgKGRveSA8IDEpIHtcbiAgICAgIHllYXItLTtcbiAgICAgIGlzX2xlYXAgPSAoSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcikgPyAxIDogMCk7XG4gICAgICBkb3kgKz0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVsxMl07XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKTtcbiAgICB9IGVsc2UgaWYgKGRveSA+IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdKSB7XG4gICAgICBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95IC09IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgeWVhcisrO1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfVxuXG4gICAgdHQueWVhciA9IHllYXI7XG4gICAgdHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIG1vbnRoID0gMTE7IG1vbnRoID49IDA7IG1vbnRoLS0pIHtcbiAgICAgIGlmIChkb3kgPiBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdW21vbnRoXSkge1xuICAgICAgICB0dC5tb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgdHQuZGF5ID0gZG95IC0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHR0LmF1dG9fbm9ybWFsaXplID0gdHJ1ZTtcbiAgICByZXR1cm4gdHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkICAgICAgICAgICAgICAgIFVzZSB7QGxpbmsgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nfSBpbnN0ZWFkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21TdHJpbmd2MiA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLlRpbWUoe1xuICAgICAgeWVhcjogcGFyc2VJbnQoc3RyLnN1YnN0cigwLCA0KSwgMTApLFxuICAgICAgbW9udGg6IHBhcnNlSW50KHN0ci5zdWJzdHIoNSwgMiksIDEwKSxcbiAgICAgIGRheTogcGFyc2VJbnQoc3RyLnN1YnN0cig4LCAyKSwgMTApLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nID0gZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgLy8gRGF0ZXMgc2hvdWxkIGhhdmUgbm8gdGltZXpvbmUuXG4gICAgLy8gR29vZ2xlIGxpa2VzIHRvIHNvbWV0aW1lcyBzcGVjaWZ5IFogb24gZGF0ZXNcbiAgICAvLyB3ZSBzcGVjaWZpY2FsbHkgaWdub3JlIHRoYXQgdG8gYXZvaWQgaXNzdWVzLlxuXG4gICAgLy8gWVlZWS1NTS1ERFxuICAgIC8vIDIwMTItMTAtMTBcbiAgICByZXR1cm4gbmV3IElDQUwuVGltZSh7XG4gICAgICB5ZWFyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigwLCA0KSksXG4gICAgICBtb250aDogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoNSwgMikpLFxuICAgICAgZGF5OiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig4LCAyKSksXG4gICAgICBpc0RhdGU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUtdGltZSBzdHJpbmcsIGUuZ1xuICAgKiAyMDE1LTAxLTAyVDAzOjA0OjA1LiBJZiBhIHByb3BlcnR5IGlzIHNwZWNpZmllZCwgdGhlIHRpbWV6b25lIGlzIHNldCB1cFxuICAgKiBmcm9tIHRoZSBwcm9wZXJ0eSdzIFRaSUQgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHk9fSBwcm9wICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcgPSBmdW5jdGlvbihhVmFsdWUsIHByb3ApIHtcbiAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDE5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGRhdGUtdGltZSB2YWx1ZTogXCInICsgYVZhbHVlICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgem9uZTtcblxuICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgem9uZSA9ICdaJztcbiAgICB9IGVsc2UgaWYgKHByb3ApIHtcbiAgICAgIHpvbmUgPSBwcm9wLmdldFBhcmFtZXRlcigndHppZCcpO1xuICAgIH1cblxuICAgIC8vIDIwMTItMTAtMTBUMTA6MTA6MTAoWik/XG4gICAgdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKHtcbiAgICAgIHllYXI6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDAsIDQpKSxcbiAgICAgIG1vbnRoOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig1LCAyKSksXG4gICAgICBkYXk6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDgsIDIpKSxcbiAgICAgIGhvdXI6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDExLCAyKSksXG4gICAgICBtaW51dGU6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDE0LCAyKSksXG4gICAgICBzZWNvbmQ6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDE3LCAyKSksXG4gICAgICB0aW1lem9uZTogem9uZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIG9yIGRhdGUtdGltZSBzdHJpbmcsXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eT19IHByb3AgICBUaGUgcHJvcGVydHkgdGhlIGRhdGUgYmVsb25ncyB0b1xuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nKGFWYWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBKYXZhc2NyaXB0IERhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICogQHBhcmFtIHtCb29sZWFufSB1c2VVVEMgIElmIHRydWUsIHRoZSBVVEMgdmFsdWVzIG9mIHRoZSBkYXRlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21KU0RhdGUgPSBmdW5jdGlvbiBmcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21KU0RhdGUoYURhdGUsIHVzZVVUQyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheSAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmQgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmU9fSBhWm9uZSAgICBUaW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgdmFyIHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgcmV0dXJuIHQuZnJvbURhdGEoYURhdGEsIGFab25lKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgY3VycmVudCBtb21lbnQuXG4gICAqIFRoZSBpbnN0YW5jZSBpcyDigJxmbG9hdGluZ+KAnSAtIGhhcyBubyB0aW1lem9uZSByZWxhdGlvbi5cbiAgICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIGNvbnNpZGVyaW5nIHRoZSB0aW1lIHpvbmUsIGNhbGxcbiAgICogSUNBTC5UaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgdHJ1ZSlcbiAgICogQHJldHVybiB7SUNBTC5UaW1lfVxuICAgKi9cbiAgSUNBTC5UaW1lLm5vdyA9IGZ1bmN0aW9uIGljYWx0aW1lX25vdygpIHtcbiAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRlIG9uIHdoaWNoIElTTyB3ZWVrIG51bWJlciAxIHN0YXJ0cy5cbiAgICpcbiAgICogQHNlZSBJQ0FMLlRpbWUjd2Vla051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgICAgICAgICBUaGUgeWVhciB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgdXNlZCBmb3IgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBkYXRlIG9uIHdoaWNoIHdlZWsgbnVtYmVyIDEgc3RhcnRzXG4gICAqL1xuICBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyA9IGZ1bmN0aW9uIHdlZWtPbmVTdGFydHMoYVllYXIsIGFXZWVrU3RhcnQpIHtcbiAgICB2YXIgdCA9IElDQUwuVGltZS5mcm9tRGF0YSh7XG4gICAgICB5ZWFyOiBhWWVhcixcbiAgICAgIG1vbnRoOiAxLFxuICAgICAgZGF5OiAxLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgZG93ID0gdC5kYXlPZldlZWsoKTtcbiAgICB2YXIgd2tzdCA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVDtcbiAgICBpZiAoZG93ID4gSUNBTC5UaW1lLlRIVVJTREFZKSB7XG4gICAgICB0LmRheSArPSA3O1xuICAgIH1cbiAgICBpZiAod2tzdCA+IElDQUwuVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgLT0gNztcbiAgICB9XG5cbiAgICB0LmRheSAtPSBkb3cgLSB3a3N0O1xuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGdpdmVuIHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gRyBmb3JcbiAgICogY29tbW9uIHllYXJzLCBhbmQgQUcgdG8gR0YgZm9yIGxlYXAgeWVhcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgZG9taW5pY2FsIGxldHRlci5cbiAgICovXG4gIElDQUwuVGltZS5nZXREb21pbmljYWxMZXR0ZXIgPSBmdW5jdGlvbih5cikge1xuICAgIHZhciBMVFJTID0gXCJHRkVEQ0JBXCI7XG4gICAgdmFyIGRvbSA9ICh5ciArICh5ciAvIDQgfCAwKSArICh5ciAvIDQwMCB8IDApIC0gKHlyIC8gMTAwIHwgMCkgLSAxKSAlIDc7XG4gICAgdmFyIGlzTGVhcCA9IElDQUwuVGltZS5pc0xlYXBZZWFyKHlyKTtcbiAgICBpZiAoaXNMZWFwKSB7XG4gICAgICByZXR1cm4gTFRSU1soZG9tICsgNikgJSA3XSArIExUUlNbZG9tXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExUUlNbZG9tXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEphbnVhcnkgMXN0LCAxOTcwIGFzIGFuIElDQUwuVGltZS5cbiAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmVwb2NoVGltZSA9IElDQUwuVGltZS5mcm9tRGF0YSh7XG4gICAgeWVhcjogMTk3MCxcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIGlzRGF0ZTogZmFsc2UsXG4gICAgdGltZXpvbmU6IFwiWlwiXG4gIH0pO1xuXG4gIElDQUwuVGltZS5fY21wX2F0dHIgPSBmdW5jdGlvbiBfY21wX2F0dHIoYSwgYiwgYXR0cikge1xuICAgIGlmIChhW2F0dHJdID4gYlthdHRyXSkgcmV0dXJuIDE7XG4gICAgaWYgKGFbYXR0cl0gPCBiW2F0dHJdKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkYXlzIHRoYXQgaGF2ZSBwYXNzZWQgaW4gdGhlIHllYXIgYWZ0ZXIgYSBnaXZlbiBtb250aC4gVGhlIGFycmF5IGhhc1xuICAgKiB0d28gbWVtYmVycywgb25lIGJlaW5nIGFuIGFycmF5IG9mIHBhc3NlZCBkYXlzIGZvciBub24tbGVhcCB5ZWFycywgdGhlXG4gICAqIG90aGVyIGFuYWxvZyBmb3IgbGVhcCB5ZWFycy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGlzTGVhcFllYXIgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICogdmFyIHBhc3NlZERheXMgPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzTGVhcFllYXJdW21vbnRoXTtcbiAgICogQHR5cGUge0FycmF5LjxBcnJheS48TnVtYmVyPj59XG4gICAqL1xuICBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoID0gW1xuICAgIFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XSxcbiAgICBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzUsIDM2Nl1cbiAgXTtcblxuICAvKipcbiAgICogVGhlIHdlZWtkYXksIDEgPSBTVU5EQVksIDcgPSBTQVRVUkRBWS4gQWNjZXNzIHZpYVxuICAgKiBJQ0FMLlRpbWUuTU9OREFZLCBJQ0FMLlRpbWUuVFVFU0RBWSwgLi4uXG4gICAqXG4gICAqIEB0eXBlZGVmIHtOdW1iZXJ9IHdlZWtEYXlcbiAgICogQG1lbWJlcm9mIElDQUwuVGltZVxuICAgKi9cblxuICBJQ0FMLlRpbWUuU1VOREFZID0gMTtcbiAgSUNBTC5UaW1lLk1PTkRBWSA9IDI7XG4gIElDQUwuVGltZS5UVUVTREFZID0gMztcbiAgSUNBTC5UaW1lLldFRE5FU0RBWSA9IDQ7XG4gIElDQUwuVGltZS5USFVSU0RBWSA9IDU7XG4gIElDQUwuVGltZS5GUklEQVkgPSA2O1xuICBJQ0FMLlRpbWUuU0FUVVJEQVkgPSA3O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB3ZWVrZGF5IGZvciB0aGUgV0tTVCBwYXJ0LlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgKi9cbiAgSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVCA9IElDQUwuVGltZS5NT05EQVk7XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyBhIHZDYXJkIHRpbWUsIHdoaWNoIGhhcyBzbGlnaHQgZGlmZmVyZW5jZXMgdG8gdGhlIElDQUwuVGltZS5cbiAgICogUHJvcGVydGllcyBjYW4gYmUgbnVsbCBpZiBub3Qgc3BlY2lmaWVkLCBmb3IgZXhhbXBsZSBmb3IgZGF0ZXMgd2l0aFxuICAgKiByZWR1Y2VkIGFjY3VyYWN5IG9yIHRydW5jYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCBjdXJyZW50bHkgbm90IGFsbCBtZXRob2RzIGFyZSBjb3JyZWN0bHkgcmUtaW1wbGVtZW50ZWQgZm9yXG4gICAqIFZDYXJkVGltZS4gRm9yIGV4YW1wbGUsIGNvbXBhcmlzb24gd2lsbCBoYXZlIHVuZGVmaW5lZCByZXN1bHRzIHdoZW4gc29tZVxuICAgKiBtZW1iZXJzIGFyZSBudWxsLlxuICAgKlxuICAgKiBBbHNvLCBub3JtYWxpemF0aW9uIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIHRoaXMgY2xhc3MhXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLlZDYXJkVGltZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMge0lDQUwuVGltZX1cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF0YSBmb3IgdGhlIHRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgICAgICAgICAgICAgICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICAgICAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmRheSAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgICAgICAgICAgICAgICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICAgICAgICAgICAgICAgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5zZWNvbmQgICAgICAgICAgICAgICAgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZXxJQ0FMLlV0Y09mZnNldH0gem9uZSAgICAgVGhlIHRpbWV6b25lIHRvIHVzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWNhbHR5cGUgICAgICAgICAgICAgICAgICAgICAgIFRoZSB0eXBlIGZvciB0aGlzIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIElDQUwuVkNhcmRUaW1lID0gZnVuY3Rpb24oZGF0YSwgem9uZSwgaWNhbHR5cGUpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRpbWUueWVhciA9IG51bGw7XG4gICAgdGltZS5tb250aCA9IG51bGw7XG4gICAgdGltZS5kYXkgPSBudWxsO1xuICAgIHRpbWUuaG91ciA9IG51bGw7XG4gICAgdGltZS5taW51dGUgPSBudWxsO1xuICAgIHRpbWUuc2Vjb25kID0gbnVsbDtcblxuICAgIHRoaXMuaWNhbHR5cGUgPSBpY2FsdHlwZSB8fCBcImRhdGUtYW5kLW9yLXRpbWVcIjtcblxuICAgIHRoaXMuZnJvbURhdGEoZGF0YSwgem9uZSk7XG4gIH07XG4gIElDQUwuaGVscGVycy5pbmhlcml0cyhJQ0FMLlRpbWUsIElDQUwuVkNhcmRUaW1lLCAvKiogQGxlbmRzIElDQUwuVkNhcmRUaW1lICovIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJ2Y2FyZHRpbWVcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJ2Y2FyZHRpbWVcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJkYXRlLWFuZC1vci10aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJkYXRlLWFuZC1vci10aW1lXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXpvbmUuIFRoaXMgY2FuIGVpdGhlciBiZSBmbG9hdGluZywgVVRDLCBvciBhbiBpbnN0YW5jZSBvZlxuICAgICAqIElDQUwuVXRjT2Zmc2V0LlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV6b25lfElDQUwuVXRjT0Zmc2V0fVxuICAgICAqL1xuICAgIHpvbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHZjYXJkIGRhdGUvdGltZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlZDYXJkVGltZX0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlZDYXJkVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUsIHRoaXMuaWNhbHR5cGUpO1xuICAgIH0sXG5cbiAgICBfbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgSUNBTC5VdGNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS50b1NlY29uZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUucHJvdG90eXBlLnV0Y09mZnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFJGQyA2MzUwIGNvbXBsaWFudCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICB2Y2FyZCBkYXRlL3RpbWUgc3RyaW5nXG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi52Y2FyZC52YWx1ZVt0aGlzLmljYWx0eXBlXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUvdGltZSwgaW4gakNhcmQgZm9ybVxuICAgICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHAyID0gSUNBTC5oZWxwZXJzLnBhZDI7XG4gICAgICB2YXIgeSA9IHRoaXMueWVhciwgbSA9IHRoaXMubW9udGgsIGQgPSB0aGlzLmRheTtcbiAgICAgIHZhciBoID0gdGhpcy5ob3VyLCBtbSA9IHRoaXMubWludXRlLCBzID0gdGhpcy5zZWNvbmQ7XG5cbiAgICAgIHZhciBoYXNZZWFyID0geSAhPT0gbnVsbCwgaGFzTW9udGggPSBtICE9PSBudWxsLCBoYXNEYXkgPSBkICE9PSBudWxsO1xuICAgICAgdmFyIGhhc0hvdXIgPSBoICE9PSBudWxsLCBoYXNNaW51dGUgPSBtbSAhPT0gbnVsbCwgaGFzU2Vjb25kID0gcyAhPT0gbnVsbDtcblxuICAgICAgdmFyIGRhdGVwYXJ0ID0gKGhhc1llYXIgPyBwMih5KSArIChoYXNNb250aCB8fCBoYXNEYXkgPyAnLScgOiAnJykgOiAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0tJyA6ICcnKSkgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc01vbnRoID8gcDIobSkgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc0RheSA/ICctJyArIHAyKGQpIDogJycpO1xuICAgICAgdmFyIHRpbWVwYXJ0ID0gKGhhc0hvdXIgPyBwMihoKSA6ICctJykgKyAoaGFzSG91ciAmJiBoYXNNaW51dGUgPyAnOicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc01pbnV0ZSA/IHAyKG1tKSA6ICcnKSArICghaGFzSG91ciAmJiAhaGFzTWludXRlID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgJiYgaGFzU2Vjb25kID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNTZWNvbmQgPyBwMihzKSA6ICcnKTtcblxuICAgICAgdmFyIHpvbmU7XG4gICAgICBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIElDQUwuVXRjT2Zmc2V0KSB7XG4gICAgICAgIHpvbmUgPSB0aGlzLnpvbmUudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgICAgem9uZSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBJQ0FMLlRpbWV6b25lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBJQ0FMLlV0Y09mZnNldC5mcm9tU2Vjb25kcyh0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpKTtcbiAgICAgICAgem9uZSA9IG9mZnNldC50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9uZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuaWNhbHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICByZXR1cm4gdGltZXBhcnQgKyB6b25lO1xuICAgICAgICBjYXNlIFwiZGF0ZS1hbmQtb3ItdGltZVwiOlxuICAgICAgICBjYXNlIFwiZGF0ZS10aW1lXCI6XG4gICAgICAgICAgcmV0dXJuIGRhdGVwYXJ0ICsgKHRpbWVwYXJ0ID09ICctLScgPyAnJyA6ICdUJyArIHRpbWVwYXJ0ICsgem9uZSk7XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIGRhdGVwYXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlZDYXJkVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBhbmQvb3IgdGltZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFJY2FsVHlwZSAgVGhlIHR5cGUgZm9yIHRoaXMgaW5zdGFuY2UsIGUuZy4gZGF0ZS1hbmQtb3ItdGltZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlZDYXJkVGltZX0gICBUaGUgZGF0ZS90aW1lIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyA9IGZ1bmN0aW9uKGFWYWx1ZSwgYUljYWxUeXBlKSB7XG4gICAgZnVuY3Rpb24gcGFydCh2LCBzLCBlKSB7XG4gICAgICByZXR1cm4gdiA/IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2LnN1YnN0cihzLCBlKSkgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICB2YXIgZHQgPSBwYXJ0c1swXSwgdG16ID0gcGFydHNbMV07XG4gICAgdmFyIHNwbGl0em9uZSA9IHRteiA/IElDQUwuZGVzaWduLnZjYXJkLnZhbHVlLnRpbWUuX3NwbGl0Wm9uZSh0bXopIDogW107XG4gICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHRtID0gc3BsaXR6b25lWzFdO1xuXG4gICAgdmFyIHN0b2kgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQ7XG4gICAgdmFyIGR0bGVuID0gZHQgPyBkdC5sZW5ndGggOiAwO1xuICAgIHZhciB0bWxlbiA9IHRtID8gdG0ubGVuZ3RoIDogMDtcblxuICAgIHZhciBoYXNEYXNoRGF0ZSA9IGR0ICYmIGR0WzBdID09ICctJyAmJiBkdFsxXSA9PSAnLSc7XG4gICAgdmFyIGhhc0Rhc2hUaW1lID0gdG0gJiYgdG1bMF0gPT0gJy0nO1xuXG4gICAgdmFyIG8gPSB7XG4gICAgICB5ZWFyOiBoYXNEYXNoRGF0ZSA/IG51bGwgOiBwYXJ0KGR0LCAwLCA0KSxcbiAgICAgIG1vbnRoOiBoYXNEYXNoRGF0ZSAmJiAoZHRsZW4gPT0gNCB8fCBkdGxlbiA9PSA3KSA/IHBhcnQoZHQsIDIsIDIpIDogZHRsZW4gPT0gNyA/IHBhcnQoZHQsIDUsIDIpIDogZHRsZW4gPT0gMTAgPyBwYXJ0KGR0LCA1LCAyKSA6IG51bGwsXG4gICAgICBkYXk6IGR0bGVuID09IDUgPyBwYXJ0KGR0LCAzLCAyKSA6IGR0bGVuID09IDcgJiYgaGFzRGFzaERhdGUgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgOCwgMikgOiBudWxsLFxuXG4gICAgICBob3VyOiBoYXNEYXNoVGltZSA/IG51bGwgOiBwYXJ0KHRtLCAwLCAyKSxcbiAgICAgIG1pbnV0ZTogaGFzRGFzaFRpbWUgJiYgdG1sZW4gPT0gMyA/IHBhcnQodG0sIDEsIDIpIDogdG1sZW4gPiA0ID8gaGFzRGFzaFRpbWUgPyBwYXJ0KHRtLCAxLCAyKSA6IHBhcnQodG0sIDMsIDIpIDogbnVsbCxcbiAgICAgIHNlY29uZDogdG1sZW4gPT0gNCA/IHBhcnQodG0sIDIsIDIpIDogdG1sZW4gPT0gNiA/IHBhcnQodG0sIDQsIDIpIDogdG1sZW4gPT0gOCA/IHBhcnQodG0sIDYsIDIpIDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoem9uZSA9PSAnWicpIHtcbiAgICAgIHpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgIH0gZWxzZSBpZiAoem9uZSAmJiB6b25lWzNdID09ICc6Jykge1xuICAgICAgem9uZSA9IElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoem9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHpvbmUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSUNBTC5WQ2FyZFRpbWUobywgem9uZSwgYUljYWxUeXBlKTtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRE9XX01BUCA9IHtcbiAgICBTVTogSUNBTC5UaW1lLlNVTkRBWSxcbiAgICBNTzogSUNBTC5UaW1lLk1PTkRBWSxcbiAgICBUVTogSUNBTC5UaW1lLlRVRVNEQVksXG4gICAgV0U6IElDQUwuVGltZS5XRURORVNEQVksXG4gICAgVEg6IElDQUwuVGltZS5USFVSU0RBWSxcbiAgICBGUjogSUNBTC5UaW1lLkZSSURBWSxcbiAgICBTQTogSUNBTC5UaW1lLlNBVFVSREFZXG4gIH07XG5cbiAgdmFyIFJFVkVSU0VfRE9XX01BUCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gRE9XX01BUCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKERPV19NQVAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgUkVWRVJTRV9ET1dfTUFQW0RPV19NQVBba2V5XV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENPUFlfUEFSVFMgPSBbXCJCWVNFQ09ORFwiLCBcIkJZTUlOVVRFXCIsIFwiQllIT1VSXCIsIFwiQllEQVlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIsIFwiQllZRUFSREFZXCIsIFwiQllXRUVLTk9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIsIFwiQllTRVRQT1NcIl07XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInJlY3VyXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlJlY3VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtJQ0FMLlJlY3VyLmZyZXF1ZW5jeVZhbHVlcz19IGRhdGEuZnJlcSAgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBkYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltaW51dGUgICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aGRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGggICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBJQ0FMLlJlY3VyID0gZnVuY3Rpb24gaWNhbHJlY3VyKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJ0cyA9IHt9O1xuXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgSUNBTC5SZWN1ci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGhvbGRpbmcgdGhlIEJZLXBhcnRzIG9mIHRoZSByZWN1cnJlbmNlIHJ1bGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVydmFsIHZhbHVlIGZvciB0aGUgcmVjdXJyZW5jZSBydWxlLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgaW50ZXJ2YWw6IDEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2VlayBzdGFydCBkYXlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWUud2Vla0RheX1cbiAgICAgKiBAZGVmYXVsdCBJQ0FMLlRpbWUuTU9OREFZXG4gICAgICovXG4gICAgd2tzdDogSUNBTC5UaW1lLk1PTkRBWSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBAdHlwZSB7P0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICB1bnRpbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqL1xuICAgIGNvdW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZXF1ZW5jeSB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXN9XG4gICAgICovXG4gICAgZnJlcTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJpY2FscmVjdXJcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJpY2FscmVjdXJcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJyZWN1clwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwicmVjdXJcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpdGVyYXRvciBmb3IgdGhpcyByZWN1cnJlbmNlIHJ1bGUuIFRoZSBwYXNzZWQgc3RhcnQgZGF0ZVxuICAgICAqIG11c3QgYmUgdGhlIHN0YXJ0IGRhdGUgb2YgdGhlIGV2ZW50LCBub3QgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0b1xuICAgICAqIHNlYXJjaCBpbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJlY3VyID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3JydWxlJyk7XG4gICAgICogdmFyIGR0c3RhcnQgPSBjb21wLmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpO1xuICAgICAqIHZhciBpdGVyID0gcmVjdXIuaXRlcmF0b3IoZHRzdGFydCk7XG4gICAgICogZm9yICh2YXIgbmV4dCA9IGl0ZXIubmV4dCgpOyBuZXh0OyBuZXh0ID0gaXRlci5uZXh0KCkpIHtcbiAgICAgKiAgIGlmIChuZXh0LmNvbXBhcmUocmFuZ2VTdGFydCkgPCAwKSB7XG4gICAgICogICAgIGNvbnRpbnVlO1xuICAgICAqICAgfVxuICAgICAqICAgY29uc29sZS5sb2cobmV4dC50b1N0cmluZygpKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVN0YXJ0ICAgICAgICBUaGUgaXRlbSdzIHN0YXJ0IGRhdGVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VySXRlcmF0b3J9ICAgICBUaGUgcmVjdXJyZW5jZSBpdGVyYXRvclxuICAgICAqL1xuICAgIGl0ZXJhdG9yOiBmdW5jdGlvbihhU3RhcnQpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5SZWN1ckl0ZXJhdG9yKHtcbiAgICAgICAgcnVsZTogdGhpcyxcbiAgICAgICAgZHRzdGFydDogYVN0YXJ0XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSByZWN1cnJlbmNlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuUmVjdXJ9ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXIodGhpcy50b0pTT04oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGZpbml0ZSwgaS5lLiBoYXMgYSBjb3VudCBvciB1bnRpbCBwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGZpbml0ZVxuICAgICAqL1xuICAgIGlzRmluaXRlOiBmdW5jdGlvbiBpc2Zpbml0ZSgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLmNvdW50IHx8IHRoaXMudW50aWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBoYXMgYSBjb3VudCBwYXJ0LCBhbmQgbm90IGxpbWl0ZWQgYnkgYW4gdW50aWxcbiAgICAgKiBwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGJ5IGNvdW50XG4gICAgICovXG4gICAgaXNCeUNvdW50OiBmdW5jdGlvbiBpc2J5Y291bnQoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5jb3VudCAmJiAhdGhpcy51bnRpbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb21wb25lbnQgKHBhcnQpIHRvIHRoZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgaXMgbm90IGEgY29tcG9uZW50XG4gICAgICogaW4gdGhlIHNlbnNlIG9mIHtAbGluayBJQ0FMLkNvbXBvbmVudH0sIGJ1dCBhIHBhcnQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBydWxlLCBpLmUuIEJZTU9OVEguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYVZhbHVlICAgICBUaGUgY29tcG9uZW50IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50OiBmdW5jdGlvbiBhZGRQYXJ0KGFUeXBlLCBhVmFsdWUpIHtcbiAgICAgIHZhciB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVjbmFtZSBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICAgIHRoaXMucGFydHNbdWNuYW1lXS5wdXNoKGFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnRzW3VjbmFtZV0gPSBbYVZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcG9uZW50IHZhbHVlIGZvciB0aGUgZ2l2ZW4gYnktcGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhVHlwZSAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhVmFsdWVzICAgICAgIFRoZSBjb21wb25lbnQgdmFsdWVzXG4gICAgICovXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQoYVR5cGUsIGFWYWx1ZXMpIHtcbiAgICAgIHRoaXMucGFydHNbYVR5cGUudG9VcHBlckNhc2UoKV0gPSBhVmFsdWVzLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgKGEgY29weSkgb2YgdGhlIHJlcXVlc3RlZCBjb21wb25lbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENvbXBvbmVudChhVHlwZSkge1xuICAgICAgdmFyIHVjbmFtZSA9IGFUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gKHVjbmFtZSBpbiB0aGlzLnBhcnRzID8gdGhpcy5wYXJ0c1t1Y25hbWVdLnNsaWNlKCkgOiBbXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyIHRoZSBnaXZlbiByZWN1cnJlbmNlIGlkLiBTZWUgdGhlXG4gICAgICogZ3VpZGUgb24ge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIE5PVEU6IEN1cnJlbnRseSwgdGhpcyBtZXRob2QgaXRlcmF0ZXMgYWxsIG9jY3VycmVuY2VzIGZyb20gdGhlIHN0YXJ0XG4gICAgICogZGF0ZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gYSBsb29wIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcbiAgICAgKiB3b3VsZCBsaWtlIHRvIGdldCBtb3JlIHRoYW4gb25lIG9jY3VycmVuY2UsIHlvdSBjYW4gaXRlcmF0ZSB0aGVcbiAgICAgKiBvY2N1cnJlbmNlcyBtYW51YWxseSwgc2VlIHRoZSBleGFtcGxlIG9uIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVN0YXJ0VGltZSAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBldmVudCBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVJlY3VycmVuY2VJZCAgICAgVGhlIGRhdGUgb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZVxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICBUaGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyXG4gICAgICovXG4gICAgZ2V0TmV4dE9jY3VycmVuY2U6IGZ1bmN0aW9uIGdldE5leHRPY2N1cnJlbmNlKGFTdGFydFRpbWUsIGFSZWN1cnJlbmNlSWQpIHtcbiAgICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcihhU3RhcnRUaW1lKTtcbiAgICAgIHZhciBuZXh0LCBjZHQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCA9IGl0ZXIubmV4dCgpO1xuICAgICAgfSB3aGlsZSAobmV4dCAmJiBuZXh0LmNvbXBhcmUoYVJlY3VycmVuY2VJZCkgPD0gMCk7XG5cbiAgICAgIGlmIChuZXh0ICYmIGFSZWN1cnJlbmNlSWQuem9uZSkge1xuICAgICAgICBuZXh0LnpvbmUgPSBhUmVjdXJyZW5jZUlkLnpvbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcmVjdXJyZW5jZVxuICAgICAqIEBwYXJhbSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gZGF0YS53a3N0ICAgICAgICAgICAgICBUaGUgd2VlayBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5c2Vjb25kICAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPj19IGRhdGEuYnlkYXkgICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5d2Vla25vICAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIHZhciB1Y2tleSA9IGtleS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh1Y2tleSBpbiBwYXJ0RGVzaWduKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c1t1Y2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gW2RhdGFba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCAmJiB0eXBlb2YgdGhpcy5pbnRlcnZhbCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnbi5JTlRFUlZBTCh0aGlzLmludGVydmFsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud2tzdCAmJiB0eXBlb2YgdGhpcy53a3N0ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy53a3N0ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVudGlsICYmICEodGhpcy51bnRpbCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhpcy51bnRpbCA9IElDQUwuVGltZS5mcm9tU3RyaW5nKHRoaXMudW50aWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgakNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3VycmVuY2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmVzLmZyZXEgPSB0aGlzLmZyZXE7XG5cbiAgICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICAgIHJlcy5jb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmludGVydmFsID4gMSkge1xuICAgICAgICByZXMuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMucGFydHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5wYXJ0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrcGFydHMgPSB0aGlzLnBhcnRzW2tdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrcGFydHMpICYmIGtwYXJ0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0ga3BhcnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMucGFydHNba10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICAgIHJlcy51bnRpbCA9IHRoaXMudW50aWwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd2tzdCcgaW4gdGhpcyAmJiB0aGlzLndrc3QgIT09IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgICAgcmVzLndrc3QgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHJ1bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiBpY2FscmVjdXJfdG9TdHJpbmcoKSB7XG4gICAgICAvLyBUT0RPIHJldGFpbiBvcmRlclxuICAgICAgdmFyIHN0ciA9IFwiRlJFUT1cIiArIHRoaXMuZnJlcTtcbiAgICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICAgIHN0ciArPSBcIjtDT1VOVD1cIiArIHRoaXMuY291bnQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgc3RyICs9IFwiO0lOVEVSVkFMPVwiICsgdGhpcy5pbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodGhpcy5wYXJ0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHN0ciArPSBcIjtcIiArIGsgKyBcIj1cIiArIHRoaXMucGFydHNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICAgIHN0ciArPSAnO1VOVElMPScgKyB0aGlzLnVudGlsLnRvSUNBTFN0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCd3a3N0JyBpbiB0aGlzICYmIHRoaXMud2tzdCAhPT0gSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVCkge1xuICAgICAgICBzdHIgKz0gJztXS1NUPScgKyBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlTnVtZXJpY1ZhbHVlKHR5cGUsIG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZVswXSA9PT0gJysnKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZS5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHJlc3VsdCk7XG5cbiAgICBpZiAobWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBtaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdHlwZSArICc6IGludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgbXVzdCBiZSA+ICcgKyBtaW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPCAnICsgbWluXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF5IChTVSwgTU8sIGV0Yy4uKVxuICAgKiBpbnRvIGEgbnVtZXJpYyB2YWx1ZSBvZiB0aGF0IGRheS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgVGhlIGlDYWxlbmRhciBkYXkgbmFtZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqL1xuICBJQ0FMLlJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkgPSBmdW5jdGlvbiB0b051bWVyaWNEYXkoc3RyaW5nLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbFxuICAgIC8vICAgICB3aXRoIHBvc3NpYmx5IGludmFsaWQgc3RyaW5nIHZhbHVlcy5cbiAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgcmV0dXJuICgoRE9XX01BUFtzdHJpbmddIC0gZmlyc3REb3cgKyA3KSAlIDcpICsgMTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIG51bWVyaWMgZGF5IHZhbHVlIGludG8gaXRzIGljYWwgcmVwcmVzZW50YXRpb24gKFNVLCBNTywgZXRjLi4pXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIElDQUwgZGF5IHZhbHVlLCBlLmcgU1UsTU8sLi4uXG4gICAqL1xuICBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkgPSBmdW5jdGlvbiB0b0ljYWxEYXkobnVtLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbCB3aXRoIHBvc3NpYmx5IGludmFsaWQgbnVtYmVyIHZhbHVlcy5cbiAgICAvLyAgICAgQWxzbywgdGhpcyBhbGxvd3MgY29uc2lzdGVudCBtYXBwaW5nIGJldHdlZW4gZGF5IG51bWJlcnMgYW5kIGRheVxuICAgIC8vICAgICBuYW1lcyBmb3IgZXh0ZXJuYWwgdXNlcnMuXG4gICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgIHZhciBkb3cgPSAobnVtICsgZmlyc3REb3cgLSBJQ0FMLlRpbWUuU1VOREFZKTtcbiAgICBpZiAoZG93ID4gNykge1xuICAgICAgZG93IC09IDc7XG4gICAgfVxuICAgIHJldHVybiBSRVZFUlNFX0RPV19NQVBbZG93XTtcbiAgfTtcblxuICB2YXIgVkFMSURfREFZX05BTUVTID0gL14oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG4gIHZhciBWQUxJRF9CWURBWV9QQVJUID0gL14oWystXSk/KDVbMC0zXXxbMS00XVswLTldfFsxLTldKT8oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGZyZXF1ZW5jeSB2YWx1ZXMgZm9yIHRoZSBGUkVRIHBhcnRcbiAgICogKFlFQVJMWSwgTU9OVEhMWSwgV0VFS0xZLCBEQUlMWSwgSE9VUkxZLCBNSU5VVEVMWSwgU0VDT05ETFkpXG4gICAqXG4gICAqIEB0eXBlZGVmIHtTdHJpbmd9IGZyZXF1ZW5jeVZhbHVlc1xuICAgKiBAbWVtYmVyb2YgSUNBTC5SZWN1clxuICAgKi9cblxuICB2YXIgQUxMT1dFRF9GUkVRID0gWydTRUNPTkRMWScsICdNSU5VVEVMWScsICdIT1VSTFknLFxuICAgICAgICAgICAgICAgICAgICAgICdEQUlMWScsICdXRUVLTFknLCAnTU9OVEhMWScsICdZRUFSTFknXTtcblxuICB2YXIgb3B0aW9uRGVzaWduID0ge1xuICAgIEZSRVE6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICAvLyB5ZXMgdGhpcyBpcyBhY3R1YWxseSBlcXVhbCBvciBmYXN0ZXIgdGhlbiByZWdleC5cbiAgICAgIC8vIHVwc2lkZSBoZXJlIGlzIHdlIGNhbiBlbnVtZXJhdGUgdGhlIHZhbGlkIHZhbHVlcy5cbiAgICAgIGlmIChBTExPV0VEX0ZSRVEuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIGRpY3QuZnJlcSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGZyZXF1ZW5jeSBcIicgKyB2YWx1ZSArICdcIiBleHBlY3RlZDogXCInICtcbiAgICAgICAgICBBTExPV0VEX0ZSRVEuam9pbignLCAnKSArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgQ09VTlQ6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICBkaWN0LmNvdW50ID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgSU5URVJWQUw6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICBkaWN0LmludGVydmFsID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICAgIGlmIChkaWN0LmludGVydmFsIDwgMSkge1xuICAgICAgICAvLyAwIG9yIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQsIHNvbWUgZW5naW5lcyBzZWVtIHRvIGdlbmVyYXRlXG4gICAgICAgIC8vIGl0IHRob3VnaC4gQXNzdW1lIDEgaW5zdGVhZC5cbiAgICAgICAgZGljdC5pbnRlcnZhbCA9IDE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFVOVElMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWUuZGF0ZS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZtdEljYWwpIHtcbiAgICAgICAgZGljdC51bnRpbCA9IElDQUwuVGltZS5mcm9tU3RyaW5nKGRpY3QudW50aWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBXS1NUOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgaWYgKFZBTElEX0RBWV9OQU1FUy50ZXN0KHZhbHVlKSkge1xuICAgICAgICBkaWN0Lndrc3QgPSBJQ0FMLlJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFdLU1QgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBhcnREZXNpZ24gPSB7XG4gICAgQllTRUNPTkQ6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZU0VDT05EJywgMCwgNjApLFxuICAgIEJZTUlOVVRFOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWU1JTlVURScsIDAsIDU5KSxcbiAgICBCWUhPVVI6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZSE9VUicsIDAsIDIzKSxcbiAgICBCWURBWTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChWQUxJRF9CWURBWV9QQVJULnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBCWURBWSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgQllNT05USERBWTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNT05USERBWScsIC0zMSwgMzEpLFxuICAgIEJZWUVBUkRBWTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllZRUFSREFZJywgLTM2NiwgMzY2KSxcbiAgICBCWVdFRUtOTzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllXRUVLTk8nLCAtNTMsIDUzKSxcbiAgICBCWU1PTlRIOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWU1PTlRIJywgMSwgMTIpLFxuICAgIEJZU0VUUE9TOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWVNFVFBPUycsIC0zNjYsIDM2NilcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlJlY3VyfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgICAgICAgVGhlIGNyZWF0ZWQgcmVjdXJyZW5jZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5SZWN1ci5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGEgPSBJQ0FMLlJlY3VyLl9zdHJpbmdUb0RhdGEoc3RyaW5nLCBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyKGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlJlY3VyfSBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZFxuICAgKiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcmVjdXJyZW5jZVxuICAgKiBAcGFyYW0ge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzPX0gYURhdGEuZnJlcSAgICBUaGUgZnJlcXVlbmN5IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgIFRoZSBJTlRFUlZBTCB2YWx1ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYURhdGEud2tzdCAgICAgICAgICAgICBUaGUgd2VlayBzdGFydCB2YWx1ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlIHNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXNlY29uZCAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltaW51dGUgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5aG91ciAgICAgICAgICAgICAgVGhlIGhvdXJzIGZvciB0aGUgQllIT1VSIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPj19IGFEYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltb250aGRheSAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl5ZWFyZGF5ICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZWUVBUkRBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXdlZWtubyAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGggICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXNldHBvcyAgICAgICAgICAgIFRoZSBwb3NpdGlvbmFscyBmb3IgdGhlIEJZU0VUUE9TIHBhcnRcbiAgICovXG4gIElDQUwuUmVjdXIuZnJvbURhdGEgPSBmdW5jdGlvbihhRGF0YSkge1xuICAgIHJldHVybiBuZXcgSUNBTC5SZWN1cihhRGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcmVjdXJyZW5jZSBzdHJpbmcgdG8gYSBkYXRhIG9iamVjdCwgc3VpdGFibGUgZm9yIHRoZSBmcm9tRGF0YVxuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBmbXRJY2FsICAgSWYgdHJ1ZSwgdGhlIHN0cmluZyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgICBUaGUgcmVjdXJyZW5jZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhID0gZnVuY3Rpb24oc3RyaW5nLCBmbXRJY2FsKSB7XG4gICAgdmFyIGRpY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gc3BsaXQgaXMgc2xvd2VyIGluIEZGIGJ1dCBmYXN0IGVub3VnaC5cbiAgICAvLyB2OCBob3dldmVyIHRoaXMgaXMgZmFzdGVyIHRoZW4gbWFudWFsIHNwbGl0P1xuICAgIHZhciB2YWx1ZXMgPSBzdHJpbmcuc3BsaXQoJzsnKTtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlc1tpXS5zcGxpdCgnPScpO1xuICAgICAgdmFyIHVjbmFtZSA9IHBhcnRzWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB2YXIgbGNuYW1lID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBuYW1lID0gKGZtdEljYWwgPyBsY25hbWUgOiB1Y25hbWUpO1xuICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV07XG5cbiAgICAgIGlmICh1Y25hbWUgaW4gcGFydERlc2lnbikge1xuICAgICAgICB2YXIgcGFydEFyciA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBwYXJ0QXJySWR4ID0gMDtcbiAgICAgICAgdmFyIHBhcnRBcnJMZW4gPSBwYXJ0QXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgcGFydEFycklkeCA8IHBhcnRBcnJMZW47IHBhcnRBcnJJZHgrKykge1xuICAgICAgICAgIHBhcnRBcnJbcGFydEFycklkeF0gPSBwYXJ0RGVzaWduW3VjbmFtZV0ocGFydEFycltwYXJ0QXJySWR4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZGljdFtuYW1lXSA9IChwYXJ0QXJyLmxlbmd0aCA9PSAxID8gcGFydEFyclswXSA6IHBhcnRBcnIpO1xuICAgICAgfSBlbHNlIGlmICh1Y25hbWUgaW4gb3B0aW9uRGVzaWduKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnblt1Y25hbWVdKHZhbHVlLCBkaWN0LCBmbXRJY2FsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IHN3YWxsb3cgdW5rbm93biB2YWx1ZXMuIEp1c3Qgc2V0IHRoZW0gYXMgdGhleSBhcmUuXG4gICAgICAgIGRpY3RbbGNuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlJlY3VySXRlcmF0b3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQW4gaXRlcmF0b3IgZm9yIGEgc2luZ2xlIHJlY3VycmVuY2UgcnVsZS4gVGhpcyBjbGFzcyB1c3VhbGx5IGRvZXNuJ3QgaGF2ZVxuICAgKiB0byBiZSBpbnN0YW5jaWF0ZWQgZGlyZWN0bHksIHRoZSBjb252ZW5pZW5jZSBtZXRob2RcbiAgICoge0BsaW5rIElDQUwuUmVjdXIjaXRlcmF0b3J9IGNhbiBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycyB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvbiBmcm9tIGEgcHJldmlvdXMgcnVuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzIHdoZW4gcmVzdW1pbmcgaXRlcmF0aW9uXG4gICAqIGZyb20gYSBwcmV2aW91cyBydW4uXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1ckl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgIFRoZSBpdGVyYXRvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7SUNBTC5SZWN1cn0gb3B0aW9ucy5ydWxlICAgICAgIFRoZSBydWxlIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5pbml0aWFsaXplZCAgV2hlbiB0cnVlLCBhc3N1bWUgdGhhdCBvcHRpb25zIGFyZVxuICAgKiAgICAgICAgZnJvbSBhIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgaXRlcmF0b3IuIEluaXRpYWxpemF0aW9uIHdpbGwgbm90IGJlXG4gICAqICAgICAgICByZXBlYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGljYWxyZWN1cl9pdGVyYXRvcihvcHRpb25zKSB7XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIGljYWxyZWN1cl9pdGVyYXRvci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZpbmlzaGVkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcnVsZSB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkXG4gICAgICogQHR5cGUge0lDQUwuUmVjdXJ9XG4gICAgICovXG4gICAgcnVsZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCBiZWluZyBpdGVyYXRlZC5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGR0c3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBvY2N1cnJlbmNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlXG4gICAgICoge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNuZXh0fSBtZXRob2QuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBsYXN0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG51bWJlciBmcm9tIHRoZSBvY2N1cnJlbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBvY2N1cnJlbmNlX251bWJlcjogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRpY2VzIHVzZWQgZm9yIHRoZSB7QGxpbmsgSUNBTC5SZWN1ckl0ZXJhdG9yI2J5X2RhdGF9IG9iamVjdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnlfaW5kaWNlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBpdGVyYXRvciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbGl6ZCBieS1kYXRhLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBieV9kYXRhOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4cGFuZGVkIHllYXJkYXlzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGF5czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBpbiB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNkYXlzfSBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGF5c19pbmRleDogMCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgaXRlcmF0b3IgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHVzdWFsbHkgbm90IGNhbGxlZCBkaXJlY3RseSwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBpdGVyYXRvclxuICAgICAqIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgVGhlIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0lDQUwuUmVjdXJ9IG9wdGlvbnMucnVsZSAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBvcHRpb25zLmluaXRpYWxpemVkICBXaGVuIHRydWUsIGFzc3VtZSB0aGF0IG9wdGlvbnMgYXJlXG4gICAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgICAqICAgICAgICByZXBlYXRlZC5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5ydWxlID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLnJ1bGUsIElDQUwuUmVjdXIpO1xuXG4gICAgICBpZiAoIXRoaXMucnVsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuUmVjdXIpIHJ1bGUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kdHN0YXJ0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIElDQUwuVGltZSk7XG5cbiAgICAgIGlmICghdGhpcy5kdHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgcmVxdWlyZXMgYSAoSUNBTC5UaW1lKSBkdHN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmJ5X2RhdGEpIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhID0gb3B0aW9ucy5ieV9kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMucnVsZS5wYXJ0cywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9jY3VycmVuY2VfbnVtYmVyKVxuICAgICAgICB0aGlzLm9jY3VycmVuY2VfbnVtYmVyID0gb3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcjtcblxuICAgICAgdGhpcy5kYXlzID0gb3B0aW9ucy5kYXlzIHx8IFtdO1xuICAgICAgaWYgKG9wdGlvbnMubGFzdCkge1xuICAgICAgICB0aGlzLmxhc3QgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMubGFzdCwgSUNBTC5UaW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ieV9pbmRpY2VzID0gb3B0aW9ucy5ieV9pbmRpY2VzO1xuXG4gICAgICBpZiAoIXRoaXMuYnlfaW5kaWNlcykge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMgPSB7XG4gICAgICAgICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgICAgICAgIFwiQllNSU5VVEVcIjogMCxcbiAgICAgICAgICBcIkJZSE9VUlwiOiAwLFxuICAgICAgICAgIFwiQllEQVlcIjogMCxcbiAgICAgICAgICBcIkJZTU9OVEhcIjogMCxcbiAgICAgICAgICBcIkJZV0VFS05PXCI6IDAsXG4gICAgICAgICAgXCJCWU1PTlRIREFZXCI6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdGlvbnMuaW5pdGlhbGl6ZWQgfHwgZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW50aWFsaXplIHRoZSBpdGVyYXRvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaWNhbHJlY3VyX2l0ZXJhdG9yX2luaXQoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubGFzdCA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5ieV9kYXRhO1xuXG4gICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIGxpYmljYWwgZG9lcyB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcnVsZSBpcyBsb2FkZWQsIGJ1dCB3ZSBwb3N0cG9uZSB0b1xuICAgICAgICAvLyBub3cgc28gd2UgY2FuIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBvcmRlci5cbiAgICAgICAgdGhpcy5zb3J0X2J5ZGF5X3J1bGVzKHBhcnRzLkJZREFZKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIEJZWUVBUkRBWSBhcHBhcmVzLCBubyBvdGhlciBkYXRlIHJ1bGUgcGFydCBtYXkgYXBwZWFyXG4gICAgICBpZiAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzIHx8XG4gICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEJZWUVBUkRBWSBydWxlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJZV0VFS05PIGFuZCBCWU1PTlRIREFZIHJ1bGUgcGFydHMgbWF5IG5vdCBib3RoIGFwcGVhclxuICAgICAgaWYgKFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVdFRUtOTyBkb2VzIG5vdCBmaXQgdG8gQllNT05USERBWVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgKEZSRVE9TU9OVEhMWSkgbmVpdGhlciBCWVlFQVJEQVkgbm9yXG4gICAgICAvLyBCWVdFRUtOTyBtYXkgYXBwZWFyLlxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiICYmXG4gICAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3IgTU9OVEhMWSByZWN1cnJlbmNlcyBuZWl0aGVyIEJZWUVBUkRBWSBub3IgQllXRUVLTk8gbWF5IGFwcGVhclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIFdFRUtMWSByZWN1cnJlbmNlcyAoRlJFUT1XRUVLTFkpIG5laXRoZXIgQllNT05USERBWSBub3JcbiAgICAgIC8vIEJZWUVBUkRBWSBtYXkgYXBwZWFyLlxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiV0VFS0xZXCIgJiZcbiAgICAgICAgICAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIFdFRUtMWSByZWN1cnJlbmNlcyBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yIEJZWUVBUkRBWSBtYXkgYXBwZWFyXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1xuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IFwiWUVBUkxZXCIgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0LnNlY29uZCA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIHRoaXMuZHRzdGFydC5zZWNvbmQpO1xuICAgICAgdGhpcy5sYXN0Lm1pbnV0ZSA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsIHRoaXMuZHRzdGFydC5taW51dGUpO1xuICAgICAgdGhpcy5sYXN0LmhvdXIgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIHRoaXMuZHRzdGFydC5ob3VyKTtcbiAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNT05USERBWVwiLCBcIkRBSUxZXCIsIHRoaXMuZHRzdGFydC5kYXkpO1xuICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhcIiwgXCJNT05USExZXCIsIHRoaXMuZHRzdGFydC5tb250aCk7XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiKSB7XG4gICAgICAgIGlmIChcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhwYXJ0cy5CWURBWVswXSwgdGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIHZhciBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgIHZhciB3a2R5ID0gZG93IC0gdGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgICAgaWYgKCh0aGlzLmxhc3QuZGF5T2ZXZWVrKHRoaXMucnVsZS53a3N0KSA8IGRvdyAmJiB3a2R5ID49IDApIHx8IHdrZHkgPCAwKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsIHRpbWUgaXMgYWZ0ZXIgZmlyc3QgZGF5IG9mIEJZREFZIGRhdGFcbiAgICAgICAgICAgIHRoaXMubGFzdC5kYXkgKz0gd2tkeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRheU5hbWUgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy5kdHN0YXJ0LmRheU9mV2VlaygpKTtcbiAgICAgICAgICBwYXJ0cy5CWURBWSA9IFtkYXlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJZRUFSTFlcIikge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgICBpZiAodGhpcy5kYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIiAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgdmFyIHRlbXBMYXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIGluaXRMYXN0ID0gdGhpcy5sYXN0LmNsb25lKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcblxuICAgICAgICAvLyBDaGVjayBldmVyeSB3ZWVrZGF5IGluIEJZREFZIHdpdGggcmVsYXRpdmUgZG93IGFuZCBwb3MuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllEQVkuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxhc3QgPSBpbml0TGFzdC5jbG9uZSgpO1xuICAgICAgICAgIHZhciBieWRheVBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKHRoaXMuYnlfZGF0YS5CWURBWVtpXSk7XG4gICAgICAgICAgdmFyIHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgdmFyIGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgdmFyIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG5cbiAgICAgICAgICAvLyBJZiB8cG9zfCA+PSA2LCB0aGUgYnlkYXkgaXMgaW52YWxpZCBmb3IgYSBtb250aGx5IHJ1bGUuXG4gICAgICAgICAgaWYgKHBvcyA+PSA2IHx8IHBvcyA8PSAtNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgQnlkYXkgd2l0aCBwb3M9Ky8tNSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgbW9udGggaXRcbiAgICAgICAgICAvLyBtdXN0IGJlIHNlYXJjaGVkIGluIHRoZSBuZXh0IG1vbnRocy5cbiAgICAgICAgICBpZiAoZGF5T2ZNb250aCA+IGRheXNJbk1vbnRoIHx8IGRheU9mTW9udGggPD0gMCkge1xuICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSBoYXZlIGFscmVhZHkgZm91bmQgYSBcImxhc3RcIiBpbiB0aGlzIG1vbnRoLlxuICAgICAgICAgICAgaWYgKHRlbXBMYXN0ICYmIHRlbXBMYXN0Lm1vbnRoID09IGluaXRMYXN0Lm1vbnRoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgICAgIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheU9mTW9udGg7XG4gICAgICAgICAgaWYgKCF0ZW1wTGFzdCB8fCB0aGlzLmxhc3QuY29tcGFyZSh0ZW1wTGFzdCkgPCAwKSB7XG4gICAgICAgICAgICB0ZW1wTGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3QgPSB0ZW1wTGFzdC5jbG9uZSgpO1xuXG4gICAgICAgIC8vWFhYOiBUaGlzIGZlZWxzIGxpa2UgYSBoYWNrLCBidXQgd2UgbmVlZCB0byBpbml0aWFsaXplXG4gICAgICAgIC8vICAgICB0aGUgQllNT05USERBWSBjYXNlIGNvcnJlY3RseSBhbmQgYnlEYXlBbmRNb250aERheSBoYW5kbGVzXG4gICAgICAgIC8vICAgICB0aGlzIGNhc2UuIEl0IGFjY2VwdHMgYSBzcGVjaWFsIGZsYWcgd2hpY2ggd2lsbCBhdm9pZCBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gICAgIHRoZSBpbml0aWFsIHZhbHVlIHdpdGhvdXQgdGhlIGZsYWcgZGF5cyB0aGF0IG1hdGNoIHRoZSBzdGFydCB0aW1lXG4gICAgICAgIC8vICAgICB3b3VsZCBiZSBtaXNzZWQuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWU1PTlRIREFZJykpIHtcbiAgICAgICAgICB0aGlzLl9ieURheUFuZE1vbnRoRGF5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPiBkYXlzSW5Nb250aCB8fCB0aGlzLmxhc3QuZGF5ID09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIHBhcnRcIik7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICBpZiAodGhpcy5sYXN0LmRheSA8IDApIHtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheXNJbk1vbnRoICsgdGhpcy5sYXN0LmRheSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbiBpY2FscmVjdXJfaXRlcmF0b3JfbmV4dCgpIHtcbiAgICAgIHZhciBiZWZvcmUgPSAodGhpcy5sYXN0ID8gdGhpcy5sYXN0LmNsb25lKCkgOiBudWxsKTtcblxuICAgICAgaWYgKCh0aGlzLnJ1bGUuY291bnQgJiYgdGhpcy5vY2N1cnJlbmNlX251bWJlciA+PSB0aGlzLnJ1bGUuY291bnQpIHx8XG4gICAgICAgICAgKHRoaXMucnVsZS51bnRpbCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLnJ1bGUudW50aWwpID4gMCkpIHtcblxuICAgICAgICAvL1hYWDogcmlnaHQgbm93IHRoaXMgaXMganVzdCBhIGZsYWcgYW5kIGhhcyBubyBpbXBhY3RcbiAgICAgICAgLy8gICAgIHdlIGNhbiBzaW1wbGlmeSB0aGUgYWJvdmUgY2FzZSB0byBjaGVjayBmb3IgY29tcGxldGVkIGxhdGVyLlxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9jY3VycmVuY2VfbnVtYmVyID09IDAgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA+PSAwKSB7XG4gICAgICAgIC8vIEZpcnN0IG9mIGFsbCwgZ2l2ZSB0aGUgaW5zdGFuY2UgdGhhdCB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuXG5cbiAgICAgIHZhciB2YWxpZDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFsaWQgPSAxO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5ydWxlLmZyZXEpIHtcbiAgICAgICAgY2FzZSBcIlNFQ09ORExZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3NlY29uZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUlOVVRFTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfbWludXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIT1VSTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfaG91cigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiREFJTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfZGF5KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXRUVLTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfd2VlaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTU9OVEhMWVwiOlxuICAgICAgICAgIHZhbGlkID0gdGhpcy5uZXh0X21vbnRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJZRUFSTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfeWVhcigpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCF0aGlzLmNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkgfHxcbiAgICAgICAgICAgICAgIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPCAwIHx8XG4gICAgICAgICAgICAgICAhdmFsaWQpO1xuXG4gICAgICAvLyBUT0RPIGlzIHRoaXMgdmFsaWQ/XG4gICAgICBpZiAodGhpcy5sYXN0LmNvbXBhcmUoYmVmb3JlKSA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNhbWUgb2NjdXJyZW5jZSBmb3VuZCB0d2ljZSwgcHJvdGVjdGluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBmcm9tIGRlYXRoIGJ5IHJlY3Vyc2lvblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVsZS51bnRpbCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLnJ1bGUudW50aWwpID4gMCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X3NlY29uZDogZnVuY3Rpb24gbmV4dF9zZWNvbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIFwic2Vjb25kXCIsIFwibWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfc2Vjb25kOiBmdW5jdGlvbiBpbmNyZW1lbnRfc2Vjb25kKGluYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50X2dlbmVyaWMoaW5jLCBcInNlY29uZFwiLCA2MCwgXCJtaW51dGVcIik7XG4gICAgfSxcblxuICAgIG5leHRfbWludXRlOiBmdW5jdGlvbiBuZXh0X21pbnV0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRfZ2VuZXJpYyhcIkJZTUlOVVRFXCIsIFwiTUlOVVRFTFlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZVwiLCBcImhvdXJcIiwgXCJuZXh0X3NlY29uZFwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21pbnV0ZTogZnVuY3Rpb24gaW5jcmVtZW50X21pbnV0ZShpbmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJtaW51dGVcIiwgNjAsIFwiaG91clwiKTtcbiAgICB9LFxuXG4gICAgbmV4dF9ob3VyOiBmdW5jdGlvbiBuZXh0X2hvdXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWUhPVVJcIiwgXCJIT1VSTFlcIiwgXCJob3VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtb250aGRheVwiLCBcIm5leHRfbWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfaG91cjogZnVuY3Rpb24gaW5jcmVtZW50X2hvdXIoaW5jKSB7XG4gICAgICB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJob3VyXCIsIDI0LCBcIm1vbnRoZGF5XCIpO1xuICAgIH0sXG5cbiAgICBuZXh0X2RheTogZnVuY3Rpb24gbmV4dF9kYXkoKSB7XG4gICAgICB2YXIgaGFzX2J5X2RheSA9IChcIkJZREFZXCIgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICAgIHZhciB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gXCJEQUlMWVwiKTtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBuZXh0X3dlZWs6IGZ1bmN0aW9uIG5leHRfd2VlaygpIHtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfd2Vla2RheV9ieV93ZWVrKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllXRUVLTk9cIikpIHtcbiAgICAgICAgdmFyIGlkeCA9ICsrdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPT0gdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTyA9IDA7XG4gICAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSEFDSyBzaG91bGQgYmUgZmlyc3QgbW9udGggb2YgdGhlIHllYXJcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gMTtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG5cbiAgICAgICAgdmFyIHdlZWtfbm8gPSB0aGlzLmJ5X2RhdGEuQllXRUVLTk9bdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PXTtcblxuICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IDcgKiB3ZWVrX25vO1xuXG4gICAgICAgIGlmIChlbmRfb2ZfZGF0YSkge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEp1bXAgdG8gdGhlIG5leHQgd2Vla1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSg3ICogdGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgZWFjaCBieSBkYXkgcnVsZSBmb3IgYSBnaXZlbiB5ZWFyL21vbnRoLlxuICAgICAqIFRha2VzIGludG8gYWNjb3VudCBvcmRlcmluZyBhbmQgbmVnYXRpdmUgcnVsZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICBDdXJyZW50IHllYXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICBDdXJyZW50IG1vbnRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBydWxlcyAgICAgICAgQXJyYXkgb2YgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc29ydGVkIGFuZCBub3JtYWxpemVkIHJ1bGVzLlxuICAgICAqICAgICAgICAgICAgICAgICBOZWdhdGl2ZSBydWxlcyB3aWxsIGJlIGV4cGFuZGVkIHRvIHRoZWlyXG4gICAgICogICAgICAgICAgICAgICAgIGNvcnJlY3QgcG9zaXRpdmUgdmFsdWVzIGZvciBlYXNpZXIgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBub3JtYWxpemVCeU1vbnRoRGF5UnVsZXM6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBydWxlcykge1xuICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcblxuICAgICAgLy8gWFhYOiBUaGlzIGlzIHByb2JhYmx5IGJhZCBmb3IgcGVyZm9ybWFuY2UgdG8gYWxsb2NhdGVcbiAgICAgIC8vICAgICAgYSBuZXcgYXJyYXkgZm9yIGVhY2ggbW9udGggd2Ugc2NhbiwgaWYgcG9zc2libGVcbiAgICAgIC8vICAgICAgd2Ugc2hvdWxkIHRyeSB0byBvcHRpbWl6ZSB0aGlzLi4uXG4gICAgICB2YXIgbmV3UnVsZXMgPSBbXTtcblxuICAgICAgdmFyIHJ1bGVJZHggPSAwO1xuICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHZhciBydWxlO1xuXG4gICAgICBmb3IgKDsgcnVsZUlkeCA8IGxlbjsgcnVsZUlkeCsrKSB7XG4gICAgICAgIHJ1bGUgPSBydWxlc1tydWxlSWR4XTtcblxuICAgICAgICAvLyBpZiB0aGlzIHJ1bGUgZmFsbHMgb3V0c2lkZSBvZiBnaXZlblxuICAgICAgICAvLyBtb250aCBkaXNjYXJkIGl0LlxuICAgICAgICBpZiAoTWF0aC5hYnMocnVsZSkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVnYXRpdmUgY2FzZVxuICAgICAgICBpZiAocnVsZSA8IDApIHtcbiAgICAgICAgICAvLyB3ZSBhZGQgKG5vdCBzdWJ0cmFjdCBpdCBpcyBhIG5lZ2F0aXZlIG51bWJlcilcbiAgICAgICAgICAvLyBvbmUgZnJvbSB0aGUgcnVsZSBiZWNhdXNlIDEgPT09IGxhc3QgZGF5IG9mIG1vbnRoXG4gICAgICAgICAgcnVsZSA9IGRheXNJbk1vbnRoICsgKHJ1bGUgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChydWxlID09PSAwKSB7XG4gICAgICAgICAgLy8gc2tpcCB6ZXJvOiBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBhZGQgdW5pcXVlIGl0ZW1zLi4uXG4gICAgICAgIGlmIChuZXdSdWxlcy5pbmRleE9mKHJ1bGUpID09PSAtMSkge1xuICAgICAgICAgIG5ld1J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyB1bmlxdWUgYW5kIHNvcnRcbiAgICAgIHJldHVybiBuZXdSdWxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTk9URVM6XG4gICAgICogV2UgYXJlIGdpdmVuIGEgbGlzdCBvZiBkYXRlcyBpbiB0aGUgbW9udGggKEJZTU9OVEhEQVkpICgyMywgZXRjLi4pXG4gICAgICogQWxzbyB3ZSBhcmUgZ2l2ZW4gYSBsaXN0IG9mIGRheXMgKEJZREFZKSAoTU8sIDJTVSwgZXRjLi4pIHdoZW5cbiAgICAgKiBib3RoIGNvbmRpdGlvbnMgbWF0Y2ggYSBnaXZlbiBkYXRlICh0aGlzLmxhc3QuZGF5KSBpdGVyYXRpb24gc3RvcHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IGlzSW5pdCAgICAgV2hlbiBnaXZlbiB0cnVlIHdpbGwgbm90IGluY3JlbWVudCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCBkYXkgKHRoaXMubGFzdCkuXG4gICAgICovXG4gICAgX2J5RGF5QW5kTW9udGhEYXk6IGZ1bmN0aW9uKGlzSW5pdCkge1xuICAgICAgdmFyIGJ5TW9udGhEYXk7IC8vIHNldHVwIGluIGluaXRNb250aFxuICAgICAgdmFyIGJ5RGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZO1xuXG4gICAgICB2YXIgZGF0ZTtcbiAgICAgIHZhciBkYXRlSWR4ID0gMDtcbiAgICAgIHZhciBkYXRlTGVuOyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICAgIHZhciBkYXlMZW4gPSBieURheS5sZW5ndGg7XG5cbiAgICAgIC8vIHdlIGFyZSBub3QgdmFsaWQgYnkgZGVmYXVsdFxuICAgICAgdmFyIGRhdGFJc1ZhbGlkID0gMDtcblxuICAgICAgdmFyIGRheXNJbk1vbnRoO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gd2UgbmVlZCBhIGNvcHkgb2YgdGhpcywgYmVjYXVzZSBhIERhdGVUaW1lIGdldHMgbm9ybWFsaXplZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBpZiB0aGUgZGF5IGlzIG91dCBvZiByYW5nZS4gQXQgc29tZSBwb2ludHMgd2VcbiAgICAgIC8vIHNldCB0aGUgbGFzdCBkYXkgdG8gMCB0byBzdGFydCBjb3VudGluZy5cbiAgICAgIHZhciBsYXN0RGF5ID0gdGhpcy5sYXN0LmRheTtcblxuICAgICAgZnVuY3Rpb24gaW5pdE1vbnRoKCkge1xuICAgICAgICBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChcbiAgICAgICAgICBzZWxmLmxhc3QubW9udGgsIHNlbGYubGFzdC55ZWFyXG4gICAgICAgICk7XG5cbiAgICAgICAgYnlNb250aERheSA9IHNlbGYubm9ybWFsaXplQnlNb250aERheVJ1bGVzKFxuICAgICAgICAgIHNlbGYubGFzdC55ZWFyLFxuICAgICAgICAgIHNlbGYubGFzdC5tb250aCxcbiAgICAgICAgICBzZWxmLmJ5X2RhdGEuQllNT05USERBWVxuICAgICAgICApO1xuXG4gICAgICAgIGRhdGVMZW4gPSBieU1vbnRoRGF5Lmxlbmd0aDtcblxuICAgICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlIGluIG9uZSBtb250aFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gc3RhcnQgc2VhcmNoaW5nIGFmdGVyIHRoZSBsYXN0XG4gICAgICAgIC8vIGZvdW5kIGRhdGUgb3IgYXQgdGhlIGxhc3QgQllNT05USERBWSwgdW5sZXNzIHdlIGFyZVxuICAgICAgICAvLyBpbml0aWFsaXppbmcgdGhlIGl0ZXJhdG9yIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHdlIGhhdmVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGxhc3QgZm91bmQgZGF0ZSB0b28uXG4gICAgICAgIHdoaWxlIChieU1vbnRoRGF5W2RhdGVJZHhdIDw9IGxhc3REYXkgJiZcbiAgICAgICAgICAgICAgICEoaXNJbml0ICYmIGJ5TW9udGhEYXlbZGF0ZUlkeF0gPT0gbGFzdERheSkgJiZcbiAgICAgICAgICAgICAgIGRhdGVJZHggPCBkYXRlTGVuIC0gMSkge1xuICAgICAgICAgIGRhdGVJZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0TW9udGgoKSB7XG4gICAgICAgIC8vIHNpbmNlIHRoZSBkYXkgaXMgaW5jcmVtZW50ZWQgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIG9mIHRoZSBsb29wIGJlbG93LCB3ZSBuZWVkIHRvIHN0YXJ0IGF0IDBcbiAgICAgICAgbGFzdERheSA9IDA7XG4gICAgICAgIHNlbGYuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIGRhdGVJZHggPSAwO1xuICAgICAgICBpbml0TW9udGgoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdE1vbnRoKCk7XG5cbiAgICAgIC8vIHNob3VsZCBjb21lIGFmdGVyIGluaXRNb250aFxuICAgICAgaWYgKGlzSW5pdCkge1xuICAgICAgICBsYXN0RGF5IC09IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhIGNvdW50ZXIgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCB3aXRoIG1hbGZvcm1lZCBydWxlcy5cbiAgICAgIC8vIFN0b3AgY2hlY2tpbmcgYWZ0ZXIgNCB5ZWFycyBzbyB3ZSBjb25zaWRlciBhbHNvIGEgbGVhcCB5ZWFyLlxuICAgICAgdmFyIG1vbnRoc0NvdW50ZXIgPSA0ODtcblxuICAgICAgd2hpbGUgKCFkYXRhSXNWYWxpZCAmJiBtb250aHNDb3VudGVyKSB7XG4gICAgICAgIG1vbnRoc0NvdW50ZXItLTtcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjdXJyZW50IGRhdGUuIFRoaXMgaXMgcmVhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCBvdGhlcndpc2Ugd2UgbWF5IGZhbGwgaW50byB0aGUgaW5maW5pdGVcbiAgICAgICAgLy8gbG9vcCB0cmFwLiBUaGUgaW5pdGlhbCBkYXRlIHRha2VzIGNhcmUgb2YgdGhlIGNhc2VcbiAgICAgICAgLy8gd2hlcmUgdGhlIGN1cnJlbnQgZGF0ZSBpcyB0aGUgZGF0ZSB3ZSBhcmUgbG9va2luZ1xuICAgICAgICAvLyBmb3IuXG4gICAgICAgIGRhdGUgPSBsYXN0RGF5ICsgMTtcblxuICAgICAgICBpZiAoZGF0ZSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgbmV4dE1vbnRoKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIG5leHQgZGF0ZVxuICAgICAgICB2YXIgbmV4dCA9IGJ5TW9udGhEYXlbZGF0ZUlkeCsrXTtcblxuICAgICAgICAvLyB0aGlzIGxvZ2ljIGlzIGRlcGVuZGFudCBvbiB0aGUgQllNT05USERBWVNcbiAgICAgICAgLy8gYmVpbmcgaW4gb3JkZXIgKHdoaWNoIGlzIGRvbmUgYnkgI25vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcylcbiAgICAgICAgaWYgKG5leHQgPj0gZGF0ZSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBuZXh0IG1vbnRoIGRheSBpcyBpbiB0aGUgZnV0dXJlIGp1bXAgdG8gaXQuXG4gICAgICAgICAgbGFzdERheSA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSAnbmV4dCcgbW9udGhkYXkgaGFzIHBhc3RcbiAgICAgICAgICAvLyB3ZSBtdXN0IG1vdmUgdG8gdGhlIG1vbnRoLlxuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHdlIGNhbiBsb29wIHRocm91Z2ggdGhlIGRheSBydWxlcyB0byBzZWVcbiAgICAgICAgLy8gaWYgb25lIG1hdGNoZXMgdGhlIGN1cnJlbnQgbW9udGggZGF0ZS5cbiAgICAgICAgZm9yICh2YXIgZGF5SWR4ID0gMDsgZGF5SWR4IDwgZGF5TGVuOyBkYXlJZHgrKykge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhieURheVtkYXlJZHhdKTtcbiAgICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3REYXk7XG4gICAgICAgICAgaWYgKHRoaXMubGFzdC5pc050aFdlZWtEYXkoZG93LCBwb3MpKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIGZpbmQgdGhlIHZhbGlkIG9uZSB3ZSBjYW4gbWFya1xuICAgICAgICAgICAgLy8gdGhlIGNvbmRpdGlvbnMgYXMgbWV0IGFuZCBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgICAgIC8vIChCZWNhdXNlIHdlIGhhdmUgdGhpcyBjb25kaXRpb24gYWJvdmVcbiAgICAgICAgICAgIC8vICBpdCB3aWxsIGFsc28gYnJlYWsgdGhlIHBhcmVudCBsb29wKS5cbiAgICAgICAgICAgIGRhdGFJc1ZhbGlkID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGNvbXBsZXRlbHkgcG9zc2libGUgdGhhdCB0aGUgY29tYmluYXRpb25cbiAgICAgICAgLy8gY2Fubm90IGJlIG1hdGNoZWQgaW4gdGhlIGN1cnJlbnQgbW9udGguXG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiBwb3NzaWJsZSBjb21iaW5hdGlvbnNcbiAgICAgICAgLy8gaW4gdGhlIGN1cnJlbnQgbW9udGggd2UgaXRlcmF0ZSB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAgIC8vIHNpbmNlIGRhdGVJZHggaXMgaW5jcmVtZW50ZWQgcmlnaHQgYWZ0ZXIgZ2V0dGluZ1xuICAgICAgICAvLyBcIm5leHRcIiwgd2UgZG9uJ3QgbmVlZCBkYXRlTGVuIC0xIGhlcmUuXG4gICAgICAgIGlmICghZGF0YUlzVmFsaWQgJiYgZGF0ZUlkeCA9PT0gZGF0ZUxlbikge1xuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aHNDb3VudGVyIDw9IDApIHtcbiAgICAgICAgLy8gQ2hlY2tlZCA0IHllYXJzIHdpdGhvdXQgZmluZGluZyBhIEJ5ZGF5IHRoYXQgbWF0Y2hlc1xuICAgICAgICAvLyBhIEJ5bW9udGhkYXkuIE1heWJlIHRoZSBydWxlIGlzIG5vdCBjb3JyZWN0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIGNvbWJpbmVkIHdpdGggQllNT05USERBWSBwYXJ0c1wiKTtcbiAgICAgIH1cblxuXG4gICAgICByZXR1cm4gZGF0YUlzVmFsaWQ7XG4gICAgfSxcblxuICAgIG5leHRfbW9udGg6IGZ1bmN0aW9uIG5leHRfbW9udGgoKSB7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiKTtcbiAgICAgIHZhciBkYXRhX3ZhbGlkID0gMTtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5fYnlEYXlBbmRNb250aERheSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICB2YXIgc2V0cG9zID0gMDtcbiAgICAgICAgdmFyIHNldHBvc190b3RhbCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSkge1xuICAgICAgICAgIHZhciBsYXN0X2RheSA9IHRoaXMubGFzdC5kYXk7XG4gICAgICAgICAgZm9yICh2YXIgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgICAgIHNldHBvc190b3RhbCsrO1xuICAgICAgICAgICAgICBpZiAoZGF5IDw9IGxhc3RfZGF5KSB7XG4gICAgICAgICAgICAgICAgc2V0cG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3RfZGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YV92YWxpZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGRheSA9IHRoaXMubGFzdC5kYXkgKyAxOyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSsrKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKCsrc2V0cG9zKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNldHBvcyAtIHNldHBvc190b3RhbCAtIDEpKSB7XG5cbiAgICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHwgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oMSkpIHtcbiAgICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA+PSB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA9IDA7XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIREFZXTtcblxuICAgICAgICBpZiAoZGF5IDwgMCkge1xuICAgICAgICAgIGRheSA9IGRheXNJbk1vbnRoICsgZGF5ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSB0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF0gPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICB9LFxuXG4gICAgbmV4dF93ZWVrZGF5X2J5X3dlZWs6IGZ1bmN0aW9uIG5leHRfd2Vla2RheV9ieV93ZWVrKCkge1xuICAgICAgdmFyIGVuZF9vZl9kYXRhID0gMDtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZREFZKys7XG5cbiAgICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9PSBPYmplY3Qua2V5cyh0aGlzLmJ5X2RhdGEuQllEQVkpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9IDA7XG4gICAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGVkX2RheSA9IHRoaXMuYnlfZGF0YS5CWURBWVt0aGlzLmJ5X2luZGljZXMuQllEQVldO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGRvdyAtPSB0aGlzLnJ1bGUud2tzdDtcblxuICAgICAgICBpZiAoZG93IDwgMCkge1xuICAgICAgICAgIGRvdyArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgdHQueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgICB0dC5tb250aCA9IHRoaXMubGFzdC5tb250aDtcbiAgICAgICAgdHQuZGF5ID0gdGhpcy5sYXN0LmRheTtcblxuICAgICAgICB2YXIgc3RhcnRPZldlZWsgPSB0dC5zdGFydERveVdlZWsodGhpcy5ydWxlLndrc3QpO1xuXG4gICAgICAgIGlmIChkb3cgKyBzdGFydE9mV2VlayA8IDEpIHtcbiAgICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgZGF0ZSBpcyBpbiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgICAgIGlmICghZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoc3RhcnRPZldlZWsgKyBkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdC55ZWFyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5vcm1hbGl6YXRpb24gaG9ycm9ycyBiZWxvdyBhcmUgZHVlIHRvXG4gICAgICAgICAqIHRoZSBmYWN0IHRoYXQgd2hlbiB0aGUgeWVhci9tb250aC9kYXkgY2hhbmdlc1xuICAgICAgICAgKiBpdCBjYW4gZWZmZWN0IHRoZSBvdGhlciBvcGVyYXRpb25zIHRoYXQgY29tZSBhZnRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdC55ZWFyID0gbmV4dC55ZWFyO1xuICAgICAgICB0aGlzLmxhc3QubW9udGggPSBuZXh0Lm1vbnRoO1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG5cbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X3llYXI6IGZ1bmN0aW9uIG5leHRfeWVhcigpIHtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCsrdGhpcy5kYXlzX2luZGV4ID09IHRoaXMuZGF5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kYXlzX2luZGV4ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgICAgICB0aGlzLmV4cGFuZF95ZWFyX2RheXModGhpcy5sYXN0LnllYXIpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmRheXMubGVuZ3RoID09IDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICBfbmV4dEJ5WWVhckRheTogZnVuY3Rpb24gX25leHRCeVllYXJEYXkoKSB7XG4gICAgICAgIHZhciBkb3kgPSB0aGlzLmRheXNbdGhpcy5kYXlzX2luZGV4XTtcbiAgICAgICAgdmFyIHllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgICAgaWYgKGRveSA8IDEpIHtcbiAgICAgICAgICAgIC8vIFRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpIGluZGV4ZXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAgICAvLyBzdGFydCBvZiB0aGUgZ2l2ZW4geWVhci4gVGhhdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbWFudGljcyBvZiBCWVlFQVJEQVkgd2hlcmUgbmVnYXRpdmUgaW5kZXhlcyBhcmUgYW5cbiAgICAgICAgICAgIC8vIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHllYXIuXG4gICAgICAgICAgICBkb3kgKz0gMTtcbiAgICAgICAgICAgIHllYXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSBuZXh0LmRheTtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRvdyAoZWc6ICcxVFUnLCAnLTFNTycpXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheVxuICAgICAqIEByZXR1cm4gW3BvcywgbnVtZXJpY0Rvd10gKGVnOiBbMSwgM10pIG51bWVyaWNEb3cgaXMgcmVsYXRpdmUgdG8gYVdlZWtTdGFydFxuICAgICAqL1xuICAgIHJ1bGVEYXlPZldlZWs6IGZ1bmN0aW9uIHJ1bGVEYXlPZldlZWsoZG93LCBhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IGRvdy5tYXRjaCgvKFsrLV0/WzAtOV0pPyhNT3xUVXxXRXxUSHxGUnxTQXxTVSkvKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHZhciBwb3MgPSBwYXJzZUludChtYXRjaGVzWzFdIHx8IDAsIDEwKTtcbiAgICAgICAgZG93ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KG1hdGNoZXNbMl0sIGFXZWVrU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3BvcywgZG93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5leHRfZ2VuZXJpYzogZnVuY3Rpb24gbmV4dF9nZW5lcmljKGFSdWxlVHlwZSwgYUludGVydmFsLCBhRGF0ZUF0dHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUZvbGxvd2luZ0F0dHIsIGFQcmV2aW91c0luY3IpIHtcbiAgICAgIHZhciBoYXNfYnlfcnVsZSA9IChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICAgIHZhciB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gYUludGVydmFsKTtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmIChhUHJldmlvdXNJbmNyICYmIHRoaXNbYVByZXZpb3VzSW5jcl0oKSA9PSAwKSB7XG4gICAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc19ieV9ydWxlKSB7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdKys7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXTtcbiAgICAgICAgdmFyIGR0YSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSA9PSBkdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSA9IGR0YVt0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYURhdGVBdHRyXSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzX2J5X3J1bGUgJiYgZW5kX29mX2RhdGEgJiYgdGhpc19mcmVxKSB7XG4gICAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhRm9sbG93aW5nQXR0cl0oMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21vbnRoZGF5OiBmdW5jdGlvbiBpbmNyZW1lbnRfbW9udGhkYXkoaW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluYzsgaSsrKSB7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdGhpcy5sYXN0LmRheSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5IC09IGRheXNJbk1vbnRoO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21vbnRoOiBmdW5jdGlvbiBpbmNyZW1lbnRfbW9udGgoKSB7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USFwiKSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USCA9PSB0aGlzLmJ5X2RhdGEuQllNT05USC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCA9IDA7XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIikge1xuICAgICAgICAgIHRoaXMubGFzdC5tb250aCArPSB0aGlzLnJ1bGUuaW50ZXJ2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QubW9udGgtLTtcbiAgICAgICAgdmFyIHllYXJzID0gSUNBTC5oZWxwZXJzLnRydW5jKHRoaXMubGFzdC5tb250aCAvIDEyKTtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoICU9IDEyO1xuICAgICAgICB0aGlzLmxhc3QubW9udGgrKztcblxuICAgICAgICBpZiAoeWVhcnMgIT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoeWVhcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluY3JlbWVudF95ZWFyOiBmdW5jdGlvbiBpbmNyZW1lbnRfeWVhcihpbmMpIHtcbiAgICAgIHRoaXMubGFzdC55ZWFyICs9IGluYztcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X2dlbmVyaWM6IGZ1bmN0aW9uIGluY3JlbWVudF9nZW5lcmljKGluYywgYURhdGVBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhRmFjdG9yLCBhTmV4dEluY3JlbWVudCkge1xuICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gKz0gaW5jO1xuICAgICAgdmFyIG5leHR1bml0ID0gSUNBTC5oZWxwZXJzLnRydW5jKHRoaXMubGFzdFthRGF0ZUF0dHJdIC8gYUZhY3Rvcik7XG4gICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSAlPSBhRmFjdG9yO1xuICAgICAgaWYgKG5leHR1bml0ICE9IDApIHtcbiAgICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFOZXh0SW5jcmVtZW50XShuZXh0dW5pdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc19ieV9kYXRhOiBmdW5jdGlvbiBoYXNfYnlfZGF0YShhUnVsZVR5cGUpIHtcbiAgICAgIHJldHVybiAoYVJ1bGVUeXBlIGluIHRoaXMucnVsZS5wYXJ0cyk7XG4gICAgfSxcblxuICAgIGV4cGFuZF95ZWFyX2RheXM6IGZ1bmN0aW9uIGV4cGFuZF95ZWFyX2RheXMoYVllYXIpIHtcbiAgICAgIHZhciB0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgICAgdGhpcy5kYXlzID0gW107XG5cbiAgICAgIC8vIFdlIG5lZWQgb3VyIG93biBjb3B5IHdpdGggYSBmZXcga2V5cyBzZXRcbiAgICAgIHZhciBwYXJ0cyA9IHt9O1xuICAgICAgdmFyIHJ1bGVzID0gW1wiQllEQVlcIiwgXCJCWVdFRUtOT1wiLCBcIkJZTU9OVEhEQVlcIiwgXCJCWU1PTlRIXCIsIFwiQllZRUFSREFZXCJdO1xuICAgICAgZm9yICh2YXIgcCBpbiBydWxlcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocnVsZXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHJ1bGVzW3BdO1xuICAgICAgICAgIGlmIChwYXJ0IGluIHRoaXMucnVsZS5wYXJ0cykge1xuICAgICAgICAgICAgcGFydHNbcGFydF0gPSB0aGlzLnJ1bGUucGFydHNbcGFydF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcIkJZTU9OVEhcIiBpbiBwYXJ0cyAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gMTtcbiAgICAgICAgdmFyIHZhbGlkV2Vla3MgPSB7fTtcbiAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBtb250aElkeCA9IDA7IG1vbnRoSWR4IDwgdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoOyBtb250aElkeCsrKSB7XG4gICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhJZHhdO1xuICAgICAgICAgIHQubW9udGggPSBtb250aDtcbiAgICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgICAgdmFyIGZpcnN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIHQuZGF5ID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgdmFyIGxhc3Rfd2VlayA9IHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgICAgZm9yIChtb250aElkeCA9IGZpcnN0X3dlZWs7IG1vbnRoSWR4IDwgbGFzdF93ZWVrOyBtb250aElkeCsrKSB7XG4gICAgICAgICAgICB2YWxpZFdlZWtzW21vbnRoSWR4XSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd2Vla0lkeCA9IDA7IHdlZWtJZHggPCB0aGlzLmJ5X2RhdGEuQllXRUVLTk8ubGVuZ3RoICYmIHZhbGlkOyB3ZWVrSWR4KyspIHtcbiAgICAgICAgICB2YXIgd2Vla25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3dlZWtJZHhdO1xuICAgICAgICAgIGlmICh3ZWVrbm8gPCA1Mikge1xuICAgICAgICAgICAgdmFsaWQgJj0gdmFsaWRXZWVrc1t3ZWVrSWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJ0cy5CWU1PTlRIO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwYXJ0cy5CWVdFRUtOTztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFydENvdW50ID0gT2JqZWN0LmtleXMocGFydHMpLmxlbmd0aDtcblxuICAgICAgaWYgKHBhcnRDb3VudCA9PSAwKSB7XG4gICAgICAgIHZhciB0MSA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICB0MS55ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICAgIHRoaXMuZGF5cy5wdXNoKHQxLmRheU9mWWVhcigpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0MiA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICAgIHQyLnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0Mi5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB0Mi5pc0RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQyLmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USERBWSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaGFzT3duUHJvcGVydHkobW9udGhkYXlrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHQzID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgdmFyIGRheV8gPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVttb250aGRheWtleV07XG4gICAgICAgICAgaWYgKGRheV8gPCAwKSB7XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodDMubW9udGgsIGFZZWFyKTtcbiAgICAgICAgICAgIGRheV8gPSBkYXlfICsgZGF5c0luTW9udGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0My5kYXkgPSBkYXlfO1xuICAgICAgICAgIHQzLnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0My5pc0RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQzLmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEguaGFzT3duUHJvcGVydHkobW9udGhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vbnRoXyA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgobW9udGhfLCBhWWVhcik7XG4gICAgICAgICAgZm9yICh2YXIgbW9udGhkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllNT05USERBWS5oYXNPd25Qcm9wZXJ0eShtb250aGRheWtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5XyA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW21vbnRoZGF5a2V5XTtcbiAgICAgICAgICAgIGlmIChkYXlfIDwgMCkge1xuICAgICAgICAgICAgICBkYXlfID0gZGF5XyArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQuZGF5ID0gZGF5XztcbiAgICAgICAgICAgIHQubW9udGggPSBtb250aF87XG4gICAgICAgICAgICB0LnllYXIgPSBhWWVhcjtcbiAgICAgICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2godC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBUT0RPIHVuaW1wbGVtZW50ZWQgaW4gbGliaWNhbFxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgICBcIkJZV0VFS05PXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgLy8gVE9ETyB1bmltcGxlbWVudGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEguaGFzT3duUHJvcGVydHkobW9udGhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhrZXldO1xuICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuXG4gICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgICAgdC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGZpcnN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgICAgICAgdmFyIGRveV9vZmZzZXQgPSB0LmRheU9mWWVhcigpIC0gMTtcblxuICAgICAgICAgIHQuZGF5ID0gZGF5c0luTW9udGg7XG4gICAgICAgICAgdmFyIGxhc3RfZG93ID0gdC5kYXlPZldlZWsoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICAgIHZhciBzZXRfcG9zX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIGJ5X21vbnRoX2RheSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgICB0LmRheSA9IGRheTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHQpKSB7XG4gICAgICAgICAgICAgICAgYnlfbW9udGhfZGF5LnB1c2goZGF5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBzcEluZGV4ID0gMDsgc3BJbmRleCA8IGJ5X21vbnRoX2RheS5sZW5ndGg7IHNwSW5kZXgrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCArIDEpIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzcEluZGV4IC0gYnlfbW9udGhfZGF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgYnlfbW9udGhfZGF5W3NwSW5kZXhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkYXljb2RlZGtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWNvZGVka2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbZGF5Y29kZWRrZXldO1xuICAgICAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayhjb2RlZF9kYXkpO1xuICAgICAgICAgICAgICB2YXIgcG9zID0gYnlkYXlQYXJ0c1swXTtcbiAgICAgICAgICAgICAgdmFyIGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgICAgIHZhciBtb250aF9kYXk7XG5cbiAgICAgICAgICAgICAgdmFyIGZpcnN0X21hdGNoaW5nX2RheSA9ICgoZG93ICsgNyAtIGZpcnN0X2RvdykgJSA3KSArIDE7XG4gICAgICAgICAgICAgIHZhciBsYXN0X21hdGNoaW5nX2RheSA9IGRheXNJbk1vbnRoIC0gKChsYXN0X2RvdyArIDcgLSBkb3cpICUgNyk7XG5cbiAgICAgICAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGF5ID0gZmlyc3RfbWF0Y2hpbmdfZGF5OyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSArPSA3KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIG1vbnRoX2RheSA9IGZpcnN0X21hdGNoaW5nX2RheSArIChwb3MgLSAxKSAqIDc7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9udGhfZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF5ID0gbGFzdF9tYXRjaGluZ19kYXkgKyAocG9zICsgMSkgKiA3O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBtb250aF9kYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZGF0ZXMgaW4gb3JkZXIgb2Ygb2NjdXJyZW5jZSAoMSwyLDMsLi4uKSBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIGJ5IGdyb3VwcyBvZiB3ZWVrZGF5cyAoMSw4LDE1LC4uLiwyLDksMTYsLi4uKS5cbiAgICAgICAgdGhpcy5kYXlzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pOyAvLyBDb21wYXJhdG9yIGZ1bmN0aW9uIGFsbG93cyB0byBzb3J0IG51bWJlcnMuXG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaW5kZXhPZih0dC5kYXkpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAzICYmXG4gICAgICAgICAgICAgICAgIFwiQllEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJ5X2RhdGEuQllNT05USC5pbmRleE9mKHR0Lm1vbnRoKSA+PSAwICYmXG4gICAgICAgICAgICAgIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICAgIHZhciBleHBhbmRlZERheXMgPSB0aGlzLmV4cGFuZF9ieV9kYXkoYVllYXIpO1xuXG4gICAgICAgIGZvciAodmFyIGRheWtleSBpbiBleHBhbmRlZERheXMpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIWV4cGFuZGVkRGF5cy5oYXNPd25Qcm9wZXJ0eShkYXlrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRheSA9IGV4cGFuZGVkRGF5c1tkYXlrZXldO1xuICAgICAgICAgIHZhciB0dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRheSwgYVllYXIpO1xuICAgICAgICAgIHZhciB3ZWVrbm8gPSB0dC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICAgIGlmICh0aGlzLmJ5X2RhdGEuQllXRUVLTk8uaW5kZXhPZih3ZWVrbm8pKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIFRPRE8gdW5pbXBsZW10ZWQgaW4gbGliaWNhbFxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZWUVBUkRBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5ieV9kYXRhLkJZWUVBUkRBWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRheXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBleHBhbmRfYnlfZGF5OiBmdW5jdGlvbiBleHBhbmRfYnlfZGF5KGFZZWFyKSB7XG5cbiAgICAgIHZhciBkYXlzX2xpc3QgPSBbXTtcbiAgICAgIHZhciB0bXAgPSB0aGlzLmxhc3QuY2xvbmUoKTtcblxuICAgICAgdG1wLnllYXIgPSBhWWVhcjtcbiAgICAgIHRtcC5tb250aCA9IDE7XG4gICAgICB0bXAuZGF5ID0gMTtcbiAgICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICB2YXIgc3RhcnRfZG93ID0gdG1wLmRheU9mV2VlaygpO1xuXG4gICAgICB0bXAubW9udGggPSAxMjtcbiAgICAgIHRtcC5kYXkgPSAzMTtcbiAgICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICB2YXIgZW5kX2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcbiAgICAgIHZhciBlbmRfeWVhcl9kYXkgPSB0bXAuZGF5T2ZZZWFyKCk7XG5cbiAgICAgIGZvciAodmFyIGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWtleV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICB2YXIgdG1wX3N0YXJ0X2RveSA9ICgoZG93ICsgNyAtIHN0YXJ0X2RvdykgJSA3KSArIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBkb3kgPSB0bXBfc3RhcnRfZG95OyBkb3kgPD0gZW5kX3llYXJfZGF5OyBkb3kgKz0gNykge1xuICAgICAgICAgICAgZGF5c19saXN0LnB1c2goZG95KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgdmFyIGZpcnN0O1xuICAgICAgICAgIGlmIChkb3cgPj0gc3RhcnRfZG93KSB7XG4gICAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZG93IC0gc3RhcnRfZG93ICsgODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXlzX2xpc3QucHVzaChmaXJzdCArIChwb3MgLSAxKSAqIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsYXN0O1xuICAgICAgICAgIHBvcyA9IC1wb3M7XG5cbiAgICAgICAgICBpZiAoZG93IDw9IGVuZF9kb3cpIHtcbiAgICAgICAgICAgIGxhc3QgPSBlbmRfeWVhcl9kYXkgLSBlbmRfZG93ICsgZG93O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0ID0gZW5kX3llYXJfZGF5IC0gZW5kX2RvdyArIGRvdyAtIDc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5c19saXN0LnB1c2gobGFzdCAtIChwb3MgLSAxKSAqIDcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF5c19saXN0O1xuICAgIH0sXG5cbiAgICBpc19kYXlfaW5fYnlkYXk6IGZ1bmN0aW9uIGlzX2RheV9pbl9ieWRheSh0dCkge1xuICAgICAgZm9yICh2YXIgZGF5a2V5IGluIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllEQVkuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbZGF5a2V5XTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGRheSk7XG4gICAgICAgIHZhciBwb3MgPSBwYXJ0c1swXTtcbiAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuICAgICAgICB2YXIgdGhpc19kb3cgPSB0dC5kYXlPZldlZWsoKTtcblxuICAgICAgICBpZiAoKHBvcyA9PSAwICYmIGRvdyA9PSB0aGlzX2RvdykgfHxcbiAgICAgICAgICAgICh0dC5udGhXZWVrRGF5KGRvdywgcG9zKSA9PSB0dC5kYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBpbiBCWVNFVFBPUy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1lcmljfSBhUG9zIHBvc2l0aW9uIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZSB1bmxlc3MgQllTRVRQT1MgcnVsZXMgZXhpc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gcnVsZXMuXG4gICAgICovXG4gICAgY2hlY2tfc2V0X3Bvc2l0aW9uOiBmdW5jdGlvbiBjaGVja19zZXRfcG9zaXRpb24oYVBvcykge1xuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoJ0JZU0VUUE9TJykpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYnlfZGF0YS5CWVNFVFBPUy5pbmRleE9mKGFQb3MpO1xuICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXJzIGFyZSBub3QgZmFsc2UteVxuICAgICAgICByZXR1cm4gaWR4ICE9PSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc29ydF9ieWRheV9ydWxlczogZnVuY3Rpb24gaWNhbHJlY3VyX3NvcnRfYnlkYXlfcnVsZXMoYVJ1bGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgIHZhciBvbmUgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2pdLCB0aGlzLnJ1bGUud2tzdClbMV07XG4gICAgICAgICAgdmFyIHR3byA9IHRoaXMucnVsZURheU9mV2VlayhhUnVsZXNbaV0sIHRoaXMucnVsZS53a3N0KVsxXTtcblxuICAgICAgICAgIGlmIChvbmUgPiB0d28pIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBhUnVsZXNbaV07XG4gICAgICAgICAgICBhUnVsZXNbaV0gPSBhUnVsZXNbal07XG4gICAgICAgICAgICBhUnVsZXNbal0gPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uOiBmdW5jdGlvbiBjaGVja19jb250cmFjdF9yZXN0cmljdGlvbihhUnVsZVR5cGUsIHYpIHtcbiAgICAgIHZhciBpbmRleE1hcFZhbHVlID0gaWNhbHJlY3VyX2l0ZXJhdG9yLl9pbmRleE1hcFthUnVsZVR5cGVdO1xuICAgICAgdmFyIHJ1bGVNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5fZXhwYW5kTWFwW3RoaXMucnVsZS5mcmVxXVtpbmRleE1hcFZhbHVlXTtcbiAgICAgIHZhciBwYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmIChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhICYmXG4gICAgICAgICAgcnVsZU1hcFZhbHVlID09IGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCkge1xuXG4gICAgICAgIHZhciBydWxlVHlwZSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICAgIGZvciAodmFyIGJ5ZGF0YWtleSBpbiBydWxlVHlwZSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHJ1bGVUeXBlLmhhc093blByb3BlcnR5KGJ5ZGF0YWtleSkpIHtcbiAgICAgICAgICAgIGlmIChydWxlVHlwZVtieWRhdGFrZXldID09IHYpIHtcbiAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY29udHJhY3RpbmcgYnlydWxlIG9yIGhhcyBubyBkYXRhLCB0ZXN0IHBhc3Nlc1xuICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXNzO1xuICAgIH0sXG5cbiAgICBjaGVja19jb250cmFjdGluZ19ydWxlczogZnVuY3Rpb24gY2hlY2tfY29udHJhY3RpbmdfcnVsZXMoKSB7XG4gICAgICB2YXIgZG93ID0gdGhpcy5sYXN0LmRheU9mV2VlaygpO1xuICAgICAgdmFyIHdlZWtObyA9IHRoaXMubGFzdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgIHZhciBkb3kgPSB0aGlzLmxhc3QuZGF5T2ZZZWFyKCk7XG5cbiAgICAgIHJldHVybiAodGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZU0VDT05EXCIsIHRoaXMubGFzdC5zZWNvbmQpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1JTlVURVwiLCB0aGlzLmxhc3QubWludXRlKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllIT1VSXCIsIHRoaXMubGFzdC5ob3VyKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllEQVlcIiwgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KGRvdykpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVdFRUtOT1wiLCB3ZWVrTm8pICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIREFZXCIsIHRoaXMubGFzdC5kYXkpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIXCIsIHRoaXMubGFzdC5tb250aCkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZWUVBUkRBWVwiLCBkb3kpKTtcbiAgICB9LFxuXG4gICAgc2V0dXBfZGVmYXVsdHM6IGZ1bmN0aW9uIHNldHVwX2RlZmF1bHRzKGFSdWxlVHlwZSwgcmVxLCBkZWZ0aW1lKSB7XG4gICAgICB2YXIgaW5kZXhNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICAgIHZhciBydWxlTWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG5cbiAgICAgIGlmIChydWxlTWFwVmFsdWUgIT0gaWNhbHJlY3VyX2l0ZXJhdG9yLkNPTlRSQUNUKSB7XG4gICAgICAgIGlmICghKGFSdWxlVHlwZSBpbiB0aGlzLmJ5X2RhdGEpKSB7XG4gICAgICAgICAgdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV0gPSBbZGVmdGltZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IHJlcSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZnRpbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgaXRlcmF0b3IgaW50byBhIHNlcmlhbGl6ZS1hYmxlIG9iamVjdC4gIFdpbGwgcHJlc2VydmUgY3VycmVudFxuICAgICAqIGl0ZXJhdGlvbiBzZXF1ZW5jZSB0byBlbnN1cmUgdGhlIHNlYW1sZXNzIGNvbnRpbnVhdGlvbiBvZiB0aGUgcmVjdXJyZW5jZVxuICAgICAqIHJ1bGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgcmVzdWx0LmluaXRpYWxpemVkID0gdGhpcy5pbml0aWFsaXplZDtcbiAgICAgIHJlc3VsdC5ydWxlID0gdGhpcy5ydWxlLnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmR0c3RhcnQgPSB0aGlzLmR0c3RhcnQudG9KU09OKCk7XG4gICAgICByZXN1bHQuYnlfZGF0YSA9IHRoaXMuYnlfZGF0YTtcbiAgICAgIHJlc3VsdC5kYXlzID0gdGhpcy5kYXlzO1xuICAgICAgcmVzdWx0Lmxhc3QgPSB0aGlzLmxhc3QudG9KU09OKCk7XG4gICAgICByZXN1bHQuYnlfaW5kaWNlcyA9IHRoaXMuYnlfaW5kaWNlcztcbiAgICAgIHJlc3VsdC5vY2N1cnJlbmNlX251bWJlciA9IHRoaXMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXAgPSB7XG4gICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgIFwiQllNSU5VVEVcIjogMSxcbiAgICBcIkJZSE9VUlwiOiAyLFxuICAgIFwiQllEQVlcIjogMyxcbiAgICBcIkJZTU9OVEhEQVlcIjogNCxcbiAgICBcIkJZWUVBUkRBWVwiOiA1LFxuICAgIFwiQllXRUVLTk9cIjogNixcbiAgICBcIkJZTU9OVEhcIjogNyxcbiAgICBcIkJZU0VUUE9TXCI6IDhcbiAgfTtcblxuICBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcCA9IHtcbiAgICBcIlNFQ09ORExZXCI6IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIk1JTlVURUxZXCI6IFsyLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIkhPVVJMWVwiOiBbMiwgMiwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJEQUlMWVwiOiBbMiwgMiwgMiwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJXRUVLTFlcIjogWzIsIDIsIDIsIDIsIDMsIDMsIDEsIDFdLFxuICAgIFwiTU9OVEhMWVwiOiBbMiwgMiwgMiwgMiwgMiwgMywgMywgMV0sXG4gICAgXCJZRUFSTFlcIjogWzIsIDIsIDIsIDIsIDIsIDIsIDIsIDJdXG4gIH07XG4gIGljYWxyZWN1cl9pdGVyYXRvci5VTktOT1dOID0gMDtcbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLkNPTlRSQUNUID0gMTtcbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLkVYUEFORCA9IDI7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5JTExFR0FMID0gMztcblxuICByZXR1cm4gaWNhbHJlY3VyX2l0ZXJhdG9yO1xuXG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuUmVjdXJFeHBhbnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWUoaXRlbSkge1xuICAgIHJldHVybiBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKGl0ZW0sIElDQUwuVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlVGltZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29tcGFyZShiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVjdXJyaW5nQ29tcG9uZW50KGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKSB8fFxuICAgICAgICAgICBjb21wLmhhc1Byb3BlcnR5KCdycnVsZScpIHx8XG4gICAgICAgICAgIGNvbXAuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFByaW1hcnkgY2xhc3MgZm9yIGV4cGFuZGluZyByZWN1cnJpbmcgcnVsZXMuICBDYW4gdGFrZSBtdWx0aXBsZSBycnVsZXMsXG4gICAqIHJkYXRlcywgZXhkYXRlKHMpIGFuZCBpdGVyYXRlIChpbiBvcmRlcikgb3ZlciBlYWNoIG5leHQgb2NjdXJyZW5jZS5cbiAgICpcbiAgICogT25jZSBpbml0aWFsaXplZCB0aGlzIGNsYXNzIGNhbiBhbHNvIGJlIHNlcmlhbGl6ZWQgc2F2ZWQgYW5kIGNvbnRpbnVlXG4gICAqIGl0ZXJhdGlvbiBmcm9tIHRoZSBsYXN0IHBvaW50LlxuICAgKlxuICAgKiBOT1RFOiBpdCBpcyBpbnRlbmRlZCB0aGF0IHRoaXMgY2xhc3MgaXMgdG8gYmUgdXNlZFxuICAgKiAgICAgICB3aXRoIElDQUwuRXZlbnQgd2hpY2ggaGFuZGxlcyByZWN1cnJlbmNlIGV4Y2VwdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGFzc3VtaW5nIGV2ZW50IGlzIGEgcGFyc2VkIGljYWwgY29tcG9uZW50XG4gICAqIHZhciBldmVudDtcbiAgICpcbiAgICogdmFyIGV4cGFuZCA9IG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKHtcbiAgICogICBjb21wb25lbnQ6IGV2ZW50LFxuICAgKiAgIGR0c3RhcnQ6IGV2ZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyByZW1lbWJlciB0aGVyZSBhcmUgaW5maW5pdGUgcnVsZXNcbiAgICogLy8gc28gaXQgaXMgYSBnb29kIGlkZWEgdG8gbGltaXQgdGhlIHNjb3BlXG4gICAqIC8vIG9mIHRoZSBpdGVyYXRpb25zIHRoZW4gcmVzdW1lIGxhdGVyIG9uLlxuICAgKlxuICAgKiAvLyBuZXh0IGlzIGFsd2F5cyBhbiBJQ0FMLlRpbWUgb3IgbnVsbFxuICAgKiB2YXIgbmV4dDtcbiAgICpcbiAgICogd2hpbGUgKHNvbWVDb25kaXRpb24gJiYgKG5leHQgPSBleHBhbmQubmV4dCgpKSkge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIG5leHRcbiAgICogfVxuICAgKlxuICAgKiAvLyBzYXZlIGluc3RhbmNlIGZvciBsYXRlclxuICAgKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGV4cGFuZCk7XG4gICAqXG4gICAqIC8vLi4uXG4gICAqXG4gICAqIC8vIE5PVEU6IGlmIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzIGhhdmVcbiAgICogLy8gICAgICAgY2hhbmdlZCB5b3Ugd2lsbCBuZWVkIHRvIHJlYnVpbGQgdGhlXG4gICAqIC8vICAgICAgIGNsYXNzIGFuZCBzdGFydCBvdmVyLiBUaGlzIG9ubHkgd29ya3NcbiAgICogLy8gICAgICAgd2hlbiB0aGUgY29tcG9uZW50J3MgcmVjdXJyZW5jZSBpbmZvIGlzIHRoZSBzYW1lLlxuICAgKiB2YXIgZXhwYW5kID0gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oSlNPTi5wYXJzZShqc29uKSk7XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGJlIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCB2YWx1ZXMuIEl0IGNhblxuICAgKiBhbHNvIGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzLCBhcyBhIHJlc3VsdCBvZiBzZXJpYWxpemluZyBhIHByZXZpb3VzXG4gICAqIGV4cGFuc2lvbiBzdGF0ZSwgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1ckV4cGFuc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgUmVjdXJyZW5jZSBleHBhbnNpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0XG4gICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICogICAgICAgIENvbXBvbmVudCBmb3IgZXhwYW5zaW9uLCByZXF1aXJlZCBpZiBub3QgcmVzdW1pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBSZWN1ckV4cGFuc2lvbihvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlRGF0ZXMgPSBbXTtcbiAgICB0aGlzLmV4RGF0ZXMgPSBbXTtcbiAgICB0aGlzLmZyb21EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgUmVjdXJFeHBhbnNpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiBpdGVyYXRpb24gaXMgZnVsbHkgY29tcGxldGVkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvbXBsZXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHJydWxlIGl0ZXJhdG9ycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlJlY3VySXRlcmF0b3JbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bGVJdGVyYXRvcnM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiByZGF0ZSBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlRGF0ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBleGRhdGUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gcnVsZURhdGVzIGFycmF5LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlRGF0ZUluYzogMCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gZXhEYXRlcyBhcnJheVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleERhdGVJbmM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IG5lZ2F0aXZlIGRhdGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBhZGRpdGlvbmFsIGRhdGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBkYXRlIG9mIHJlY3VycmluZyBydWxlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZHRzdGFydDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExhc3QgZXhwYW5kZWQgdGltZVxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBsYXN0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24gZnJvbSB0aGUgZGF0YSBvYmplY3QuIFRoZSBvcHRpb25zXG4gICAgICogb2JqZWN0IG1heSBhbHNvIGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzLCBzZWUgdGhlXG4gICAgICoge0BsaW5rIElDQUwuUmVjdXJFeHBhbnNpb24gY29uc3RydWN0b3J9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICBSZWN1cnJlbmNlIGV4cGFuc2lvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9wdGlvbnMuZHRzdGFydFxuICAgICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBvcHRpb25zLmNvbXBvbmVudFxuICAgICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc3RhcnQgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMuZHRzdGFydCwgSUNBTC5UaW1lKTtcblxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5kdHN0YXJ0IChJQ0FMLlRpbWUpIG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHRzdGFydCA9IHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zLmNvbXBvbmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3QgPSBmb3JtYXRUaW1lKG9wdGlvbnMubGFzdCkgfHwgc3RhcnQuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMucnVsZUl0ZXJhdG9ycykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignLnJ1bGVJdGVyYXRvcnMgb3IgLmNvbXBvbmVudCBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMgPSBvcHRpb25zLnJ1bGVJdGVyYXRvcnMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShpdGVtLCBJQ0FMLlJlY3VySXRlcmF0b3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gb3B0aW9ucy5ydWxlRGF0ZUluYztcbiAgICAgICAgdGhpcy5leERhdGVJbmMgPSBvcHRpb25zLmV4RGF0ZUluYztcblxuICAgICAgICBpZiAob3B0aW9ucy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlcyA9IG9wdGlvbnMucnVsZURhdGVzLm1hcChmb3JtYXRUaW1lKTtcbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5leERhdGVzKSB7XG4gICAgICAgICAgdGhpcy5leERhdGVzID0gb3B0aW9ucy5leERhdGVzLm1hcChmb3JtYXRUaW1lKTtcbiAgICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMuY29tcGxldGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBuZXh0IG9jY3VycmVuY2UgaW4gdGhlIHNlcmllcy5cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcjtcbiAgICAgIHZhciBydWxlT2ZEYXk7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIHZhciBjb21wYXJlO1xuXG4gICAgICB2YXIgbWF4VHJpZXMgPSA1MDA7XG4gICAgICB2YXIgY3VycmVudFRyeSA9IDA7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChjdXJyZW50VHJ5KysgPiBtYXhUcmllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdtYXggdHJpZXMgaGF2ZSBvY2N1cmVkLCBydWxlIG1heSBiZSBpbXBvc3NpYmxlIHRvIGZvcmZpbGwuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0ID0gdGhpcy5ydWxlRGF0ZTtcbiAgICAgICAgaXRlciA9IHRoaXMuX25leHRSZWN1cnJlbmNlSXRlcih0aGlzLmxhc3QpO1xuXG4gICAgICAgIC8vIG5vIG1vcmUgbWF0Y2hlc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGluY3JlbWVudCB0aGUgcnVsZSBkYXkgb3IgcnVsZVxuICAgICAgICAvLyBfYWZ0ZXJfIHdlIGNob29zZSBhIHZhbHVlIHRoaXMgc2hvdWxkIGJlXG4gICAgICAgIC8vIHRoZSBvbmx5IHNwb3Qgd2hlcmUgd2UgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIGV2ZW50cy5cbiAgICAgICAgaWYgKCFuZXh0ICYmICFpdGVyKSB7XG4gICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgaXRlcmF0b3JzIG9yIHJkYXRlc1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbmV4dCBydWxlIGRheSBvciByZWN1cnJlbmNlIHJ1bGUgaXMgZmlyc3QuXG4gICAgICAgIGlmICghbmV4dCB8fCAoaXRlciAmJiBuZXh0LmNvbXBhcmUoaXRlci5sYXN0KSA+IDApKSB7XG4gICAgICAgICAgLy8gbXVzdCBiZSBjbG9uZWQsIHJlY3VyIHdpbGwgcmV1c2UgdGhlIHRpbWUgZWxlbWVudC5cbiAgICAgICAgICBuZXh0ID0gaXRlci5sYXN0LmNsb25lKCk7XG4gICAgICAgICAgLy8gbW92ZSB0byBuZXh0IHNvIHdlIGNhbiBjb250aW51ZVxuICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJ1bGVEYXRlIGlzIHN0aWxsIG5leHQgaW5jcmVtZW50IGl0LlxuICAgICAgICBpZiAodGhpcy5ydWxlRGF0ZSA9PT0gbmV4dCkge1xuICAgICAgICAgIHRoaXMuX25leHRSdWxlRGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QgPSBuZXh0O1xuXG4gICAgICAgIC8vIGNoZWNrIHRoZSBuZWdhdGl2ZSBydWxlc1xuICAgICAgICBpZiAodGhpcy5leERhdGUpIHtcbiAgICAgICAgICBjb21wYXJlID0gdGhpcy5leERhdGUuY29tcGFyZSh0aGlzLmxhc3QpO1xuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0RXhEYXkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGV4Y2x1ZGVkIHNraXAgaXQuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRFeERheSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9YWFg6IFRoZSBzcGVjIHN0YXRlcyB0aGF0IGFmdGVyIHdlIHJlc29sdmUgdGhlIGZpbmFsXG4gICAgICAgIC8vICAgICBsaXN0IG9mIGRhdGVzIHdlIGV4ZWN1dGUgZXhkYXRlIHRoaXMgc2VlbXMgc29tZXdoYXQgY291bnRlclxuICAgICAgICAvLyAgICAgaW50dWl0aXZlIHRvIHdoYXQgSSBoYXZlIHNlZW4gbW9zdCBzZXJ2ZXJzIGRvIHNvIGZvciBub3dcbiAgICAgICAgLy8gICAgIEkgZXhjbHVkZSBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgZGF0ZSBub3QgdGhlIG9uZSB0aGF0IG1heVxuICAgICAgICAvLyAgICAgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5IHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3Q7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG9iamVjdCBpbnRvIGEgc2VyaWFsaXplLWFibGUgZm9ybWF0LiBUaGlzIGZvcm1hdCBjYW4gYmUgcGFzc2VkXG4gICAgICogYmFjayBpbnRvIHRoZSBleHBhbnNpb24gdG8gcmVzdW1lIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIHRvSlNPTihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlc3VsdC5ydWxlSXRlcmF0b3JzID0gdGhpcy5ydWxlSXRlcmF0b3JzLm1hcCh0b0pTT04pO1xuXG4gICAgICBpZiAodGhpcy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgcmVzdWx0LnJ1bGVEYXRlcyA9IHRoaXMucnVsZURhdGVzLm1hcCh0b0pTT04pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5leERhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5leERhdGVzID0gdGhpcy5leERhdGVzLm1hcCh0b0pTT04pO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucnVsZURhdGVJbmMgPSB0aGlzLnJ1bGVEYXRlSW5jO1xuICAgICAgcmVzdWx0LmV4RGF0ZUluYyA9IHRoaXMuZXhEYXRlSW5jO1xuICAgICAgcmVzdWx0Lmxhc3QgPSB0aGlzLmxhc3QudG9KU09OKCk7XG4gICAgICByZXN1bHQuZHRzdGFydCA9IHRoaXMuZHRzdGFydC50b0pTT04oKTtcbiAgICAgIHJlc3VsdC5jb21wbGV0ZSA9IHRoaXMuY29tcGxldGU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYWxsIGRhdGVzIGZyb20gdGhlIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIGNvbXBvbmVudC4gVGhlXG4gICAgICogcHJvcGVydGllcyB3aWxsIGJlIGZpbHRlcmVkIGJ5IHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgIFRoZSBjb21wb25lbnQgdG8gc2VhcmNoIGluXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSAgICAgICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lW119ICAgICAgICAgICAgICAgICAgICBUaGUgZXh0cmFjdGVkIGRhdGVzLlxuICAgICAqL1xuICAgIF9leHRyYWN0RGF0ZXM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVQcm9wKHByb3ApIHtcbiAgICAgICAgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG9yZGVyZWQgaW5zZXJ0XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHByb3BzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMocHJvcGVydHlOYW1lKTtcbiAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcHJvcDtcblxuICAgICAgdmFyIGlkeDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wc1tpXS5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZVByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGV4cGFuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgIFRoZSBjb21wb25lbnQgdG8gaW5pdGlhbGl6ZSBmcm9tLlxuICAgICAqL1xuICAgIF9pbml0OiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycyA9IFtdO1xuXG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcblxuICAgICAgLy8gdG8gcHJvdmlkZSBhcGkgY29uc2lzdGVuY3kgbm9uLXJlY3VycmluZ1xuICAgICAgLy8gZXZlbnRzIGNhbiBhbHNvIHVzZSB0aGUgaXRlcmF0b3IgdGhvdWdoIGl0IHdpbGxcbiAgICAgIC8vIG9ubHkgcmV0dXJuIGEgc2luZ2xlIHRpbWUuXG4gICAgICBpZiAoIWlzUmVjdXJyaW5nQ29tcG9uZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZGF0ZScpKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ3JkYXRlJyk7XG5cbiAgICAgICAgLy8gc3BlY2lhbCBoYWNrIGZvciBjYXNlcyB3aGVyZSBmaXJzdCByZGF0ZSBpcyBwcmlvclxuICAgICAgICAvLyB0byB0aGUgc3RhcnQgZGF0ZS4gV2Ugb25seSBjaGVjayBmb3IgdGhlIGZpcnN0IHJkYXRlLlxuICAgICAgICAvLyBUaGlzIGlzIG1vc3RseSBmb3IgZ29vZ2xlJ3MgY3JhenkgcmVjdXJyaW5nIGRhdGUgbG9naWNcbiAgICAgICAgLy8gKGNvbnRhY3RzIGJpcnRoZGF5cykuXG4gICAgICAgIGlmICgodGhpcy5ydWxlRGF0ZXNbMF0pICYmXG4gICAgICAgICAgICAodGhpcy5ydWxlRGF0ZXNbMF0uY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCkpIHtcblxuICAgICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSAwO1xuICAgICAgICAgIHRoaXMubGFzdCA9IHRoaXMucnVsZURhdGVzWzBdLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgICB0aGlzLnJ1bGVEYXRlcyxcbiAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgIGNvbXBhcmVUaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1t0aGlzLnJ1bGVEYXRlSW5jXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSkge1xuICAgICAgICB2YXIgcnVsZXMgPSBjb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygncnJ1bGUnKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBydWxlO1xuICAgICAgICB2YXIgaXRlcjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgICBpdGVyID0gcnVsZS5pdGVyYXRvcih0aGlzLmR0c3RhcnQpO1xuICAgICAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycy5wdXNoKGl0ZXIpO1xuXG4gICAgICAgICAgLy8gaW5jcmVtZW50IHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugc28gZnV0dXJlXG4gICAgICAgICAgLy8gY2FsbHMgdG8gbmV4dCByZXR1cm4gdGltZXMgYmV5b25kIHRoZSBpbml0aWFsIGl0ZXJhdGlvbi5cbiAgICAgICAgICAvLyBYWFg6IEkgZmluZCB0aGlzIHN1c3BpY2lvdXMgbWlnaHQgYmUgYSBidWc/XG4gICAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZXhkYXRlJykpIHtcbiAgICAgICAgdGhpcy5leERhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ2V4ZGF0ZScpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgLmxhc3QgZGF5IHdlIGluY3JlbWVudCB0aGUgaW5kZXggdG8gYmV5b25kIGl0LlxuICAgICAgICB0aGlzLmV4RGF0ZUluYyA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgdGhpcy5leERhdGVzLFxuICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzW3RoaXMuZXhEYXRlSW5jXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZSB0byB0aGUgbmV4dCBleGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9uZXh0RXhEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbKyt0aGlzLmV4RGF0ZUluY107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgcnVsZSBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dFJ1bGVEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzWysrdGhpcy5ydWxlRGF0ZUluY107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIHJldHVybiB0aGUgcmVjdXJyZW5jZSBydWxlIHdpdGggdGhlIG1vc3QgcmVjZW50IGV2ZW50IGFuZFxuICAgICAqIHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P0lDQUwuUmVjdXJJdGVyYXRvcn0gICAgRm91bmQgaXRlcmF0b3IuXG4gICAgICovXG4gICAgX25leHRSZWN1cnJlbmNlSXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcnMgPSB0aGlzLnJ1bGVJdGVyYXRvcnM7XG5cbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBpdGVycy5sZW5ndGg7XG4gICAgICB2YXIgaXRlcjtcbiAgICAgIHZhciBpdGVyVGltZTtcbiAgICAgIHZhciBpdGVySWR4ID0gMDtcbiAgICAgIHZhciBjaG9zZW5JdGVyO1xuXG4gICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBpdGVyYXRvclxuICAgICAgZm9yICg7IGl0ZXJJZHggPCBsZW47IGl0ZXJJZHgrKykge1xuICAgICAgICBpdGVyID0gaXRlcnNbaXRlcklkeF07XG4gICAgICAgIGl0ZXJUaW1lID0gaXRlci5sYXN0O1xuXG4gICAgICAgIC8vIGlmIGl0ZXJhdGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICAvLyB0aGVuIHdlIG11c3QgZXhjbHVkZSBpdCBmcm9tXG4gICAgICAgIC8vIHRoZSBzZWFyY2ggYW5kIHJlbW92ZSBpdC5cbiAgICAgICAgaWYgKGl0ZXIuY29tcGxldGVkKSB7XG4gICAgICAgICAgbGVuLS07XG4gICAgICAgICAgaWYgKGl0ZXJJZHggIT09IDApIHtcbiAgICAgICAgICAgIGl0ZXJJZHgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlcnMuc3BsaWNlKGl0ZXJJZHgsIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbW9zdCByZWNlbnQgcG9zc2libGUgY2hvaWNlXG4gICAgICAgIGlmICghY2hvc2VuSXRlciB8fCBjaG9zZW5JdGVyLmxhc3QuY29tcGFyZShpdGVyVGltZSkgPiAwKSB7XG4gICAgICAgICAgLy8gdGhhdCBpdGVyYXRvciBpcyBzYXZlZFxuICAgICAgICAgIGNob3Nlbkl0ZXIgPSBpdGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBjaG9zZW4gaXRlcmF0b3IgaXMgcmV0dXJuZWQgYnV0IG5vdCBtdXRhdGVkXG4gICAgICAvLyB0aGlzIGl0ZXJhdG9yIGNvbnRhaW5zIHRoZSBtb3N0IHJlY2VudCBldmVudC5cbiAgICAgIHJldHVybiBjaG9zZW5JdGVyO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVjdXJFeHBhbnNpb247XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogSUNBTC5qcyBpcyBvcmdhbml6ZWQgaW50byBtdWx0aXBsZSBsYXllcnMuIFRoZSBib3R0b20gbGF5ZXIgaXMgYSByYXcgakNhbFxuICAgKiBvYmplY3QsIGZvbGxvd2VkIGJ5IHRoZSBjb21wb25lbnQvcHJvcGVydHkgbGF5ZXIuIFRoZSBoaWdoZXN0IGxldmVsIGlzIHRoZVxuICAgKiBldmVudCByZXByZXNlbnRhdGlvbiwgd2hpY2ggdGhpcyBjbGFzcyBpcyBwYXJ0IG9mLiBTZWUgdGhlXG4gICAqIHtAdHV0b3JpYWwgbGF5ZXJzfSBndWlkZSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuRXZlbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IGNvbXBvbmVudCAgICAgICAgIFRoZSBJQ0FMLkNvbXBvbmVudCB0byBiYXNlIHRoaXMgZXZlbnQgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnNcbiAgICogICAgICAgICAgV2hlbiB0cnVlLCB3aWxsIHZlcmlmeSBleGNlcHRpb25zIGFyZSByZWxhdGVkIGJ5IHRoZWlyIFVVSURcbiAgICogQHBhcmFtIHtBcnJheTxJQ0FMLkNvbXBvbmVudHxJQ0FMLkV2ZW50Pn0gb3B0aW9ucy5leGNlcHRpb25zXG4gICAqICAgICAgICAgIEV4Y2VwdGlvbnMgdG8gdGhpcyBldmVudCwgZWl0aGVyIGFzIGNvbXBvbmVudHMgb3IgZXZlbnRzLiBJZiBub3RcbiAgICogICAgICAgICAgICBzcGVjaWZpZWQgZXhjZXB0aW9ucyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2V0IGluIHJlbGF0aW9uIG9mXG4gICAqICAgICAgICAgICAgY29tcG9uZW50J3MgcGFyZW50XG4gICAqL1xuICBmdW5jdGlvbiBFdmVudChjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wb25lbnQgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSBjb21wb25lbnQ7XG4gICAgICBjb21wb25lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudCgndmV2ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5leGNlcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zKSB7XG4gICAgICB0aGlzLnN0cmljdEV4Y2VwdGlvbnMgPSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leGNlcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbnMuZm9yRWFjaCh0aGlzLnJlbGF0ZUV4Y2VwdGlvbiwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudC5wYXJlbnQgJiYgIXRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnBhcmVudC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpKSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGVFeGNlcHRpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBFdmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICBUSElTQU5ERlVUVVJFOiAnVEhJU0FOREZVVFVSRScsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHJlbGF0ZWQgZXZlbnQgZXhjZXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLkV2ZW50W119XG4gICAgICovXG4gICAgZXhjZXB0aW9uczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlELlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RyaWN0RXhjZXB0aW9uczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGVzIGEgZ2l2ZW4gZXZlbnQgZXhjZXB0aW9uIHRvIHRoaXMgb2JqZWN0LiAgSWYgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgICAqIGRvZXMgbm90IHNoYXJlIHRoZSBVSUQgb2YgdGhpcyBldmVudCBpdCBjYW5ub3QgYmUgcmVsYXRlZCBhbmQgd2lsbCB0aHJvd1xuICAgICAqIGFuIGV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgY29tcG9uZW50IGlzIGFuIGV4Y2VwdGlvbiBpdCBjYW5ub3QgaGF2ZSBvdGhlciBleGNlcHRpb25zXG4gICAgICogcmVsYXRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8SUNBTC5FdmVudH0gb2JqICAgICAgIENvbXBvbmVudCBvciBldmVudFxuICAgICAqL1xuICAgIHJlbGF0ZUV4Y2VwdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAodGhpcy5pc1JlY3VycmVuY2VFeGNlcHRpb24oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWxhdGUgZXhjZXB0aW9uIHRvIGV4Y2VwdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIG9iaiA9IG5ldyBJQ0FMLkV2ZW50KG9iaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0cmljdEV4Y2VwdGlvbnMgJiYgb2JqLnVpZCAhPT0gdGhpcy51aWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gcmVsYXRlIHVucmVsYXRlZCBleGNlcHRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gb2JqLnJlY3VycmVuY2VJZC50b1N0cmluZygpO1xuXG4gICAgICAvLyB3ZSBkb24ndCBzb3J0IG9yIG1hbmFnZSBleGNlcHRpb25zIGRpcmVjdGx5XG4gICAgICAvLyBoZXJlIHRoZSByZWN1cnJlbmNlIGV4cGFuZGVyIGhhbmRsZXMgdGhhdC5cbiAgICAgIHRoaXMuZXhjZXB0aW9uc1tpZF0gPSBvYmo7XG5cbiAgICAgIC8vIGluZGV4IFJBTkdFPVRISVNBTkRGVVRVUkUgZXhjZXB0aW9ucyBzbyB3ZSBjYW5cbiAgICAgIC8vIGxvb2sgdGhlbSB1cCBsYXRlciBpbiBnZXRPY2N1cnJlbmNlRGV0YWlscy5cbiAgICAgIGlmIChvYmoubW9kaWZpZXNGdXR1cmUoKSkge1xuICAgICAgICB2YXIgaXRlbSA9IFtcbiAgICAgICAgICBvYmoucmVjdXJyZW5jZUlkLnRvVW5peFRpbWUoKSwgaWRcbiAgICAgICAgXTtcblxuICAgICAgICAvLyB3ZSBrZWVwIHRoZW0gc29ydGVkIHNvIHdlIGNhbiBmaW5kIHRoZSBuZWFyZXN0XG4gICAgICAgIC8vIHZhbHVlIGxhdGVyIG9uLi4uXG4gICAgICAgIHZhciBpZHggPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMuc3BsaWNlKGlkeCwgMCwgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHJlY29yZCBpcyBhbiBleGNlcHRpb24gYW5kIGhhcyB0aGUgUkFOR0U9VEhJU0FOREZVVFVSRVxuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gZXhjZXB0aW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAqL1xuICAgIG1vZGlmaWVzRnV0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKS5nZXRQYXJhbWV0ZXIoJ3JhbmdlJyk7XG4gICAgICByZXR1cm4gcmFuZ2UgPT09IHRoaXMuVEhJU0FOREZVVFVSRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHJhbmdlIGV4Y2VwdGlvbiBuZWFyZXN0IHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHRpbWUgdXN1YWxseSBhbiBvY2N1cnJlbmNlIHRpbWUgb2YgYW4gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5FdmVudH0gdGhlIHJlbGF0ZWQgZXZlbnQvZXhjZXB0aW9uIG9yIG51bGxcbiAgICAgKi9cbiAgICBmaW5kUmFuZ2VFeGNlcHRpb246IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgIGlmICghdGhpcy5yYW5nZUV4Y2VwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXRjID0gdGltZS50b1VuaXhUaW1lKCk7XG4gICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMsXG4gICAgICAgIFt1dGNdLFxuICAgICAgICBjb21wYXJlUmFuZ2VFeGNlcHRpb25cbiAgICAgICk7XG5cbiAgICAgIGlkeCAtPSAxO1xuXG4gICAgICAvLyBvY2N1cnMgYmVmb3JlXG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlSXRlbSA9IHRoaXMucmFuZ2VFeGNlcHRpb25zW2lkeF07XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgb25seSAqL1xuICAgICAgaWYgKHV0YyA8IHJhbmdlSXRlbVswXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlSXRlbVsxXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgaXMgcmV0dXJuZWQgYnkge0BsaW5rIElDQUwuRXZlbnQjZ2V0T2NjdXJyZW5jZURldGFpbHMgZ2V0T2NjdXJyZW5jZURldGFpbHN9XG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBvY2N1cnJlbmNlRGV0YWlsc1xuICAgICAqIEBtZW1iZXJvZiBJQ0FMLkV2ZW50XG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IHJlY3VycmVuY2VJZCAgICAgICBUaGUgcGFzc2VkIGluIHJlY3VycmVuY2UgaWRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuRXZlbnR9IGl0ZW0gICAgICAgICAgICAgIFRoZSBvY2N1cnJlbmNlXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IHN0YXJ0RGF0ZSAgICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIG9jY3VycmVuY2VcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuVGltZX0gZW5kRGF0ZSAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIG9jY3VycmVuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9jY3VycmVuY2UgZGV0YWlscyBiYXNlZCBvbiBpdHMgc3RhcnQgdGltZS4gIElmIHRoZVxuICAgICAqIG9jY3VycmVuY2UgaGFzIGFuIGV4Y2VwdGlvbiB3aWxsIHJldHVybiB0aGUgZGV0YWlscyBmb3IgdGhhdCBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBpcyBpbnRlbmQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvblxuICAgICAqICAgICAgIHdpdGggdGhlIHtAbGluayBJQ0FMLkV2ZW50I2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb2NjdXJyZW5jZSB0aW1lIG9jY3VycmVuY2VcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkV2ZW50Lm9jY3VycmVuY2VEZXRhaWxzfSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2NjdXJyZW5jZVxuICAgICAqL1xuICAgIGdldE9jY3VycmVuY2VEZXRhaWxzOiBmdW5jdGlvbihvY2N1cnJlbmNlKSB7XG4gICAgICB2YXIgaWQgPSBvY2N1cnJlbmNlLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgdXRjSWQgPSBvY2N1cnJlbmNlLmNvbnZlcnRUb1pvbmUoSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkudG9TdHJpbmcoKTtcbiAgICAgIHZhciBpdGVtO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgLy9YWFg6IENsb25lP1xuICAgICAgICByZWN1cnJlbmNlSWQ6IG9jY3VycmVuY2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChpZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgICAgaXRlbSA9IHJlc3VsdC5pdGVtID0gdGhpcy5leGNlcHRpb25zW2lkXTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0RGF0ZSA9IGl0ZW0uc3RhcnREYXRlO1xuICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGl0ZW0uZW5kRGF0ZTtcbiAgICAgICAgcmVzdWx0Lml0ZW0gPSBpdGVtO1xuICAgICAgfSBlbHNlIGlmICh1dGNJZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1t1dGNJZF07XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBpdGVtLmVuZERhdGU7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJhbmdlIGV4Y2VwdGlvbnMgKFJBTkdFPVRISVNBTkRGVVRVUkUpIGhhdmUgYVxuICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0aGVuIGRpcmVjdCBleGNlcHRpb25zIGJ1dFxuICAgICAgICAvLyBtdXN0IGJlIGFjY291bnRlZCBmb3IgZmlyc3QuIFRoZWlyIGl0ZW0gaXNcbiAgICAgICAgLy8gYWx3YXlzIHRoZSBmaXJzdCBleGNlcHRpb24gd2l0aCB0aGUgcmFuZ2UgcHJvcC5cbiAgICAgICAgdmFyIHJhbmdlRXhjZXB0aW9uSWQgPSB0aGlzLmZpbmRSYW5nZUV4Y2VwdGlvbihcbiAgICAgICAgICBvY2N1cnJlbmNlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbmQ7XG5cbiAgICAgICAgaWYgKHJhbmdlRXhjZXB0aW9uSWQpIHtcbiAgICAgICAgICB2YXIgZXhjZXB0aW9uID0gdGhpcy5leGNlcHRpb25zW3JhbmdlRXhjZXB0aW9uSWRdO1xuXG4gICAgICAgICAgLy8gcmFuZ2UgZXhjZXB0aW9uIG11c3QgbW9kaWZ5IHN0YW5kYXJkIHRpbWVcbiAgICAgICAgICAvLyBieSB0aGUgZGlmZmVyZW5jZSAoaWYgYW55KSBpbiBzdGFydC9lbmQgdGltZXMuXG4gICAgICAgICAgcmVzdWx0Lml0ZW0gPSBleGNlcHRpb247XG5cbiAgICAgICAgICB2YXIgc3RhcnREaWZmID0gdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAgIGlmICghc3RhcnREaWZmKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBleGNlcHRpb24ucmVjdXJyZW5jZUlkLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSBleGNlcHRpb24uc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIC8vIHpvbmVzIG11c3QgYmUgc2FtZSBvdGhlcndpc2Ugc3VidHJhY3QgbWF5IGJlIGluY29ycmVjdC5cbiAgICAgICAgICAgIG9yaWdpbmFsLnpvbmUgPSBuZXdTdGFydC56b25lO1xuICAgICAgICAgICAgc3RhcnREaWZmID0gbmV3U3RhcnQuc3VidHJhY3REYXRlKG9yaWdpbmFsKTtcblxuICAgICAgICAgICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXSA9IHN0YXJ0RGlmZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvY2N1cnJlbmNlLmNsb25lKCk7XG4gICAgICAgICAgc3RhcnQuem9uZSA9IGV4Y2VwdGlvbi5zdGFydERhdGUuem9uZTtcbiAgICAgICAgICBzdGFydC5hZGREdXJhdGlvbihzdGFydERpZmYpO1xuXG4gICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICBlbmQuYWRkRHVyYXRpb24oZXhjZXB0aW9uLmR1cmF0aW9uKTtcblxuICAgICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBzdGFydDtcbiAgICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyByYW5nZSBleGNlcHRpb24gc3RhbmRhcmQgZXhwYW5zaW9uXG4gICAgICAgICAgZW5kID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcblxuICAgICAgICAgIHJlc3VsdC5lbmREYXRlID0gZW5kO1xuICAgICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBvY2N1cnJlbmNlO1xuICAgICAgICAgIHJlc3VsdC5pdGVtID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSByZWN1ciBleHBhbnNpb24gaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZSAoZGVmYXVsdHNcbiAgICAgKiB0byBzdGFydERhdGUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHN0YXJ0VGltZSAgICAgU3RhcnRpbmcgcG9pbnQgZm9yIGV4cGFuc2lvblxuICAgICAqIEByZXR1cm4ge0lDQUwuUmVjdXJFeHBhbnNpb259ICAgIEV4cGFuc2lvbiBvYmplY3RcbiAgICAgKi9cbiAgICBpdGVyYXRvcjogZnVuY3Rpb24oc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oe1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29tcG9uZW50LFxuICAgICAgICBkdHN0YXJ0OiBzdGFydFRpbWUgfHwgdGhpcy5zdGFydERhdGVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgICAqL1xuICAgIGlzUmVjdXJyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICByZXR1cm4gY29tcC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSB8fCBjb21wLmhhc1Byb3BlcnR5KCdyZGF0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGRlc2NyaWJlcyBhIHJlY3VycmVuY2UgZXhjZXB0aW9uLiBTZWVcbiAgICAgKiB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUsIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvblxuICAgICAqL1xuICAgIGlzUmVjdXJyZW5jZUV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZXMgb2YgcmVjdXJyZW5jZXMgdGhpcyBldmVudCBtYXkgaGF2ZS5cbiAgICAgKlxuICAgICAqIFJldHVybmVkIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcG9zc2libGUga2V5czpcbiAgICAgKlxuICAgICAqICAgIC0gWUVBUkxZXG4gICAgICogICAgLSBNT05USExZXG4gICAgICogICAgLSBXRUVLTFlcbiAgICAgKiAgICAtIERBSUxZXG4gICAgICogICAgLSBNSU5VVEVMWVxuICAgICAqICAgIC0gU0VDT05ETFlcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdC48SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXMsIEJvb2xlYW4+fVxuICAgICAqICAgICAgICAgIE9iamVjdCBvZiByZWN1cnJlbmNlIGZsYWdzXG4gICAgICovXG4gICAgZ2V0UmVjdXJyZW5jZVR5cGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydWxlcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ3JydWxlJyk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcnVsZXNbaV0uZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICByZXN1bHRbdmFsdWUuZnJlcV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdWlkIG9mIHRoaXMgZXZlbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1aWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCd1aWQnKTtcbiAgICB9LFxuXG4gICAgc2V0IHVpZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgndWlkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgZGF0ZVxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2R0c3RhcnQnKTtcbiAgICB9LFxuXG4gICAgc2V0IHN0YXJ0RGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0VGltZSgnZHRzdGFydCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVuZCBkYXRlLiBUaGlzIGNhbiBiZSB0aGUgcmVzdWx0IGRpcmVjdGx5IGZyb20gdGhlIHByb3BlcnR5LCBvciB0aGVcbiAgICAgKiBlbmQgZGF0ZSBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZHVyYXRpb24uIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAgICogd2lsbCByZW1vdmUgYW55IGR1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBnZXQgZW5kRGF0ZSgpIHtcbiAgICAgIHZhciBlbmREYXRlID0gdGhpcy5fZmlyc3RQcm9wKCdkdGVuZCcpO1xuICAgICAgaWYgKCFlbmREYXRlKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fZmlyc3RQcm9wKCdkdXJhdGlvbicpO1xuICAgICAgICAgIGVuZERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZERhdGUuaXNEYXRlKSB7XG4gICAgICAgICAgICAgIGVuZERhdGUuZGF5ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZERhdGU7XG4gICAgfSxcblxuICAgIHNldCBlbmREYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRUaW1lKCdkdGVuZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uLiBUaGlzIGNhbiBiZSB0aGUgcmVzdWx0IGRpcmVjdGx5IGZyb20gdGhlIHByb3BlcnR5LCBvciB0aGVcbiAgICAgKiBkdXJhdGlvbiBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZW5kIGRhdGUuIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAgICogd2lsbCByZW1vdmUgYW55IGBkdGVuZGAgcHJvcGVydGllcy5cbiAgICAgKiBAdHlwZSB7SUNBTC5EdXJhdGlvbn1cbiAgICAgKi9cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9maXJzdFByb3AoJ2R1cmF0aW9uJyk7XG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZERhdGUuc3VidHJhY3REYXRlVHoodGhpcy5zdGFydERhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICBzZXQgZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZHRlbmQnKSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZW1vdmVQcm9wZXJ0eSgnZHRlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UHJvcCgnZHVyYXRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdsb2NhdGlvbicpO1xuICAgIH0sXG5cbiAgICBzZXQgbG9jYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRQcm9wKCdsb2NhdGlvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dGVuZGVlcyBpbiB0aGUgZXZlbnRcbiAgICAgKiBAdHlwZSB7SUNBTC5Qcm9wZXJ0eVtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBhdHRlbmRlZXMoKSB7XG4gICAgICAvL1hYWDogVGhpcyBpcyB3YXkgbGFtZSB3ZSBzaG91bGQgaGF2ZSBhIGJldHRlclxuICAgICAgLy8gICAgIGRhdGEgc3RydWN0dXJlIGZvciB0aGlzIGxhdGVyLlxuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ2F0dGVuZGVlJyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHN1bW1hcnlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzdW1tYXJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc3VtbWFyeScpO1xuICAgIH0sXG5cbiAgICBzZXQgc3VtbWFyeSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnc3VtbWFyeScsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGRlc2NyaXB0aW9uLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnZGVzY3JpcHRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0IGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdkZXNjcmlwdGlvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGNvbG9yIGZyb20gW3JmYzc5ODZdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzk4NilcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2NvbG9yJyk7XG4gICAgfSxcblxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnY29sb3InLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmdhbml6ZXIgdmFsdWUgYXMgYW4gdXJpLiBJbiBtb3N0IGNhc2VzIHRoaXMgaXMgYSBtYWlsdG86IHVyaSwgYnV0XG4gICAgICogaXQgY2FuIGFsc28gYmUgc29tZXRoaW5nIGVsc2UsIGxpa2UgdXJuOnV1aWQ6Li4uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgb3JnYW5pemVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnb3JnYW5pemVyJyk7XG4gICAgfSxcblxuICAgIHNldCBvcmdhbml6ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ29yZ2FuaXplcicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIHZhbHVlIGZvciB0aGlzIGV2ZW50LiBVc2VkIGZvciBzY2hlZHVsaW5nXG4gICAgICogc2VlIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlcXVlbmNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc2VxdWVuY2UnKTtcbiAgICB9LFxuXG4gICAgc2V0IHNlcXVlbmNlKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdzZXF1ZW5jZScsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlY3VycmVuY2UgaWQgZm9yIHRoaXMgZXZlbnQuIFNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGdldCByZWN1cnJlbmNlSWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdyZWN1cnJlbmNlLWlkJyk7XG4gICAgfSxcblxuICAgIHNldCByZWN1cnJlbmNlSWQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFRpbWUoJ3JlY3VycmVuY2UtaWQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldC91cGRhdGUgYSB0aW1lIHByb3BlcnR5J3MgdmFsdWUuXG4gICAgICogVGhpcyB3aWxsIGFsc28gdXBkYXRlIHRoZSBUWklEIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRPRE86IHRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIHN3aXRjaGluZ1xuICAgICAqIGZyb20gYSBrbm93biB0aW1lem9uZSB0byBhbiBpbXBsaWVkIHRpbWV6b25lIChvbmUgd2l0aG91dCBUWklEKS5cbiAgICAgKiBUaGlzIGRvZXMgX25vdF8gaGFuZGxlIHRoZSBjYXNlIG9mIG1vdmluZyBiZXR3ZWVuIGEga25vd25cbiAgICAgKiAgKGJ5IFRpbWV6b25lU2VydmljZSkgdGltZXpvbmUgdG8gYW4gdW5rbm93biB0aW1lem9uZS4uLlxuICAgICAqXG4gICAgICogV2Ugd2lsbCBub3QgYWRkL3JlbW92ZS91cGRhdGUgdGhlIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzXG4gICAgICogIGxlYWRpbmcgdG8gaW52YWxpZCBJQ0FMIGRhdGEuLi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSAgICAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gdGltZSAgICAgIFRoZSB0aW1lIHRvIHNldFxuICAgICAqL1xuICAgIF9zZXRUaW1lOiBmdW5jdGlvbihwcm9wTmFtZSwgdGltZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KHByb3BOYW1lKTtcblxuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmFkZFByb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICAvLyB1dGMgYW5kIGxvY2FsIGRvbid0IGdldCBhIHR6aWRcbiAgICAgIGlmIChcbiAgICAgICAgdGltZS56b25lID09PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgdGltZS56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0emlkXG4gICAgICAgIHByb3AucmVtb3ZlUGFyYW1ldGVyKCd0emlkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnNldFBhcmFtZXRlcigndHppZCcsIHRpbWUuem9uZS50emlkKTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5zZXRWYWx1ZSh0aW1lKTtcbiAgICB9LFxuXG4gICAgX3NldFByb3A6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIF9maXJzdFByb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGFyZVJhbmdlRXhjZXB0aW9uKGEsIGIpIHtcbiAgICBpZiAoYVswXSA+IGJbMF0pIHJldHVybiAxO1xuICAgIGlmIChiWzBdID4gYVswXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIEV2ZW50O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkNvbXBvbmVudFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhlIENvbXBvbmVudFBhcnNlciBpcyB1c2VkIHRvIHByb2Nlc3MgYSBTdHJpbmcgb3IgakNhbCBPYmplY3QsXG4gICAqIGZpcmluZyBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZm91bmQgY29tcG9uZW50cywgYXMgd2VsbCBhcyBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICogICAvLyB3aGVuIGZhbHNlIG5vIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgZm9yIHR5cGVcbiAgICogICBwYXJzZUV2ZW50OiB0cnVlLFxuICAgKiAgIHBhcnNlVGltZXpvbmU6IHRydWVcbiAgICogfTtcbiAgICpcbiAgICogdmFyIHBhcnNlciA9IG5ldyBJQ0FMLkNvbXBvbmVudFBhcnNlcihvcHRpb25zKTtcbiAgICpcbiAgICogcGFyc2VyLm9uZXZlbnQoZXZlbnRDb21wb25lbnQpIHtcbiAgICogICAvLy4uLlxuICAgKiB9XG4gICAqXG4gICAqIC8vIG9udGltZXpvbmUsIGV0Yy4uLlxuICAgKlxuICAgKiBwYXJzZXIub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgKlxuICAgKiB9O1xuICAgKlxuICAgKiBwYXJzZXIucHJvY2VzcyhzdHJpbmdPckNvbXBvbmVudCk7XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5Db21wb25lbnRQYXJzZXJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICAgICAgICBDb21wb25lbnQgcGFyc2VyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlRXZlbnQgICAgICAgIFdoZXRoZXIgZXZlbnRzIHNob3VsZCBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlVGltZXplb25lICAgIFdoZXRoZXIgdGltZXpvbmVzIHNob3VsZCBiZSBwYXJzZWRcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudFBhcnNlcihvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBDb21wb25lbnRQYXJzZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBwYXJzZSBldmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHBhcnNlRXZlbnQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHBhcnNlIHRpbWV6b25lc1xuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VUaW1lem9uZTogdHJ1ZSxcblxuXG4gICAgLyogU0FYIGxpa2UgZXZlbnRzIGhlcmUgZm9yIHJlZmVyZW5jZSAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBwYXJzaW5nIGlzIGNvbXBsZXRlXG4gICAgICogQGNhbGxiYWNrXG4gICAgICovXG4gICAgb25jb21wbGV0ZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgcGFyc2luZy5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBkZXRhaWxzIG9mIGVycm9yXG4gICAgICovXG4gICAgb25lcnJvcjogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oZXJyKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWVElNRVpPTkUpIGlzIGZvdW5kXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IGNvbXBvbmVudCAgICAgVGltZXpvbmUgb2JqZWN0XG4gICAgICovXG4gICAgb250aW1lem9uZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oY29tcG9uZW50KSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWRVZFTlQpIGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogQGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtJQ0FMLkV2ZW50fSBjb21wb25lbnQgICAgVG9wIGxldmVsIGNvbXBvbmVudFxuICAgICAqL1xuICAgIG9uZXZlbnQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgc3RyaW5nIG9yIHBhcnNlIGljYWwgb2JqZWN0LiAgVGhpcyBmdW5jdGlvbiBpdHNlbGYgd2lsbCByZXR1cm5cbiAgICAgKiBub3RoaW5nIGJ1dCB3aWxsIHN0YXJ0IHRoZSBwYXJzaW5nIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBFdmVudHMgbXVzdCBiZSByZWdpc3RlcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fFN0cmluZ3xPYmplY3R9IGljYWwgICAgICBUaGUgY29tcG9uZW50IHRvIHByb2Nlc3MsXG4gICAgICogICAgICAgIGVpdGhlciBpbiBpdHMgZmluYWwgZm9ybSwgYXMgYSBqQ2FsIE9iamVjdCwgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaWNhbCkge1xuICAgICAgLy9UT0RPOiB0aGlzIGlzIHN5bmMgbm93IGluIHRoZSBmdXR1cmUgd2Ugd2lsbCBoYXZlIGEgaW5jcmVtZW50YWwgcGFyc2VyLlxuICAgICAgaWYgKHR5cGVvZihpY2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWNhbCA9IElDQUwucGFyc2UoaWNhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGljYWwgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkpIHtcbiAgICAgICAgaWNhbCA9IG5ldyBJQ0FMLkNvbXBvbmVudChpY2FsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudHMgPSBpY2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAndnRpbWV6b25lJzpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIHR6aWQgPSBjb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAgICAgICAgICAgIGlmICh0emlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbnRpbWV6b25lKG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAgICAgICAgICAgICAgICAgIHR6aWQ6IHR6aWQsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmV2ZW50JzpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KG5ldyBJQ0FMLkV2ZW50KGNvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vWFhYOiBpZGVhbGx5IHdlIHNob3VsZCBkbyBhIFwibmV4dFRpY2tcIiBoZXJlXG4gICAgICAvLyAgICAgc28gaW4gYWxsIGNhc2VzIHRoaXMgaXMgYWN0dWFsbHkgYXN5bmMuXG4gICAgICB0aGlzLm9uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudFBhcnNlcjtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ical.js/build/ical.js\n");

/***/ })

};
;