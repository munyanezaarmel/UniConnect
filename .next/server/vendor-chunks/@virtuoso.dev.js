"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@virtuoso.dev";
exports.ids = ["vendor-chunks/@virtuoso.dev"];
exports.modules = {

/***/ "(ssr)/./node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   systemToComponent: () => (/* binding */ systemToComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @virtuoso.dev/urx */ \"(ssr)/./node_modules/@virtuoso.dev/urx/dist/urx.esm.js\");\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar _excluded = [\"children\"];\n/** @internal */\n\nfunction omit(keys, obj) {\n  var result = {};\n  var index = {};\n  var idx = 0;\n  var len = keys.length;\n\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n\n  for (var prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n\n  return result;\n}\n\nvar useIsomorphicLayoutEffect = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\r\n * Converts a system spec to React component by mapping the system streams to component properties, events and methods. Returns hooks for querying and modifying\r\n * the system streams from the component's child components.\r\n * @param systemSpec The return value from a [[system]] call.\r\n * @param map The streams to props / events / methods mapping Check [[SystemPropsMap]] for more details.\r\n * @param Root The optional React component to render. By default, the resulting component renders nothing, acting as a logical wrapper for its children.\r\n * @returns an object containing the following:\r\n *  - `Component`: the React component.\r\n *  - `useEmitterValue`: a hook that lets child components use values emitted from the specified output stream.\r\n *  - `useEmitter`: a hook that calls the provided callback whenever the specified stream emits a value.\r\n *  - `usePublisher`: a hook which lets child components publish values to the specified stream.\r\n *  <hr />\r\n */\n\nfunction systemToComponent(systemSpec, map, Root) {\n  var requiredPropNames = Object.keys(map.required || {});\n  var optionalPropNames = Object.keys(map.optional || {});\n  var methodNames = Object.keys(map.methods || {});\n  var eventNames = Object.keys(map.events || {});\n  var Context = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n\n  function applyPropsToSystem(system, props) {\n    if (system['propsReady']) {\n      (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(system['propsReady'], false);\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(requiredPropNames), _step; !(_step = _iterator()).done;) {\n      var requiredPropName = _step.value;\n      var stream = system[map.required[requiredPropName]];\n      (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(stream, props[requiredPropName]);\n    }\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(optionalPropNames), _step2; !(_step2 = _iterator2()).done;) {\n      var optionalPropName = _step2.value;\n\n      if (optionalPropName in props) {\n        var _stream = system[map.optional[optionalPropName]];\n        (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(_stream, props[optionalPropName]);\n      }\n    }\n\n    if (system['propsReady']) {\n      (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(system['propsReady'], true);\n    }\n  }\n\n  function buildMethods(system) {\n    return methodNames.reduce(function (acc, methodName) {\n\n      acc[methodName] = function (value) {\n        var stream = system[map.methods[methodName]];\n        (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(stream, value);\n      };\n\n      return acc;\n    }, {});\n  }\n\n  function buildEventHandlers(system) {\n    return eventNames.reduce(function (handlers, eventName) {\n      handlers[eventName] = (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.eventHandler)(system[map.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  /**\r\n   * A React component generated from an urx system\r\n   */\n\n\n  var Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (propsWithChildren, ref) {\n    var children = propsWithChildren.children,\n        props = _objectWithoutPropertiesLoose(propsWithChildren, _excluded);\n\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n      return (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.tap)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.init)(systemSpec), function (system) {\n        return applyPropsToSystem(system, props);\n      });\n    }),\n        system = _useState[0];\n\n    var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.curry1to0)(buildEventHandlers, system)),\n        handlers = _useState2[0];\n\n    useIsomorphicLayoutEffect(function () {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(eventNames), _step3; !(_step3 = _iterator3()).done;) {\n        var eventName = _step3.value;\n\n        if (eventName in props) {\n          (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.subscribe)(handlers[eventName], props[eventName]);\n        }\n      }\n\n      return function () {\n        Object.values(handlers).map(_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.reset);\n      };\n    }, [props, handlers, system]);\n    useIsomorphicLayoutEffect(function () {\n      applyPropsToSystem(system, props);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.always)(buildMethods(system)));\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Context.Provider, {\n      value: system\n    }, Root ? (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Root, omit([].concat(requiredPropNames, optionalPropNames, eventNames), props), children) : children);\n  });\n\n  var usePublisher = function usePublisher(key) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.curry2to1)(_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context)[key]), [key]);\n  };\n  /**\r\n   * Returns the value emitted from the stream.\r\n   */\n\n\n  var useEmitterValue = function useEmitterValue(key) {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    var source = context[key];\n\n    var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.curry1to0)(_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.getValue, source)),\n        value = _useState3[0],\n        setValue = _useState3[1];\n\n    useIsomorphicLayoutEffect(function () {\n      return (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.subscribe)(source, function (next) {\n        if (next !== value) {\n          setValue((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.always)(next));\n        }\n      });\n    }, [source, value]);\n    return value;\n  };\n\n  var useEmitter = function useEmitter(key, callback) {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    var source = context[key];\n    useIsomorphicLayoutEffect(function () {\n      return (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.subscribe)(source, callback);\n    }, [callback, source]);\n  };\n\n  return {\n    Component: Component,\n    usePublisher: usePublisher,\n    useEmitterValue: useEmitterValue,\n    useEmitter: useEmitter\n  };\n}\n\n\n//# sourceMappingURL=react-urx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi9yZWFjdC11cngvZGlzdC9yZWFjdC11cnguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUo7QUFDdEI7O0FBRS9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrRUFBa0Usa0RBQWUsR0FBRyw0Q0FBUztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsaURBQWlEO0FBQ2pELCtDQUErQztBQUMvQyxnQkFBZ0Isb0RBQWEsR0FBRzs7QUFFaEM7QUFDQTtBQUNBLE1BQU0sMERBQU87QUFDYjs7QUFFQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQSxNQUFNLDBEQUFPO0FBQ2I7O0FBRUEsc0ZBQXNGLDhCQUE4QjtBQUNwSDs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwwREFBTztBQUNmO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDBEQUFPO0FBQ2Y7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFZO0FBQ3hDO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGtCQUFrQixpREFBVTtBQUM1QjtBQUNBOztBQUVBLG9CQUFvQiwrQ0FBUTtBQUM1QixhQUFhLHNEQUFHLENBQUMsdURBQUk7QUFDckI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBLHFCQUFxQiwrQ0FBUSxDQUFDLDREQUFTO0FBQ3ZDOztBQUVBO0FBQ0EsaUZBQWlGLDhCQUE4QjtBQUMvRzs7QUFFQTtBQUNBLFVBQVUsNERBQVM7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxvREFBSztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksMERBQW1CLE1BQU0seURBQU07QUFDbkMsV0FBVyxvREFBYTtBQUN4QjtBQUNBLEtBQUssU0FBUyxvREFBYTtBQUMzQixHQUFHOztBQUVIO0FBQ0EsV0FBVyxrREFBVyxDQUFDLDREQUFTLENBQUMsc0RBQU8sRUFBRSxpREFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxrQkFBa0IsaURBQVU7QUFDNUI7O0FBRUEscUJBQXFCLCtDQUFRLENBQUMsNERBQVMsQ0FBQyx1REFBUTtBQUNoRDtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0REFBUztBQUN0QjtBQUNBLG1CQUFtQix5REFBTTtBQUN6QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QjtBQUNBO0FBQ0EsYUFBYSw0REFBUztBQUN0QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLTE1LXNvY2lhbC1tZWRpYS1hcHAvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi9yZWFjdC11cngvZGlzdC9yZWFjdC11cnguZXNtLmpzP2Q3N2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGNyZWF0ZUVsZW1lbnQsIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRhcCwgaW5pdCwgY3VycnkxdG8wLCBzdWJzY3JpYmUsIHJlc2V0LCBhbHdheXMsIHB1Ymxpc2gsIGV2ZW50SGFuZGxlciwgY3VycnkydG8xLCBnZXRWYWx1ZSB9IGZyb20gJ0B2aXJ0dW9zby5kZXYvdXJ4JztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCJdO1xuLyoqIEBpbnRlcm5hbCAqL1xuXG5mdW5jdGlvbiBvbWl0KGtleXMsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpbmRleCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpbmRleFtrZXlzW2lkeF1dID0gMTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKCFpbmRleC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHN5c3RlbSBzcGVjIHRvIFJlYWN0IGNvbXBvbmVudCBieSBtYXBwaW5nIHRoZSBzeXN0ZW0gc3RyZWFtcyB0byBjb21wb25lbnQgcHJvcGVydGllcywgZXZlbnRzIGFuZCBtZXRob2RzLiBSZXR1cm5zIGhvb2tzIGZvciBxdWVyeWluZyBhbmQgbW9kaWZ5aW5nXHJcbiAqIHRoZSBzeXN0ZW0gc3RyZWFtcyBmcm9tIHRoZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0gc3lzdGVtU3BlYyBUaGUgcmV0dXJuIHZhbHVlIGZyb20gYSBbW3N5c3RlbV1dIGNhbGwuXHJcbiAqIEBwYXJhbSBtYXAgVGhlIHN0cmVhbXMgdG8gcHJvcHMgLyBldmVudHMgLyBtZXRob2RzIG1hcHBpbmcgQ2hlY2sgW1tTeXN0ZW1Qcm9wc01hcF1dIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIEBwYXJhbSBSb290IFRoZSBvcHRpb25hbCBSZWFjdCBjb21wb25lbnQgdG8gcmVuZGVyLiBCeSBkZWZhdWx0LCB0aGUgcmVzdWx0aW5nIGNvbXBvbmVudCByZW5kZXJzIG5vdGhpbmcsIGFjdGluZyBhcyBhIGxvZ2ljYWwgd3JhcHBlciBmb3IgaXRzIGNoaWxkcmVuLlxyXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nOlxyXG4gKiAgLSBgQ29tcG9uZW50YDogdGhlIFJlYWN0IGNvbXBvbmVudC5cclxuICogIC0gYHVzZUVtaXR0ZXJWYWx1ZWA6IGEgaG9vayB0aGF0IGxldHMgY2hpbGQgY29tcG9uZW50cyB1c2UgdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIG91dHB1dCBzdHJlYW0uXHJcbiAqICAtIGB1c2VFbWl0dGVyYDogYSBob29rIHRoYXQgY2FsbHMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgc3RyZWFtIGVtaXRzIGEgdmFsdWUuXHJcbiAqICAtIGB1c2VQdWJsaXNoZXJgOiBhIGhvb2sgd2hpY2ggbGV0cyBjaGlsZCBjb21wb25lbnRzIHB1Ymxpc2ggdmFsdWVzIHRvIHRoZSBzcGVjaWZpZWQgc3RyZWFtLlxyXG4gKiAgPGhyIC8+XHJcbiAqL1xuXG5mdW5jdGlvbiBzeXN0ZW1Ub0NvbXBvbmVudChzeXN0ZW1TcGVjLCBtYXAsIFJvb3QpIHtcbiAgdmFyIHJlcXVpcmVkUHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwLnJlcXVpcmVkIHx8IHt9KTtcbiAgdmFyIG9wdGlvbmFsUHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwLm9wdGlvbmFsIHx8IHt9KTtcbiAgdmFyIG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMobWFwLm1ldGhvZHMgfHwge30pO1xuICB2YXIgZXZlbnROYW1lcyA9IE9iamVjdC5rZXlzKG1hcC5ldmVudHMgfHwge30pO1xuICB2YXIgQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuXG4gIGZ1bmN0aW9uIGFwcGx5UHJvcHNUb1N5c3RlbShzeXN0ZW0sIHByb3BzKSB7XG4gICAgaWYgKHN5c3RlbVsncHJvcHNSZWFkeSddKSB7XG4gICAgICBwdWJsaXNoKHN5c3RlbVsncHJvcHNSZWFkeSddLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZXF1aXJlZFByb3BOYW1lcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcmVxdWlyZWRQcm9wTmFtZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIHN0cmVhbSA9IHN5c3RlbVttYXAucmVxdWlyZWRbcmVxdWlyZWRQcm9wTmFtZV1dO1xuICAgICAgcHVibGlzaChzdHJlYW0sIHByb3BzW3JlcXVpcmVkUHJvcE5hbWVdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvcHRpb25hbFByb3BOYW1lcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgb3B0aW9uYWxQcm9wTmFtZSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgaWYgKG9wdGlvbmFsUHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgdmFyIF9zdHJlYW0gPSBzeXN0ZW1bbWFwLm9wdGlvbmFsW29wdGlvbmFsUHJvcE5hbWVdXTtcbiAgICAgICAgcHVibGlzaChfc3RyZWFtLCBwcm9wc1tvcHRpb25hbFByb3BOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN5c3RlbVsncHJvcHNSZWFkeSddKSB7XG4gICAgICBwdWJsaXNoKHN5c3RlbVsncHJvcHNSZWFkeSddLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZE1ldGhvZHMoc3lzdGVtKSB7XG4gICAgcmV0dXJuIG1ldGhvZE5hbWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBtZXRob2ROYW1lKSB7XG5cbiAgICAgIGFjY1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyZWFtID0gc3lzdGVtW21hcC5tZXRob2RzW21ldGhvZE5hbWVdXTtcbiAgICAgICAgcHVibGlzaChzdHJlYW0sIHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRFdmVudEhhbmRsZXJzKHN5c3RlbSkge1xuICAgIHJldHVybiBldmVudE5hbWVzLnJlZHVjZShmdW5jdGlvbiAoaGFuZGxlcnMsIGV2ZW50TmFtZSkge1xuICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXSA9IGV2ZW50SGFuZGxlcihzeXN0ZW1bbWFwLmV2ZW50c1tldmVudE5hbWVdXSk7XG4gICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgfSwge30pO1xuICB9XG4gIC8qKlxyXG4gICAqIEEgUmVhY3QgY29tcG9uZW50IGdlbmVyYXRlZCBmcm9tIGFuIHVyeCBzeXN0ZW1cclxuICAgKi9cblxuXG4gIHZhciBDb21wb25lbnQgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wc1dpdGhDaGlsZHJlbiwgcmVmKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHNXaXRoQ2hpbGRyZW4uY2hpbGRyZW4sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHNXaXRoQ2hpbGRyZW4sIF9leGNsdWRlZCk7XG5cbiAgICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRhcChpbml0KHN5c3RlbVNwZWMpLCBmdW5jdGlvbiAoc3lzdGVtKSB7XG4gICAgICAgIHJldHVybiBhcHBseVByb3BzVG9TeXN0ZW0oc3lzdGVtLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICAgICAgc3lzdGVtID0gX3VzZVN0YXRlWzBdO1xuXG4gICAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShjdXJyeTF0bzAoYnVpbGRFdmVudEhhbmRsZXJzLCBzeXN0ZW0pKSxcbiAgICAgICAgaGFuZGxlcnMgPSBfdXNlU3RhdGUyWzBdO1xuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShldmVudE5hbWVzKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICBpZiAoZXZlbnROYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgc3Vic2NyaWJlKGhhbmRsZXJzW2V2ZW50TmFtZV0sIHByb3BzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoaGFuZGxlcnMpLm1hcChyZXNldCk7XG4gICAgICB9O1xuICAgIH0sIFtwcm9wcywgaGFuZGxlcnMsIHN5c3RlbV0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHlQcm9wc1RvU3lzdGVtKHN5c3RlbSwgcHJvcHMpO1xuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBhbHdheXMoYnVpbGRNZXRob2RzKHN5c3RlbSkpKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc3lzdGVtXG4gICAgfSwgUm9vdCA/IGNyZWF0ZUVsZW1lbnQoUm9vdCwgb21pdChbXS5jb25jYXQocmVxdWlyZWRQcm9wTmFtZXMsIG9wdGlvbmFsUHJvcE5hbWVzLCBldmVudE5hbWVzKSwgcHJvcHMpLCBjaGlsZHJlbikgOiBjaGlsZHJlbik7XG4gIH0pO1xuXG4gIHZhciB1c2VQdWJsaXNoZXIgPSBmdW5jdGlvbiB1c2VQdWJsaXNoZXIoa2V5KSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGN1cnJ5MnRvMShwdWJsaXNoLCB1c2VDb250ZXh0KENvbnRleHQpW2tleV0pLCBba2V5XSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgc3RyZWFtLlxyXG4gICAqL1xuXG5cbiAgdmFyIHVzZUVtaXR0ZXJWYWx1ZSA9IGZ1bmN0aW9uIHVzZUVtaXR0ZXJWYWx1ZShrZXkpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgdmFyIHNvdXJjZSA9IGNvbnRleHRba2V5XTtcblxuICAgIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoY3VycnkxdG8wKGdldFZhbHVlLCBzb3VyY2UpKSxcbiAgICAgICAgdmFsdWUgPSBfdXNlU3RhdGUzWzBdLFxuICAgICAgICBzZXRWYWx1ZSA9IF91c2VTdGF0ZTNbMV07XG5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmUoc291cmNlLCBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBpZiAobmV4dCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZShhbHdheXMobmV4dCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBbc291cmNlLCB2YWx1ZV0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgdXNlRW1pdHRlciA9IGZ1bmN0aW9uIHVzZUVtaXR0ZXIoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB2YXIgc291cmNlID0gY29udGV4dFtrZXldO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShzb3VyY2UsIGNhbGxiYWNrKTtcbiAgICB9LCBbY2FsbGJhY2ssIHNvdXJjZV0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIsXG4gICAgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUsXG4gICAgdXNlRW1pdHRlcjogdXNlRW1pdHRlclxuICB9O1xufVxuXG5leHBvcnQgeyBzeXN0ZW1Ub0NvbXBvbmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtdXJ4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@virtuoso.dev/urx/dist/urx.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@virtuoso.dev/urx/dist/urx.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   always: () => (/* binding */ always),\n/* harmony export */   call: () => (/* binding */ call),\n/* harmony export */   combineLatest: () => (/* binding */ combineLatest),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   curry1to0: () => (/* binding */ curry1to0),\n/* harmony export */   curry2to1: () => (/* binding */ curry2to1),\n/* harmony export */   debounceTime: () => (/* binding */ debounceTime),\n/* harmony export */   defaultComparator: () => (/* binding */ defaultComparator),\n/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged),\n/* harmony export */   duc: () => (/* binding */ duc),\n/* harmony export */   eventHandler: () => (/* binding */ eventHandler),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   getValue: () => (/* binding */ getValue),\n/* harmony export */   handleNext: () => (/* binding */ handleNext),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   joinProc: () => (/* binding */ joinProc),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapTo: () => (/* binding */ mapTo),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   prop: () => (/* binding */ prop),\n/* harmony export */   publish: () => (/* binding */ publish),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   scan: () => (/* binding */ scan),\n/* harmony export */   skip: () => (/* binding */ skip),\n/* harmony export */   statefulStream: () => (/* binding */ statefulStream),\n/* harmony export */   statefulStreamFromEmitter: () => (/* binding */ statefulStreamFromEmitter),\n/* harmony export */   stream: () => (/* binding */ stream),\n/* harmony export */   streamFromEmitter: () => (/* binding */ streamFromEmitter),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   system: () => (/* binding */ system),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   throttleTime: () => (/* binding */ throttleTime),\n/* harmony export */   thrush: () => (/* binding */ thrush),\n/* harmony export */   tup: () => (/* binding */ tup),\n/* harmony export */   withLatestFrom: () => (/* binding */ withLatestFrom)\n/* harmony export */ });\nvar PUBLISH = 0;\nvar SUBSCRIBE = 1;\nvar RESET = 2;\nvar VALUE = 4;\n\n/**\r\n * Utils includes\r\n * - a handful of functional utilities inspired by or taken from the [Ramda library](https://ramdajs.com/);\r\n * - TypeScript crutches - the [[tup]] function.\r\n *\r\n * Use these for your convenience - they are here so that urx is zero-dependency package.\r\n *\r\n * @packageDocumentation\r\n */\n\n/**\r\n * Performs left to right composition of two functions.\r\n */\nfunction compose(a, b) {\n  return function (arg) {\n    return a(b(arg));\n  };\n}\n/**\r\n * Takes a value and applies a function to it.\r\n */\n\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\n/**\r\n * Takes a 2 argument function and partially applies the first argument.\r\n */\n\nfunction curry2to1(proc, arg1) {\n  return function (arg2) {\n    return proc(arg1, arg2);\n  };\n}\n/**\r\n * Takes a 1 argument function and returns a function which when called, executes it with the provided argument.\r\n */\n\nfunction curry1to0(proc, arg) {\n  return function () {\n    return proc(arg);\n  };\n}\n/**\r\n * Returns a function which extracts the property from from the passed object.\r\n */\n\nfunction prop(property) {\n  return function (object) {\n    return object[property];\n  };\n}\n/**\r\n * Calls callback with the first argument, and returns it.\r\n */\n\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\n/**\r\n *  Utility function to help typescript figure out that what we pass is a tuple and not a generic array.\r\n *  Taken from (this StackOverflow tread)[https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript/52445008#52445008]\r\n */\n\nfunction tup() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args;\n}\n/**\r\n * Calls the passed function.\r\n */\n\nfunction call(proc) {\n  proc();\n}\n/**\r\n * returns a function which when called always returns the passed value\r\n */\n\nfunction always(value) {\n  return function () {\n    return value;\n  };\n}\n/**\r\n * returns a function which calls all passed functions in the passed order.\r\n * joinProc does not pass arguments or collect return values.\r\n */\n\nfunction joinProc() {\n  for (var _len2 = arguments.length, procs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    procs[_key2] = arguments[_key2];\n  }\n\n  return function () {\n    procs.map(call);\n  };\n}\nfunction noop() {}\n\n/**\r\n * urx Actions operate on streams - `publish` publishes data in a stream, and `subscribe` attaches a subscription to a stream.\r\n * @packageDocumentation\r\n */\n/**\r\n * Subscribes the specified [[Subscription]] to the updates from the Emitter.\r\n * The emitter calls the subscription with the new data each time new data is published into it.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n * subscribe(foo, (value) => console.log(value));\r\n * ```\r\n *\r\n * @returns an [[Unsubscribe]] handle  - calling it will unbind the subscription from the emitter.\r\n *```ts\r\n * const foo = stream<number>();\r\n * const unsub = subscribe(foo, (value) => console.log(value));\r\n * unsub();\r\n *```\r\n */\n\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\n/**\r\n * Publishes the value into the passed [[Publisher]].\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n * publish(foo, 42);\r\n * ```\r\n */\n\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\n/**\r\n * Clears all subscriptions from the [[Emitter]].\r\n * ```ts\r\n * const foo = stream<number>();\r\n * subscribe(foo, (value) => console.log(value));\r\n * reset(foo);\r\n * publish(foo, 42);\r\n * ```\r\n */\n\nfunction reset(emitter) {\n  emitter(RESET);\n}\n/**\r\n * Extracts the current value from a stateful stream. Use it only as an escape hatch, as it violates the concept of reactive programming.\r\n * ```ts\r\n * const foo = statefulStream(42);\r\n * console.log(getValue(foo));\r\n * ```\r\n */\n\nfunction getValue(depot) {\n  return depot(VALUE);\n}\n/**\r\n * Connects two streams - any value emitted from the emitter will be published in the publisher.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * const bar = stream<number>();\r\n * subscribe(bar, (value) => console.log(`Bar emitted ${value}`));\r\n *\r\n * connect(foo, bar);\r\n * publish(foo);\r\n * ```\r\n * @returns an [[Unsubscribe]] handle which will disconnect the two streams.\r\n */\n\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\n/**\r\n * Executes the passed subscription at most once, for the next emit from the emitter.\r\n * ```ts\r\n * const foo = stream<number>()\r\n * handleNext(foo, value => console.log(value)) // called once, with 42\r\n * publish(foo, 42)\r\n * publish(foo, 43)\r\n * ```\r\n * @returns an [[Unsubscribe]] handle to unbind the subscription if necessary.\r\n */\n\nfunction handleNext(emitter, subscription) {\n  var unsub = emitter(SUBSCRIBE, function (value) {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\n\n/**\r\n * Streams are the basic building blocks of a reactive system. Think of them as the system permanent \"data tubes\".\r\n *\r\n * A stream acts as both an [[Emitter]] and [[Publisher]]. Each stream can have multiple {@link Subscription | Subscriptions}.\r\n *\r\n * urx streams are either **stateless** or **stateful**.\r\n * Stateless streams emit data to existing subscriptions when published, without keeping track of it.\r\n * Stateful streams remember the last published value and immediately publish it to new subscriptions.\r\n *\r\n * ```ts\r\n * import { stream, statefulStream, publish, subscribe } from \"@virtuoso.dev/urx\";\r\n *\r\n * // foo is a stateless stream\r\n * const foo = stream<number>();\r\n *\r\n * publish(foo, 42);\r\n * // this subsription will not be called...\r\n * subscribe(foo, (value) => console.log(value));\r\n * // it will only catch published values after it\r\n * publish(foo, 43);\r\n *\r\n * // stateful streams always start with an initial value\r\n * const bar = statefulStream(42);\r\n *\r\n * // subscribing to a stateful stream\r\n * // immediately calls the subscription with the current value\r\n * subscribe(bar, (value) => console.log(value));\r\n *\r\n * // subsequent publishing works just like stateless streams\r\n * publish(bar, 43);\r\n * ```\r\n * @packageDocumentation\r\n */\n/**\r\n * Constructs a new stateless stream.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * ```\r\n * @typeParam T the type of values to publish in the stream.\r\n * @returns a [[Stream]]\r\n */\n\nfunction stream() {\n  var subscriptions = [];\n  return function (action, arg) {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return function () {\n          var indexOf = subscriptions.indexOf(arg);\n\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n\n      case PUBLISH:\n        subscriptions.slice().forEach(function (subscription) {\n          subscription(arg);\n        });\n        return;\n\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * Constructs a new stateful stream.\r\n * ```ts\r\n * const foo = statefulStream(42);\r\n * ```\r\n * @param initial the initial value in the stream.\r\n * @typeParam T the type of values to publish in the stream. If omitted, the function infers it from the initial value.\r\n * @returns a [[StatefulStream]]\r\n */\n\nfunction statefulStream(initial) {\n  var value = initial;\n  var innerSubject = stream();\n  return function (action, arg) {\n    switch (action) {\n      case SUBSCRIBE:\n        var subscription = arg;\n        subscription(value);\n        break;\n\n      case PUBLISH:\n        value = arg;\n        break;\n\n      case VALUE:\n        return value;\n    }\n\n    return innerSubject(action, arg);\n  };\n}\n/**\r\n * Event handlers are special emitters which can have **at most one active subscription**.\r\n * Subscribing to an event handler unsubscribes the previous subscription, if present.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * const fooEvent = eventHandler(foo);\r\n *\r\n * // will be called once with 42\r\n * subscribe(fooEvent, (value) => console.log(`Sub 1 ${value}`));\r\n * publish(foo, 42);\r\n *\r\n * // unsubscribes sub 1\r\n * subscribe(fooEvent, (value) => console.log(`Sub 2 ${value}`));\r\n * publish(foo, 43);\r\n * ```\r\n * @param emitter the source emitter.\r\n * @returns the single-subscription emitter.\r\n */\n\nfunction eventHandler(emitter) {\n  var unsub;\n  var currentSubscription;\n\n  var cleanup = function cleanup() {\n    return unsub && unsub();\n  };\n\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * Creates and connects a \"junction\" stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n *\r\n * const fooX2 = pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * );\r\n *\r\n * subscribe(fooX2, (value) => console.log(value));\r\n * subscribe(fooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42); // executes the map operator twice for each subscription.\r\n *\r\n * const sharedFooX2 = streamFromEmitter(pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`shared multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * ));\r\n *\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42);\r\n *```\r\n * @returns the resulting stream.\r\n */\n\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), function (stream) {\n    return connect(emitter, stream);\n  });\n}\n/**\r\n * Creates and connects a \"junction\" stateful stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n *\r\n * const fooX2 = pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * );\r\n *\r\n * subscribe(fooX2, (value) => console.log(value));\r\n * subscribe(fooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42); // executes the map operator twice for each subscription.\r\n *\r\n * const sharedFooX2 = statefulStreamFromEmitter(pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`shared multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * ), 42);\r\n *\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42);\r\n *```\r\n * @param initial the initial value in the stream.\r\n * @returns the resulting stateful stream.\r\n */\n\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), function (stream) {\n    return connect(emitter, stream);\n  });\n}\n\n/**\r\n *\r\n * Stream values can be transformed and controlled by {@link pipe | **piping**} through **operators**.\r\n * urx includes several operators like [[map]], [[filter]], [[scan]], and [[throttleTime]].\r\n * The [[withLatestFrom]] operator allows the combination of values from other streams.\r\n *\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\r\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\r\n * subscribe(bar, value => console.log(value))\r\n * publish(foo, 2) // outputs 8\r\n * ```\r\n *\r\n * ### Implementing Custom Operators\r\n * To implement your own operators, implement the [[Operator]] interface.\r\n * @packageDocumentation\r\n */\n/** @internal */\n\nfunction combineOperators() {\n  for (var _len = arguments.length, operators = new Array(_len), _key = 0; _key < _len; _key++) {\n    operators[_key] = arguments[_key];\n  }\n\n  return function (subscriber) {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\n\nfunction pipe(source) {\n  for (var _len2 = arguments.length, operators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    operators[_key2 - 1] = arguments[_key2];\n  }\n\n  // prettier-ignore\n  var project = combineOperators.apply(void 0, operators);\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n\n      case RESET:\n        reset(source);\n        return;\n\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * The default [[Comparator]] for [[distinctUntilChanged]] and [[duc]].\r\n */\n\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\n/**\r\n * Filters out identical values. Pass an optional [[Comparator]] if you need to filter non-primitive values.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, distinctUntilChanged()),\r\n *  console.log\r\n * ) // will be called only once\r\n *\r\n * publish(foo, 42)\r\n * publish(foo, 42)\r\n * ```\r\n */\n\nfunction distinctUntilChanged(comparator) {\n  if (comparator === void 0) {\n    comparator = defaultComparator;\n  }\n\n  var current;\n  return function (done) {\n    return function (next) {\n      if (!comparator(current, next)) {\n        current = next;\n        done(next);\n      }\n    };\n  };\n}\n/**\r\n * Filters out values for which the predicator does not return `true`-ish.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, filter(value => value % 2 === 0)),\r\n *  console.log\r\n * ) // will be called only with even values\r\n *\r\n * publish(foo, 2)\r\n * publish(foo, 3)\r\n * publish(foo, 4)\r\n * publish(foo, 5)\r\n * ```\r\n */\n\nfunction filter(predicate) {\n  return function (done) {\n    return function (value) {\n      predicate(value) && done(value);\n    };\n  };\n}\n/**\r\n * Maps values using the provided project function.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, map(value => value * 2)),\r\n *  console.log\r\n * ) // 4, 6\r\n *\r\n * publish(foo, 2)\r\n * publish(foo, 3)\r\n * ```\r\n */\n\nfunction map(project) {\n  return function (done) {\n    return compose(done, project);\n  };\n}\n/**\r\n * Maps values to the hard-coded value.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, mapTo(3)),\r\n *  console.log\r\n * ) // 3, 3\r\n *\r\n * publish(foo, 1)\r\n * publish(foo, 2)\r\n * ```\r\n */\n\nfunction mapTo(value) {\n  return function (done) {\n    return function () {\n      return done(value);\n    };\n  };\n}\n/**\r\n * Works like Array#reduce.\r\n * Applies an accumulator function on the emitter, and outputs intermediate result. Starts with the initial value.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, scan((acc, value) => acc + value, 2),\r\n *  console.log\r\n * ) // 3, 5\r\n *\r\n * publish(foo, 1)\r\n * publish(foo, 2)\r\n * ```\r\n */\n\nfunction scan(scanner, initial) {\n  return function (done) {\n    return function (value) {\n      return done(initial = scanner(initial, value));\n    };\n  };\n}\n/**\r\n * Skips the specified amount of values from the emitter.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, skip(2)),\r\n *  console.log\r\n * ) // 3, 4\r\n *\r\n * publish(foo, 1) // skipped\r\n * publish(foo, 2) // skipped\r\n * publish(foo, 3)\r\n * publish(foo, 4)\r\n * ```\r\n */\n\nfunction skip(times) {\n  return function (done) {\n    return function (value) {\n      times > 0 ? times-- : done(value);\n    };\n  };\n}\n/**\r\n * Throttles flowing values at the provided interval in milliseconds.\r\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\r\n *\r\n * ```ts\r\n *  const foo = stream<number>()\r\n *  publish(foo, 1)\r\n *\r\n *  setTimeout(() => publish(foo, 2), 20)\r\n *  setTimeout(() => publish(foo, 3), 20)\r\n *\r\n *  subscribe(pipe(foo, throttleTime(50)), val => {\r\n *    console.log(value); // 3\r\n *  })\r\n * ```\r\n */\n\nfunction throttleTime(interval) {\n  var currentValue;\n  var timeout;\n  return function (done) {\n    return function (value) {\n      currentValue = value;\n\n      if (timeout) {\n        return;\n      }\n\n      timeout = setTimeout(function () {\n        timeout = undefined;\n        done(currentValue);\n      }, interval);\n    };\n  };\n}\n/**\r\n * Debounces flowing values at the provided interval in milliseconds.\r\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\r\n *\r\n * ```ts\r\n *  const foo = stream<number>()\r\n *  publish(foo, 1)\r\n *\r\n *  setTimeout(() => publish(foo, 2), 20)\r\n *  setTimeout(() => publish(foo, 3), 20)\r\n *\r\n *  subscribe(pipe(foo, debounceTime(50)), val => {\r\n *    console.log(value); // 3\r\n *  })\r\n * ```\r\n */\n\nfunction debounceTime(interval) {\n  var currentValue;\n  var timeout;\n  return function (done) {\n    return function (value) {\n      currentValue = value;\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      timeout = setTimeout(function () {\n        done(currentValue);\n      }, interval);\n    };\n  };\n}\nfunction withLatestFrom() {\n  for (var _len3 = arguments.length, sources = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    sources[_key3] = arguments[_key3];\n  }\n\n  var values = new Array(sources.length);\n  var called = 0;\n  var pendingCall = null;\n  var allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach(function (source, index) {\n    var bit = Math.pow(2, index);\n    subscribe(source, function (value) {\n      var prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return function (done) {\n    return function (value) {\n      var call = function call() {\n        return done([value].concat(values));\n      };\n\n      if (called === allCalled) {\n        call();\n      } else {\n        pendingCall = call;\n      }\n    };\n  };\n}\n\n/**\r\n * Transformers change and combine streams, similar to operators.\r\n * urx comes with two combinators - [[combineLatest]] and [[merge]], and one convenience filter - [[duc]].\r\n *\r\n * @packageDocumentation\r\n */\n/**\r\n * Merges one or more emitters from the same type into a new Emitter which emits values from any of the source emitters.\r\n * ```ts\r\n * const foo = stream<number>()\r\n * const bar = stream<number>()\r\n *\r\n * subscribe(merge(foo, bar), (value) => console.log(value)) // 42, 43\r\n *\r\n * publish(foo, 42)\r\n * publish(bar, 43)\r\n * ```\r\n */\n\nfunction merge() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc.apply(void 0, sources.map(function (source) {\n          return subscribe(source, subscription);\n        }));\n\n      case RESET:\n        // do nothing, we are stateless\n        return;\n\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * A convenience wrapper that emits only the distinct values from the passed Emitter. Wraps [[pipe]] and [[distinctUntilChanged]].\r\n *\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * // this line...\r\n * const a = duc(foo)\r\n *\r\n * // is equivalent to this\r\n * const b = pipe(distinctUntilChanged(foo))\r\n * ```\r\n *\r\n * @param source The source emitter.\r\n * @param comparator optional custom comparison function for the two values.\r\n *\r\n * @typeParam T the type of the value emitted by the source.\r\n *\r\n * @returns the resulting emitter.\r\n */\n\nfunction duc(source, comparator) {\n  if (comparator === void 0) {\n    comparator = defaultComparator;\n  }\n\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest() {\n  var innerSubject = stream();\n\n  for (var _len2 = arguments.length, emitters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    emitters[_key2] = arguments[_key2];\n  }\n\n  var values = new Array(emitters.length);\n  var called = 0;\n  var allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach(function (source, index) {\n    var bit = Math.pow(2, index);\n    subscribe(source, function (value) {\n      values[index] = value;\n      called = called | bit;\n\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n\n        return subscribe(innerSubject, subscription);\n\n      case RESET:\n        return reset(innerSubject);\n\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n\n/**\r\n * `system` defines a specification of a system - its constructor, dependencies and if it should act as a singleton in a system dependency tree.\r\n * When called, system returns a [[SystemSpec]], which is then initialized along with its dependencies by passing it to [[init]].\r\n *\r\n * ```ts\r\n * @import { subscribe, publish, system, init, tup, connect, map, pipe } from 'urx'\r\n *\r\n * // a simple system with two streams\r\n * const sys1 = system(() => {\r\n *  const a = stream<number>()\r\n *  const b = stream<number>()\r\n *\r\n *  connect(pipe(a, map(value => value * 2)), b)\r\n *  return { a, b }\r\n * })\r\n *\r\n * // a second system which depends on the streams from the first one\r\n * const sys2 = system(([ {a, b} ]) => {\r\n *  const c = stream<number>()\r\n *  connect(pipe(b, map(value => value * 2)), c)\r\n *  // re-export the `a` stream, keep `b` internal\r\n *  return { a, c }\r\n * }, tup(sys1))\r\n *\r\n * // init will recursively initialize sys2 dependencies, in this case sys1\r\n * const { a, c } = init(sys2)\r\n * subscribe(c, c => console.log(`Value multiplied by 4`, c))\r\n * publish(a, 2)\r\n * ```\r\n *\r\n * #### Singletons in Dependency Tree\r\n *\r\n * By default, systems will be initialized only once if encountered multiple times in the dependency tree.\r\n * In the below dependency system tree, systems `b` and `c` will receive the same stream instances from system `a` when system `d` is initialized.\r\n * ```txt\r\n *   a\r\n *  / \\\r\n * b   c\r\n *  \\ /\r\n *   d\r\n * ```\r\n * If `a` gets `{singleton: false}` as a last argument, `init` creates two separate instances - one for `b` and one for `c`.\r\n *\r\n * @param constructor the system constructor function. Initialize and connect the streams in its body.\r\n *\r\n * @param dependencies the system dependencies, which the constructor will receive as arguments.\r\n * Use the [[tup]] utility **For TypeScript type inference to work correctly**.\r\n * ```ts\r\n * const sys3 = system(() => { ... }, tup(sys2, sys1))\r\n * ```\r\n * @param __namedParameters Options\r\n * @param singleton determines if the system will act as a singleton in a system dependency tree. `true` by default.\r\n */\nfunction system(constructor, dependencies, _temp) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n\n  var _ref = _temp === void 0 ? {\n    singleton: true\n  } : _temp,\n      singleton = _ref.singleton;\n\n  return {\n    id: id(),\n    constructor: constructor,\n    dependencies: dependencies,\n    singleton: singleton\n  };\n}\n/** @internal */\n\nvar id = function id() {\n  return Symbol();\n};\n/**\r\n * Initializes a [[SystemSpec]] by recursively initializing its dependencies.\r\n *\r\n * ```ts\r\n * // a simple system with two streams\r\n * const sys1 = system(() => {\r\n *  const a = stream<number>()\r\n *  const b = stream<number>()\r\n *\r\n *  connect(pipe(a, map(value => value * 2)), b)\r\n *  return { a, b }\r\n * })\r\n *\r\n * const { a, b } = init(sys1)\r\n * subscribe(b, b => console.log(b))\r\n * publish(a, 2)\r\n * ```\r\n *\r\n * @returns the [[System]] constructed by the spec constructor.\r\n * @param systemSpec the system spec to initialize.\r\n */\n\n\nfunction init(systemSpec) {\n  var singletons = new Map();\n\n  var _init = function _init(_ref2) {\n    var id = _ref2.id,\n        constructor = _ref2.constructor,\n        dependencies = _ref2.dependencies,\n        singleton = _ref2.singleton;\n\n    if (singleton && singletons.has(id)) {\n      return singletons.get(id);\n    }\n\n    var system = constructor(dependencies.map(function (e) {\n      return _init(e);\n    }));\n\n    if (singleton) {\n      singletons.set(id, system);\n    }\n\n    return system;\n  };\n\n  return _init(systemSpec);\n}\n\n\n//# sourceMappingURL=urx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi91cngvZGlzdC91cnguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsbUNBQW1DO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUE0RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVpWjtBQUNqWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy0xNS1zb2NpYWwtbWVkaWEtYXBwLy4vbm9kZV9tb2R1bGVzL0B2aXJ0dW9zby5kZXYvdXJ4L2Rpc3QvdXJ4LmVzbS5qcz8wYmY4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBQVUJMSVNIID0gMDtcbnZhciBTVUJTQ1JJQkUgPSAxO1xudmFyIFJFU0VUID0gMjtcbnZhciBWQUxVRSA9IDQ7XG5cbi8qKlxyXG4gKiBVdGlscyBpbmNsdWRlc1xyXG4gKiAtIGEgaGFuZGZ1bCBvZiBmdW5jdGlvbmFsIHV0aWxpdGllcyBpbnNwaXJlZCBieSBvciB0YWtlbiBmcm9tIHRoZSBbUmFtZGEgbGlicmFyeV0oaHR0cHM6Ly9yYW1kYWpzLmNvbS8pO1xyXG4gKiAtIFR5cGVTY3JpcHQgY3J1dGNoZXMgLSB0aGUgW1t0dXBdXSBmdW5jdGlvbi5cclxuICpcclxuICogVXNlIHRoZXNlIGZvciB5b3VyIGNvbnZlbmllbmNlIC0gdGhleSBhcmUgaGVyZSBzbyB0aGF0IHVyeCBpcyB6ZXJvLWRlcGVuZGVuY3kgcGFja2FnZS5cclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xuXG4vKipcclxuICogUGVyZm9ybXMgbGVmdCB0byByaWdodCBjb21wb3NpdGlvbiBvZiB0d28gZnVuY3Rpb25zLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2UoYSwgYikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBhKGIoYXJnKSk7XG4gIH07XG59XG4vKipcclxuICogVGFrZXMgYSB2YWx1ZSBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uIHRvIGl0LlxyXG4gKi9cblxuZnVuY3Rpb24gdGhydXNoKGFyZywgcHJvYykge1xuICByZXR1cm4gcHJvYyhhcmcpO1xufVxuLyoqXHJcbiAqIFRha2VzIGEgMiBhcmd1bWVudCBmdW5jdGlvbiBhbmQgcGFydGlhbGx5IGFwcGxpZXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxyXG4gKi9cblxuZnVuY3Rpb24gY3VycnkydG8xKHByb2MsIGFyZzEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcyKSB7XG4gICAgcmV0dXJuIHByb2MoYXJnMSwgYXJnMik7XG4gIH07XG59XG4vKipcclxuICogVGFrZXMgYSAxIGFyZ3VtZW50IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggd2hlbiBjYWxsZWQsIGV4ZWN1dGVzIGl0IHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50LlxyXG4gKi9cblxuZnVuY3Rpb24gY3VycnkxdG8wKHByb2MsIGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jKGFyZyk7XG4gIH07XG59XG4vKipcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4dHJhY3RzIHRoZSBwcm9wZXJ0eSBmcm9tIGZyb20gdGhlIHBhc3NlZCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBwcm9wKHByb3BlcnR5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XG4gIH07XG59XG4vKipcclxuICogQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQsIGFuZCByZXR1cm5zIGl0LlxyXG4gKi9cblxuZnVuY3Rpb24gdGFwKGFyZywgcHJvYykge1xuICBwcm9jKGFyZyk7XG4gIHJldHVybiBhcmc7XG59XG4vKipcclxuICogIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGVscCB0eXBlc2NyaXB0IGZpZ3VyZSBvdXQgdGhhdCB3aGF0IHdlIHBhc3MgaXMgYSB0dXBsZSBhbmQgbm90IGEgZ2VuZXJpYyBhcnJheS5cclxuICogIFRha2VuIGZyb20gKHRoaXMgU3RhY2tPdmVyZmxvdyB0cmVhZClbaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk3Mjk1NTAvaW1wbGljaXRseS1jcmVhdGUtYS10dXBsZS1pbi10eXBlc2NyaXB0LzUyNDQ1MDA4IzUyNDQ1MDA4XVxyXG4gKi9cblxuZnVuY3Rpb24gdHVwKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGFyZ3M7XG59XG4vKipcclxuICogQ2FsbHMgdGhlIHBhc3NlZCBmdW5jdGlvbi5cclxuICovXG5cbmZ1bmN0aW9uIGNhbGwocHJvYykge1xuICBwcm9jKCk7XG59XG4vKipcclxuICogcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHdoZW4gY2FsbGVkIGFsd2F5cyByZXR1cm5zIHRoZSBwYXNzZWQgdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGFsd2F5cyh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cbi8qKlxyXG4gKiByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggY2FsbHMgYWxsIHBhc3NlZCBmdW5jdGlvbnMgaW4gdGhlIHBhc3NlZCBvcmRlci5cclxuICogam9pblByb2MgZG9lcyBub3QgcGFzcyBhcmd1bWVudHMgb3IgY29sbGVjdCByZXR1cm4gdmFsdWVzLlxyXG4gKi9cblxuZnVuY3Rpb24gam9pblByb2MoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvY3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBwcm9jc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jcy5tYXAoY2FsbCk7XG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cblxuLyoqXHJcbiAqIHVyeCBBY3Rpb25zIG9wZXJhdGUgb24gc3RyZWFtcyAtIGBwdWJsaXNoYCBwdWJsaXNoZXMgZGF0YSBpbiBhIHN0cmVhbSwgYW5kIGBzdWJzY3JpYmVgIGF0dGFjaGVzIGEgc3Vic2NyaXB0aW9uIHRvIGEgc3RyZWFtLlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXG4vKipcclxuICogU3Vic2NyaWJlcyB0aGUgc3BlY2lmaWVkIFtbU3Vic2NyaXB0aW9uXV0gdG8gdGhlIHVwZGF0ZXMgZnJvbSB0aGUgRW1pdHRlci5cclxuICogVGhlIGVtaXR0ZXIgY2FsbHMgdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBuZXcgZGF0YSBlYWNoIHRpbWUgbmV3IGRhdGEgaXMgcHVibGlzaGVkIGludG8gaXQuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqIHN1YnNjcmliZShmb28sICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEByZXR1cm5zIGFuIFtbVW5zdWJzY3JpYmVdXSBoYW5kbGUgIC0gY2FsbGluZyBpdCB3aWxsIHVuYmluZCB0aGUgc3Vic2NyaXB0aW9uIGZyb20gdGhlIGVtaXR0ZXIuXHJcbiAqYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKTtcclxuICogY29uc3QgdW5zdWIgPSBzdWJzY3JpYmUoZm9vLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqIHVuc3ViKCk7XHJcbiAqYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBzdWJzY3JpYmUoZW1pdHRlciwgc3Vic2NyaXB0aW9uKSB7XG4gIHJldHVybiBlbWl0dGVyKFNVQlNDUklCRSwgc3Vic2NyaXB0aW9uKTtcbn1cbi8qKlxyXG4gKiBQdWJsaXNoZXMgdGhlIHZhbHVlIGludG8gdGhlIHBhc3NlZCBbW1B1Ymxpc2hlcl1dLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBwdWJsaXNoKGZvbywgNDIpO1xyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHVibGlzaGVyLCB2YWx1ZSkge1xuICBwdWJsaXNoZXIoUFVCTElTSCwgdmFsdWUpO1xufVxuLyoqXHJcbiAqIENsZWFycyBhbGwgc3Vic2NyaXB0aW9ucyBmcm9tIHRoZSBbW0VtaXR0ZXJdXS5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKTtcclxuICogc3Vic2NyaWJlKGZvbywgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKiByZXNldChmb28pO1xyXG4gKiBwdWJsaXNoKGZvbywgNDIpO1xyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIHJlc2V0KGVtaXR0ZXIpIHtcbiAgZW1pdHRlcihSRVNFVCk7XG59XG4vKipcclxuICogRXh0cmFjdHMgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSBhIHN0YXRlZnVsIHN0cmVhbS4gVXNlIGl0IG9ubHkgYXMgYW4gZXNjYXBlIGhhdGNoLCBhcyBpdCB2aW9sYXRlcyB0aGUgY29uY2VwdCBvZiByZWFjdGl2ZSBwcm9ncmFtbWluZy5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RhdGVmdWxTdHJlYW0oNDIpO1xyXG4gKiBjb25zb2xlLmxvZyhnZXRWYWx1ZShmb28pKTtcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShkZXBvdCkge1xuICByZXR1cm4gZGVwb3QoVkFMVUUpO1xufVxuLyoqXHJcbiAqIENvbm5lY3RzIHR3byBzdHJlYW1zIC0gYW55IHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgZW1pdHRlciB3aWxsIGJlIHB1Ymxpc2hlZCBpbiB0aGUgcHVibGlzaGVyLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBjb25zdCBiYXIgPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBzdWJzY3JpYmUoYmFyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKGBCYXIgZW1pdHRlZCAke3ZhbHVlfWApKTtcclxuICpcclxuICogY29ubmVjdChmb28sIGJhcik7XHJcbiAqIHB1Ymxpc2goZm9vKTtcclxuICogYGBgXHJcbiAqIEByZXR1cm5zIGFuIFtbVW5zdWJzY3JpYmVdXSBoYW5kbGUgd2hpY2ggd2lsbCBkaXNjb25uZWN0IHRoZSB0d28gc3RyZWFtcy5cclxuICovXG5cbmZ1bmN0aW9uIGNvbm5lY3QoZW1pdHRlciwgcHVibGlzaGVyKSB7XG4gIHJldHVybiBzdWJzY3JpYmUoZW1pdHRlciwgY3VycnkydG8xKHB1Ymxpc2hlciwgUFVCTElTSCkpO1xufVxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBwYXNzZWQgc3Vic2NyaXB0aW9uIGF0IG1vc3Qgb25jZSwgZm9yIHRoZSBuZXh0IGVtaXQgZnJvbSB0aGUgZW1pdHRlci5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKiBoYW5kbGVOZXh0KGZvbywgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpKSAvLyBjYWxsZWQgb25jZSwgd2l0aCA0MlxyXG4gKiBwdWJsaXNoKGZvbywgNDIpXHJcbiAqIHB1Ymxpc2goZm9vLCA0MylcclxuICogYGBgXHJcbiAqIEByZXR1cm5zIGFuIFtbVW5zdWJzY3JpYmVdXSBoYW5kbGUgdG8gdW5iaW5kIHRoZSBzdWJzY3JpcHRpb24gaWYgbmVjZXNzYXJ5LlxyXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlTmV4dChlbWl0dGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgdmFyIHVuc3ViID0gZW1pdHRlcihTVUJTQ1JJQkUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHVuc3ViKCk7XG4gICAgc3Vic2NyaXB0aW9uKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB1bnN1Yjtcbn1cblxuLyoqXHJcbiAqIFN0cmVhbXMgYXJlIHRoZSBiYXNpYyBidWlsZGluZyBibG9ja3Mgb2YgYSByZWFjdGl2ZSBzeXN0ZW0uIFRoaW5rIG9mIHRoZW0gYXMgdGhlIHN5c3RlbSBwZXJtYW5lbnQgXCJkYXRhIHR1YmVzXCIuXHJcbiAqXHJcbiAqIEEgc3RyZWFtIGFjdHMgYXMgYm90aCBhbiBbW0VtaXR0ZXJdXSBhbmQgW1tQdWJsaXNoZXJdXS4gRWFjaCBzdHJlYW0gY2FuIGhhdmUgbXVsdGlwbGUge0BsaW5rIFN1YnNjcmlwdGlvbiB8IFN1YnNjcmlwdGlvbnN9LlxyXG4gKlxyXG4gKiB1cnggc3RyZWFtcyBhcmUgZWl0aGVyICoqc3RhdGVsZXNzKiogb3IgKipzdGF0ZWZ1bCoqLlxyXG4gKiBTdGF0ZWxlc3Mgc3RyZWFtcyBlbWl0IGRhdGEgdG8gZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucyB3aGVuIHB1Ymxpc2hlZCwgd2l0aG91dCBrZWVwaW5nIHRyYWNrIG9mIGl0LlxyXG4gKiBTdGF0ZWZ1bCBzdHJlYW1zIHJlbWVtYmVyIHRoZSBsYXN0IHB1Ymxpc2hlZCB2YWx1ZSBhbmQgaW1tZWRpYXRlbHkgcHVibGlzaCBpdCB0byBuZXcgc3Vic2NyaXB0aW9ucy5cclxuICpcclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgc3RyZWFtLCBzdGF0ZWZ1bFN0cmVhbSwgcHVibGlzaCwgc3Vic2NyaWJlIH0gZnJvbSBcIkB2aXJ0dW9zby5kZXYvdXJ4XCI7XHJcbiAqXHJcbiAqIC8vIGZvbyBpcyBhIHN0YXRlbGVzcyBzdHJlYW1cclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKTtcclxuICpcclxuICogcHVibGlzaChmb28sIDQyKTtcclxuICogLy8gdGhpcyBzdWJzcmlwdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQuLi5cclxuICogc3Vic2NyaWJlKGZvbywgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKiAvLyBpdCB3aWxsIG9ubHkgY2F0Y2ggcHVibGlzaGVkIHZhbHVlcyBhZnRlciBpdFxyXG4gKiBwdWJsaXNoKGZvbywgNDMpO1xyXG4gKlxyXG4gKiAvLyBzdGF0ZWZ1bCBzdHJlYW1zIGFsd2F5cyBzdGFydCB3aXRoIGFuIGluaXRpYWwgdmFsdWVcclxuICogY29uc3QgYmFyID0gc3RhdGVmdWxTdHJlYW0oNDIpO1xyXG4gKlxyXG4gKiAvLyBzdWJzY3JpYmluZyB0byBhIHN0YXRlZnVsIHN0cmVhbVxyXG4gKiAvLyBpbW1lZGlhdGVseSBjYWxscyB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVcclxuICogc3Vic2NyaWJlKGJhciwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKlxyXG4gKiAvLyBzdWJzZXF1ZW50IHB1Ymxpc2hpbmcgd29ya3MganVzdCBsaWtlIHN0YXRlbGVzcyBzdHJlYW1zXHJcbiAqIHB1Ymxpc2goYmFyLCA0Myk7XHJcbiAqIGBgYFxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBzdGF0ZWxlc3Mgc3RyZWFtLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBgYGBcclxuICogQHR5cGVQYXJhbSBUIHRoZSB0eXBlIG9mIHZhbHVlcyB0byBwdWJsaXNoIGluIHRoZSBzdHJlYW0uXHJcbiAqIEByZXR1cm5zIGEgW1tTdHJlYW1dXVxyXG4gKi9cblxuZnVuY3Rpb24gc3RyZWFtKCkge1xuICB2YXIgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgYXJnKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKDAsIHN1YnNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGFyZyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluZGV4T2YgPSBzdWJzY3JpcHRpb25zLmluZGV4T2YoYXJnKTtcblxuICAgICAgICAgIGlmIChpbmRleE9mID4gLTEpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKGluZGV4T2YsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBQVUJMSVNIOlxuICAgICAgICBzdWJzY3JpcHRpb25zLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uKGFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBhY3Rpb24gXCIgKyBhY3Rpb24pO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHN0YXRlZnVsIHN0cmVhbS5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RhdGVmdWxTdHJlYW0oNDIpO1xyXG4gKiBgYGBcclxuICogQHBhcmFtIGluaXRpYWwgdGhlIGluaXRpYWwgdmFsdWUgaW4gdGhlIHN0cmVhbS5cclxuICogQHR5cGVQYXJhbSBUIHRoZSB0eXBlIG9mIHZhbHVlcyB0byBwdWJsaXNoIGluIHRoZSBzdHJlYW0uIElmIG9taXR0ZWQsIHRoZSBmdW5jdGlvbiBpbmZlcnMgaXQgZnJvbSB0aGUgaW5pdGlhbCB2YWx1ZS5cclxuICogQHJldHVybnMgYSBbW1N0YXRlZnVsU3RyZWFtXV1cclxuICovXG5cbmZ1bmN0aW9uIHN0YXRlZnVsU3RyZWFtKGluaXRpYWwpIHtcbiAgdmFyIHZhbHVlID0gaW5pdGlhbDtcbiAgdmFyIGlubmVyU3ViamVjdCA9IHN0cmVhbSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgYXJnKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gYXJnO1xuICAgICAgICBzdWJzY3JpcHRpb24odmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBQVUJMSVNIOlxuICAgICAgICB2YWx1ZSA9IGFyZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVkFMVUU6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5uZXJTdWJqZWN0KGFjdGlvbiwgYXJnKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBFdmVudCBoYW5kbGVycyBhcmUgc3BlY2lhbCBlbWl0dGVycyB3aGljaCBjYW4gaGF2ZSAqKmF0IG1vc3Qgb25lIGFjdGl2ZSBzdWJzY3JpcHRpb24qKi5cclxuICogU3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQgaGFuZGxlciB1bnN1YnNjcmliZXMgdGhlIHByZXZpb3VzIHN1YnNjcmlwdGlvbiwgaWYgcHJlc2VudC5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKTtcclxuICogY29uc3QgZm9vRXZlbnQgPSBldmVudEhhbmRsZXIoZm9vKTtcclxuICpcclxuICogLy8gd2lsbCBiZSBjYWxsZWQgb25jZSB3aXRoIDQyXHJcbiAqIHN1YnNjcmliZShmb29FdmVudCwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyhgU3ViIDEgJHt2YWx1ZX1gKSk7XHJcbiAqIHB1Ymxpc2goZm9vLCA0Mik7XHJcbiAqXHJcbiAqIC8vIHVuc3Vic2NyaWJlcyBzdWIgMVxyXG4gKiBzdWJzY3JpYmUoZm9vRXZlbnQsICh2YWx1ZSkgPT4gY29uc29sZS5sb2coYFN1YiAyICR7dmFsdWV9YCkpO1xyXG4gKiBwdWJsaXNoKGZvbywgNDMpO1xyXG4gKiBgYGBcclxuICogQHBhcmFtIGVtaXR0ZXIgdGhlIHNvdXJjZSBlbWl0dGVyLlxyXG4gKiBAcmV0dXJucyB0aGUgc2luZ2xlLXN1YnNjcmlwdGlvbiBlbWl0dGVyLlxyXG4gKi9cblxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGVtaXR0ZXIpIHtcbiAgdmFyIHVuc3ViO1xuICB2YXIgY3VycmVudFN1YnNjcmlwdGlvbjtcblxuICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgcmV0dXJuIHVuc3ViICYmIHVuc3ViKCk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24sIHN1YnNjcmlwdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaXB0aW9uID09PSBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgY3VycmVudFN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICB1bnN1YiA9IHN1YnNjcmliZShlbWl0dGVyLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICAgIHJldHVybiB1bnN1YjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgYWN0aW9uIFwiICsgYWN0aW9uKTtcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogQ3JlYXRlcyBhbmQgY29ubmVjdHMgYSBcImp1bmN0aW9uXCIgc3RyZWFtIHRvIHRoZSBzcGVjaWZpZWQgZW1pdHRlci4gT2Z0ZW4gdXNlZCB3aXRoIFtbcGlwZV1dLCB0byBhdm9pZCB0aGUgbXVsdGlwbGUgZXZhbHVhdGlvbiBvZiBvcGVyYXRvciBzZXRzLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKlxyXG4gKiBjb25zdCBmb29YMiA9IHBpcGUoXHJcbiAqICAgZm9vLFxyXG4gKiAgIG1hcCgodmFsdWUpID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGBtdWx0aXBseWluZyAke3ZhbHVlfWApO1xyXG4gKiAgICAgcmV0dXJuIHZhbHVlICogMjtcclxuICogICB9KVxyXG4gKiApO1xyXG4gKlxyXG4gKiBzdWJzY3JpYmUoZm9vWDIsICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICogc3Vic2NyaWJlKGZvb1gyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCA0Mik7IC8vIGV4ZWN1dGVzIHRoZSBtYXAgb3BlcmF0b3IgdHdpY2UgZm9yIGVhY2ggc3Vic2NyaXB0aW9uLlxyXG4gKlxyXG4gKiBjb25zdCBzaGFyZWRGb29YMiA9IHN0cmVhbUZyb21FbWl0dGVyKHBpcGUoXHJcbiAqICAgZm9vLFxyXG4gKiAgIG1hcCgodmFsdWUpID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGBzaGFyZWQgbXVsdGlwbHlpbmcgJHt2YWx1ZX1gKTtcclxuICogICAgIHJldHVybiB2YWx1ZSAqIDI7XHJcbiAqICAgfSlcclxuICogKSk7XHJcbiAqXHJcbiAqIHN1YnNjcmliZShzaGFyZWRGb29YMiwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKiBzdWJzY3JpYmUoc2hhcmVkRm9vWDIsICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICpcclxuICogcHVibGlzaChmb28sIDQyKTtcclxuICpgYGBcclxuICogQHJldHVybnMgdGhlIHJlc3VsdGluZyBzdHJlYW0uXHJcbiAqL1xuXG5mdW5jdGlvbiBzdHJlYW1Gcm9tRW1pdHRlcihlbWl0dGVyKSB7XG4gIHJldHVybiB0YXAoc3RyZWFtKCksIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gY29ubmVjdChlbWl0dGVyLCBzdHJlYW0pO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCBjb25uZWN0cyBhIFwianVuY3Rpb25cIiBzdGF0ZWZ1bCBzdHJlYW0gdG8gdGhlIHNwZWNpZmllZCBlbWl0dGVyLiBPZnRlbiB1c2VkIHdpdGggW1twaXBlXV0sIHRvIGF2b2lkIHRoZSBtdWx0aXBsZSBldmFsdWF0aW9uIG9mIG9wZXJhdG9yIHNldHMuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqXHJcbiAqIGNvbnN0IGZvb1gyID0gcGlwZShcclxuICogICBmb28sXHJcbiAqICAgbWFwKCh2YWx1ZSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coYG11bHRpcGx5aW5nICR7dmFsdWV9YCk7XHJcbiAqICAgICByZXR1cm4gdmFsdWUgKiAyO1xyXG4gKiAgIH0pXHJcbiAqICk7XHJcbiAqXHJcbiAqIHN1YnNjcmliZShmb29YMiwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKiBzdWJzY3JpYmUoZm9vWDIsICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICpcclxuICogcHVibGlzaChmb28sIDQyKTsgLy8gZXhlY3V0ZXMgdGhlIG1hcCBvcGVyYXRvciB0d2ljZSBmb3IgZWFjaCBzdWJzY3JpcHRpb24uXHJcbiAqXHJcbiAqIGNvbnN0IHNoYXJlZEZvb1gyID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihwaXBlKFxyXG4gKiAgIGZvbyxcclxuICogICBtYXAoKHZhbHVlKSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhgc2hhcmVkIG11bHRpcGx5aW5nICR7dmFsdWV9YCk7XHJcbiAqICAgICByZXR1cm4gdmFsdWUgKiAyO1xyXG4gKiAgIH0pXHJcbiAqICksIDQyKTtcclxuICpcclxuICogc3Vic2NyaWJlKHNoYXJlZEZvb1gyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqIHN1YnNjcmliZShzaGFyZWRGb29YMiwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgNDIpO1xyXG4gKmBgYFxyXG4gKiBAcGFyYW0gaW5pdGlhbCB0aGUgaW5pdGlhbCB2YWx1ZSBpbiB0aGUgc3RyZWFtLlxyXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0aW5nIHN0YXRlZnVsIHN0cmVhbS5cclxuICovXG5cbmZ1bmN0aW9uIHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoZW1pdHRlciwgaW5pdGlhbCkge1xuICByZXR1cm4gdGFwKHN0YXRlZnVsU3RyZWFtKGluaXRpYWwpLCBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNvbm5lY3QoZW1pdHRlciwgc3RyZWFtKTtcbiAgfSk7XG59XG5cbi8qKlxyXG4gKlxyXG4gKiBTdHJlYW0gdmFsdWVzIGNhbiBiZSB0cmFuc2Zvcm1lZCBhbmQgY29udHJvbGxlZCBieSB7QGxpbmsgcGlwZSB8ICoqcGlwaW5nKip9IHRocm91Z2ggKipvcGVyYXRvcnMqKi5cclxuICogdXJ4IGluY2x1ZGVzIHNldmVyYWwgb3BlcmF0b3JzIGxpa2UgW1ttYXBdXSwgW1tmaWx0ZXJdXSwgW1tzY2FuXV0sIGFuZCBbW3Rocm90dGxlVGltZV1dLlxyXG4gKiBUaGUgW1t3aXRoTGF0ZXN0RnJvbV1dIG9wZXJhdG9yIGFsbG93cyB0aGUgY29tYmluYXRpb24gb2YgdmFsdWVzIGZyb20gb3RoZXIgc3RyZWFtcy5cclxuICpcclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiAvLyBjcmVhdGUgYW4gZW1pdHRlciB0aGF0IGZpcnN0IGFkZHMgMiB0byB0aGUgcGFzc2VkIHZhbHVlLCB0aGVuIG11bHRpcGxpZXMgaXQgYnkgKiAyXHJcbiAqIGNvbnN0IGJhciA9IHBpcGUoZm9vLCBtYXAodmFsdWUgPT4gdmFsdWUgKyAyKSwgbWFwKHZhbHVlID0+IHZhbHVlICogMikpXHJcbiAqIHN1YnNjcmliZShiYXIsIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSlcclxuICogcHVibGlzaChmb28sIDIpIC8vIG91dHB1dHMgOFxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIEltcGxlbWVudGluZyBDdXN0b20gT3BlcmF0b3JzXHJcbiAqIFRvIGltcGxlbWVudCB5b3VyIG93biBvcGVyYXRvcnMsIGltcGxlbWVudCB0aGUgW1tPcGVyYXRvcl1dIGludGVyZmFjZS5cclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuXG5mdW5jdGlvbiBjb21iaW5lT3BlcmF0b3JzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3BlcmF0b3JzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG9wZXJhdG9yc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHJldHVybiBvcGVyYXRvcnMucmVkdWNlUmlnaHQodGhydXNoLCBzdWJzY3JpYmVyKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGlwZShzb3VyY2UpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBvcGVyYXRvcnMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIG9wZXJhdG9yc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICB2YXIgcHJvamVjdCA9IGNvbWJpbmVPcGVyYXRvcnMuYXBwbHkodm9pZCAwLCBvcGVyYXRvcnMpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlKHNvdXJjZSwgcHJvamVjdChzdWJzY3JpcHRpb24pKTtcblxuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgcmVzZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgYWN0aW9uIFwiICsgYWN0aW9uKTtcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogVGhlIGRlZmF1bHQgW1tDb21wYXJhdG9yXV0gZm9yIFtbZGlzdGluY3RVbnRpbENoYW5nZWRdXSBhbmQgW1tkdWNdXS5cclxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKHByZXZpb3VzLCBuZXh0KSB7XG4gIHJldHVybiBwcmV2aW91cyA9PT0gbmV4dDtcbn1cbi8qKlxyXG4gKiBGaWx0ZXJzIG91dCBpZGVudGljYWwgdmFsdWVzLiBQYXNzIGFuIG9wdGlvbmFsIFtbQ29tcGFyYXRvcl1dIGlmIHlvdSBuZWVkIHRvIGZpbHRlciBub24tcHJpbWl0aXZlIHZhbHVlcy5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiBzdWJzY3JpYmUoXHJcbiAqICBwaXBlKGZvbywgZGlzdGluY3RVbnRpbENoYW5nZWQoKSksXHJcbiAqICBjb25zb2xlLmxvZ1xyXG4gKiApIC8vIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZVxyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgNDIpXHJcbiAqIHB1Ymxpc2goZm9vLCA0MilcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJhdG9yKSB7XG4gIGlmIChjb21wYXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gIH1cblxuICB2YXIgY3VycmVudDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICBpZiAoIWNvbXBhcmF0b3IoY3VycmVudCwgbmV4dCkpIHtcbiAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIGRvbmUobmV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBGaWx0ZXJzIG91dCB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBwcmVkaWNhdG9yIGRvZXMgbm90IHJldHVybiBgdHJ1ZWAtaXNoLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIHN1YnNjcmliZShcclxuICogIHBpcGUoZm9vLCBmaWx0ZXIodmFsdWUgPT4gdmFsdWUgJSAyID09PSAwKSksXHJcbiAqICBjb25zb2xlLmxvZ1xyXG4gKiApIC8vIHdpbGwgYmUgY2FsbGVkIG9ubHkgd2l0aCBldmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgMilcclxuICogcHVibGlzaChmb28sIDMpXHJcbiAqIHB1Ymxpc2goZm9vLCA0KVxyXG4gKiBwdWJsaXNoKGZvbywgNSlcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHByZWRpY2F0ZSh2YWx1ZSkgJiYgZG9uZSh2YWx1ZSk7XG4gICAgfTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBNYXBzIHZhbHVlcyB1c2luZyB0aGUgcHJvdmlkZWQgcHJvamVjdCBmdW5jdGlvbi5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiBzdWJzY3JpYmUoXHJcbiAqICBwaXBlKGZvbywgbWFwKHZhbHVlID0+IHZhbHVlICogMikpLFxyXG4gKiAgY29uc29sZS5sb2dcclxuICogKSAvLyA0LCA2XHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCAyKVxyXG4gKiBwdWJsaXNoKGZvbywgMylcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBtYXAocHJvamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gY29tcG9zZShkb25lLCBwcm9qZWN0KTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBNYXBzIHZhbHVlcyB0byB0aGUgaGFyZC1jb2RlZCB2YWx1ZS5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiBzdWJzY3JpYmUoXHJcbiAqICBwaXBlKGZvbywgbWFwVG8oMykpLFxyXG4gKiAgY29uc29sZS5sb2dcclxuICogKSAvLyAzLCAzXHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCAxKVxyXG4gKiBwdWJsaXNoKGZvbywgMilcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBtYXBUbyh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRvbmUodmFsdWUpO1xuICAgIH07XG4gIH07XG59XG4vKipcclxuICogV29ya3MgbGlrZSBBcnJheSNyZWR1Y2UuXHJcbiAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb24gdGhlIGVtaXR0ZXIsIGFuZCBvdXRwdXRzIGludGVybWVkaWF0ZSByZXN1bHQuIFN0YXJ0cyB3aXRoIHRoZSBpbml0aWFsIHZhbHVlLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIHN1YnNjcmliZShcclxuICogIHBpcGUoZm9vLCBzY2FuKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZSwgMiksXHJcbiAqICBjb25zb2xlLmxvZ1xyXG4gKiApIC8vIDMsIDVcclxuICpcclxuICogcHVibGlzaChmb28sIDEpXHJcbiAqIHB1Ymxpc2goZm9vLCAyKVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIHNjYW4oc2Nhbm5lciwgaW5pdGlhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZG9uZShpbml0aWFsID0gc2Nhbm5lcihpbml0aWFsLCB2YWx1ZSkpO1xuICAgIH07XG4gIH07XG59XG4vKipcclxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdmFsdWVzIGZyb20gdGhlIGVtaXR0ZXIuXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KClcclxuICpcclxuICogc3Vic2NyaWJlKFxyXG4gKiAgcGlwZShmb28sIHNraXAoMikpLFxyXG4gKiAgY29uc29sZS5sb2dcclxuICogKSAvLyAzLCA0XHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCAxKSAvLyBza2lwcGVkXHJcbiAqIHB1Ymxpc2goZm9vLCAyKSAvLyBza2lwcGVkXHJcbiAqIHB1Ymxpc2goZm9vLCAzKVxyXG4gKiBwdWJsaXNoKGZvbywgNClcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBza2lwKHRpbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRpbWVzID4gMCA/IHRpbWVzLS0gOiBkb25lKHZhbHVlKTtcbiAgICB9O1xuICB9O1xufVxuLyoqXHJcbiAqIFRocm90dGxlcyBmbG93aW5nIHZhbHVlcyBhdCB0aGUgcHJvdmlkZWQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxyXG4gKiBbVGhyb3R0bGUgVlMgRGVib3VuY2UgaW4gU09dKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1OTkxMzY3L2RpZmZlcmVuY2UtYmV0d2Vlbi10aHJvdHRsaW5nLWFuZC1kZWJvdW5jaW5nLWEtZnVuY3Rpb24pLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiAgY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKiAgcHVibGlzaChmb28sIDEpXHJcbiAqXHJcbiAqICBzZXRUaW1lb3V0KCgpID0+IHB1Ymxpc2goZm9vLCAyKSwgMjApXHJcbiAqICBzZXRUaW1lb3V0KCgpID0+IHB1Ymxpc2goZm9vLCAzKSwgMjApXHJcbiAqXHJcbiAqICBzdWJzY3JpYmUocGlwZShmb28sIHRocm90dGxlVGltZSg1MCkpLCB2YWwgPT4ge1xyXG4gKiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDNcclxuICogIH0pXHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gdGhyb3R0bGVUaW1lKGludGVydmFsKSB7XG4gIHZhciBjdXJyZW50VmFsdWU7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRvbmUoY3VycmVudFZhbHVlKTtcbiAgICAgIH0sIGludGVydmFsKTtcbiAgICB9O1xuICB9O1xufVxuLyoqXHJcbiAqIERlYm91bmNlcyBmbG93aW5nIHZhbHVlcyBhdCB0aGUgcHJvdmlkZWQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxyXG4gKiBbVGhyb3R0bGUgVlMgRGVib3VuY2UgaW4gU09dKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1OTkxMzY3L2RpZmZlcmVuY2UtYmV0d2Vlbi10aHJvdHRsaW5nLWFuZC1kZWJvdW5jaW5nLWEtZnVuY3Rpb24pLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiAgY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKiAgcHVibGlzaChmb28sIDEpXHJcbiAqXHJcbiAqICBzZXRUaW1lb3V0KCgpID0+IHB1Ymxpc2goZm9vLCAyKSwgMjApXHJcbiAqICBzZXRUaW1lb3V0KCgpID0+IHB1Ymxpc2goZm9vLCAzKSwgMjApXHJcbiAqXHJcbiAqICBzdWJzY3JpYmUocGlwZShmb28sIGRlYm91bmNlVGltZSg1MCkpLCB2YWwgPT4ge1xyXG4gKiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDNcclxuICogIH0pXHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gZGVib3VuY2VUaW1lKGludGVydmFsKSB7XG4gIHZhciBjdXJyZW50VmFsdWU7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoY3VycmVudFZhbHVlKTtcbiAgICAgIH0sIGludGVydmFsKTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gd2l0aExhdGVzdEZyb20oKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHNvdXJjZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoc291cmNlcy5sZW5ndGgpO1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIHBlbmRpbmdDYWxsID0gbnVsbDtcbiAgdmFyIGFsbENhbGxlZCA9IE1hdGgucG93KDIsIHNvdXJjZXMubGVuZ3RoKSAtIDE7XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlLCBpbmRleCkge1xuICAgIHZhciBiaXQgPSBNYXRoLnBvdygyLCBpbmRleCk7XG4gICAgc3Vic2NyaWJlKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcHJldkNhbGxlZCA9IGNhbGxlZDtcbiAgICAgIGNhbGxlZCA9IGNhbGxlZCB8IGJpdDtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHByZXZDYWxsZWQgIT09IGFsbENhbGxlZCAmJiBjYWxsZWQgPT09IGFsbENhbGxlZCAmJiBwZW5kaW5nQ2FsbCkge1xuICAgICAgICBwZW5kaW5nQ2FsbCgpO1xuICAgICAgICBwZW5kaW5nQ2FsbCA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgY2FsbCA9IGZ1bmN0aW9uIGNhbGwoKSB7XG4gICAgICAgIHJldHVybiBkb25lKFt2YWx1ZV0uY29uY2F0KHZhbHVlcykpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGNhbGxlZCA9PT0gYWxsQ2FsbGVkKSB7XG4gICAgICAgIGNhbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdDYWxsID0gY2FsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcclxuICogVHJhbnNmb3JtZXJzIGNoYW5nZSBhbmQgY29tYmluZSBzdHJlYW1zLCBzaW1pbGFyIHRvIG9wZXJhdG9ycy5cclxuICogdXJ4IGNvbWVzIHdpdGggdHdvIGNvbWJpbmF0b3JzIC0gW1tjb21iaW5lTGF0ZXN0XV0gYW5kIFtbbWVyZ2VdXSwgYW5kIG9uZSBjb252ZW5pZW5jZSBmaWx0ZXIgLSBbW2R1Y11dLlxyXG4gKlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXG4vKipcclxuICogTWVyZ2VzIG9uZSBvciBtb3JlIGVtaXR0ZXJzIGZyb20gdGhlIHNhbWUgdHlwZSBpbnRvIGEgbmV3IEVtaXR0ZXIgd2hpY2ggZW1pdHMgdmFsdWVzIGZyb20gYW55IG9mIHRoZSBzb3VyY2UgZW1pdHRlcnMuXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KClcclxuICogY29uc3QgYmFyID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiBzdWJzY3JpYmUobWVyZ2UoZm9vLCBiYXIpLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSkgLy8gNDIsIDQzXHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCA0MilcclxuICogcHVibGlzaChiYXIsIDQzKVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24sIHN1YnNjcmlwdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgcmV0dXJuIGpvaW5Qcm9jLmFwcGx5KHZvaWQgMCwgc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoc291cmNlLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9KSk7XG5cbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmcsIHdlIGFyZSBzdGF0ZWxlc3NcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgYWN0aW9uIFwiICsgYWN0aW9uKTtcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogQSBjb252ZW5pZW5jZSB3cmFwcGVyIHRoYXQgZW1pdHMgb25seSB0aGUgZGlzdGluY3QgdmFsdWVzIGZyb20gdGhlIHBhc3NlZCBFbWl0dGVyLiBXcmFwcyBbW3BpcGVdXSBhbmQgW1tkaXN0aW5jdFVudGlsQ2hhbmdlZF1dLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIC8vIHRoaXMgbGluZS4uLlxyXG4gKiBjb25zdCBhID0gZHVjKGZvbylcclxuICpcclxuICogLy8gaXMgZXF1aXZhbGVudCB0byB0aGlzXHJcbiAqIGNvbnN0IGIgPSBwaXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGZvbykpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgZW1pdHRlci5cclxuICogQHBhcmFtIGNvbXBhcmF0b3Igb3B0aW9uYWwgY3VzdG9tIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIHRoZSB0d28gdmFsdWVzLlxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIFQgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZS5cclxuICpcclxuICogQHJldHVybnMgdGhlIHJlc3VsdGluZyBlbWl0dGVyLlxyXG4gKi9cblxuZnVuY3Rpb24gZHVjKHNvdXJjZSwgY29tcGFyYXRvcikge1xuICBpZiAoY29tcGFyYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIHBpcGUoc291cmNlLCBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJhdG9yKSk7XG59XG5mdW5jdGlvbiBjb21iaW5lTGF0ZXN0KCkge1xuICB2YXIgaW5uZXJTdWJqZWN0ID0gc3RyZWFtKCk7XG5cbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBlbWl0dGVycyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGVtaXR0ZXJzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGVtaXR0ZXJzLmxlbmd0aCk7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgYWxsQ2FsbGVkID0gTWF0aC5wb3coMiwgZW1pdHRlcnMubGVuZ3RoKSAtIDE7XG4gIGVtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSwgaW5kZXgpIHtcbiAgICB2YXIgYml0ID0gTWF0aC5wb3coMiwgaW5kZXgpO1xuICAgIHN1YnNjcmliZShzb3VyY2UsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgY2FsbGVkID0gY2FsbGVkIHwgYml0O1xuXG4gICAgICBpZiAoY2FsbGVkID09PSBhbGxDYWxsZWQpIHtcbiAgICAgICAgcHVibGlzaChpbm5lclN1YmplY3QsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBpZiAoY2FsbGVkID09PSBhbGxDYWxsZWQpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24odmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmUoaW5uZXJTdWJqZWN0LCBzdWJzY3JpcHRpb24pO1xuXG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICByZXR1cm4gcmVzZXQoaW5uZXJTdWJqZWN0KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGFjdGlvbiBcIiArIGFjdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcclxuICogYHN5c3RlbWAgZGVmaW5lcyBhIHNwZWNpZmljYXRpb24gb2YgYSBzeXN0ZW0gLSBpdHMgY29uc3RydWN0b3IsIGRlcGVuZGVuY2llcyBhbmQgaWYgaXQgc2hvdWxkIGFjdCBhcyBhIHNpbmdsZXRvbiBpbiBhIHN5c3RlbSBkZXBlbmRlbmN5IHRyZWUuXHJcbiAqIFdoZW4gY2FsbGVkLCBzeXN0ZW0gcmV0dXJucyBhIFtbU3lzdGVtU3BlY11dLCB3aGljaCBpcyB0aGVuIGluaXRpYWxpemVkIGFsb25nIHdpdGggaXRzIGRlcGVuZGVuY2llcyBieSBwYXNzaW5nIGl0IHRvIFtbaW5pdF1dLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBAaW1wb3J0IHsgc3Vic2NyaWJlLCBwdWJsaXNoLCBzeXN0ZW0sIGluaXQsIHR1cCwgY29ubmVjdCwgbWFwLCBwaXBlIH0gZnJvbSAndXJ4J1xyXG4gKlxyXG4gKiAvLyBhIHNpbXBsZSBzeXN0ZW0gd2l0aCB0d28gc3RyZWFtc1xyXG4gKiBjb25zdCBzeXMxID0gc3lzdGVtKCgpID0+IHtcclxuICogIGNvbnN0IGEgPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqICBjb25zdCBiID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiAgY29ubmVjdChwaXBlKGEsIG1hcCh2YWx1ZSA9PiB2YWx1ZSAqIDIpKSwgYilcclxuICogIHJldHVybiB7IGEsIGIgfVxyXG4gKiB9KVxyXG4gKlxyXG4gKiAvLyBhIHNlY29uZCBzeXN0ZW0gd2hpY2ggZGVwZW5kcyBvbiB0aGUgc3RyZWFtcyBmcm9tIHRoZSBmaXJzdCBvbmVcclxuICogY29uc3Qgc3lzMiA9IHN5c3RlbSgoWyB7YSwgYn0gXSkgPT4ge1xyXG4gKiAgY29uc3QgYyA9IHN0cmVhbTxudW1iZXI+KClcclxuICogIGNvbm5lY3QocGlwZShiLCBtYXAodmFsdWUgPT4gdmFsdWUgKiAyKSksIGMpXHJcbiAqICAvLyByZS1leHBvcnQgdGhlIGBhYCBzdHJlYW0sIGtlZXAgYGJgIGludGVybmFsXHJcbiAqICByZXR1cm4geyBhLCBjIH1cclxuICogfSwgdHVwKHN5czEpKVxyXG4gKlxyXG4gKiAvLyBpbml0IHdpbGwgcmVjdXJzaXZlbHkgaW5pdGlhbGl6ZSBzeXMyIGRlcGVuZGVuY2llcywgaW4gdGhpcyBjYXNlIHN5czFcclxuICogY29uc3QgeyBhLCBjIH0gPSBpbml0KHN5czIpXHJcbiAqIHN1YnNjcmliZShjLCBjID0+IGNvbnNvbGUubG9nKGBWYWx1ZSBtdWx0aXBsaWVkIGJ5IDRgLCBjKSlcclxuICogcHVibGlzaChhLCAyKVxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIyBTaW5nbGV0b25zIGluIERlcGVuZGVuY3kgVHJlZVxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBzeXN0ZW1zIHdpbGwgYmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlIGlmIGVuY291bnRlcmVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBkZXBlbmRlbmN5IHRyZWUuXHJcbiAqIEluIHRoZSBiZWxvdyBkZXBlbmRlbmN5IHN5c3RlbSB0cmVlLCBzeXN0ZW1zIGBiYCBhbmQgYGNgIHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBzdHJlYW0gaW5zdGFuY2VzIGZyb20gc3lzdGVtIGBhYCB3aGVuIHN5c3RlbSBgZGAgaXMgaW5pdGlhbGl6ZWQuXHJcbiAqIGBgYHR4dFxyXG4gKiAgIGFcclxuICogIC8gXFxcclxuICogYiAgIGNcclxuICogIFxcIC9cclxuICogICBkXHJcbiAqIGBgYFxyXG4gKiBJZiBgYWAgZ2V0cyBge3NpbmdsZXRvbjogZmFsc2V9YCBhcyBhIGxhc3QgYXJndW1lbnQsIGBpbml0YCBjcmVhdGVzIHR3byBzZXBhcmF0ZSBpbnN0YW5jZXMgLSBvbmUgZm9yIGBiYCBhbmQgb25lIGZvciBgY2AuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb25zdHJ1Y3RvciB0aGUgc3lzdGVtIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBJbml0aWFsaXplIGFuZCBjb25uZWN0IHRoZSBzdHJlYW1zIGluIGl0cyBib2R5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGVwZW5kZW5jaWVzIHRoZSBzeXN0ZW0gZGVwZW5kZW5jaWVzLCB3aGljaCB0aGUgY29uc3RydWN0b3Igd2lsbCByZWNlaXZlIGFzIGFyZ3VtZW50cy5cclxuICogVXNlIHRoZSBbW3R1cF1dIHV0aWxpdHkgKipGb3IgVHlwZVNjcmlwdCB0eXBlIGluZmVyZW5jZSB0byB3b3JrIGNvcnJlY3RseSoqLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBzeXMzID0gc3lzdGVtKCgpID0+IHsgLi4uIH0sIHR1cChzeXMyLCBzeXMxKSlcclxuICogYGBgXHJcbiAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVycyBPcHRpb25zXHJcbiAqIEBwYXJhbSBzaW5nbGV0b24gZGV0ZXJtaW5lcyBpZiB0aGUgc3lzdGVtIHdpbGwgYWN0IGFzIGEgc2luZ2xldG9uIGluIGEgc3lzdGVtIGRlcGVuZGVuY3kgdHJlZS4gYHRydWVgIGJ5IGRlZmF1bHQuXHJcbiAqL1xuZnVuY3Rpb24gc3lzdGVtKGNvbnN0cnVjdG9yLCBkZXBlbmRlbmNpZXMsIF90ZW1wKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge1xuICAgIHNpbmdsZXRvbjogdHJ1ZVxuICB9IDogX3RlbXAsXG4gICAgICBzaW5nbGV0b24gPSBfcmVmLnNpbmdsZXRvbjtcblxuICByZXR1cm4ge1xuICAgIGlkOiBpZCgpLFxuICAgIGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3RvcixcbiAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICBzaW5nbGV0b246IHNpbmdsZXRvblxuICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuXG52YXIgaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgcmV0dXJuIFN5bWJvbCgpO1xufTtcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIFtbU3lzdGVtU3BlY11dIGJ5IHJlY3Vyc2l2ZWx5IGluaXRpYWxpemluZyBpdHMgZGVwZW5kZW5jaWVzLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiAvLyBhIHNpbXBsZSBzeXN0ZW0gd2l0aCB0d28gc3RyZWFtc1xyXG4gKiBjb25zdCBzeXMxID0gc3lzdGVtKCgpID0+IHtcclxuICogIGNvbnN0IGEgPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqICBjb25zdCBiID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiAgY29ubmVjdChwaXBlKGEsIG1hcCh2YWx1ZSA9PiB2YWx1ZSAqIDIpKSwgYilcclxuICogIHJldHVybiB7IGEsIGIgfVxyXG4gKiB9KVxyXG4gKlxyXG4gKiBjb25zdCB7IGEsIGIgfSA9IGluaXQoc3lzMSlcclxuICogc3Vic2NyaWJlKGIsIGIgPT4gY29uc29sZS5sb2coYikpXHJcbiAqIHB1Ymxpc2goYSwgMilcclxuICogYGBgXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRoZSBbW1N5c3RlbV1dIGNvbnN0cnVjdGVkIGJ5IHRoZSBzcGVjIGNvbnN0cnVjdG9yLlxyXG4gKiBAcGFyYW0gc3lzdGVtU3BlYyB0aGUgc3lzdGVtIHNwZWMgdG8gaW5pdGlhbGl6ZS5cclxuICovXG5cblxuZnVuY3Rpb24gaW5pdChzeXN0ZW1TcGVjKSB7XG4gIHZhciBzaW5nbGV0b25zID0gbmV3IE1hcCgpO1xuXG4gIHZhciBfaW5pdCA9IGZ1bmN0aW9uIF9pbml0KF9yZWYyKSB7XG4gICAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICAgIGNvbnN0cnVjdG9yID0gX3JlZjIuY29uc3RydWN0b3IsXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IF9yZWYyLmRlcGVuZGVuY2llcyxcbiAgICAgICAgc2luZ2xldG9uID0gX3JlZjIuc2luZ2xldG9uO1xuXG4gICAgaWYgKHNpbmdsZXRvbiAmJiBzaW5nbGV0b25zLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b25zLmdldChpZCk7XG4gICAgfVxuXG4gICAgdmFyIHN5c3RlbSA9IGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfaW5pdChlKTtcbiAgICB9KSk7XG5cbiAgICBpZiAoc2luZ2xldG9uKSB7XG4gICAgICBzaW5nbGV0b25zLnNldChpZCwgc3lzdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3lzdGVtO1xuICB9O1xuXG4gIHJldHVybiBfaW5pdChzeXN0ZW1TcGVjKTtcbn1cblxuZXhwb3J0IHsgYWx3YXlzLCBjYWxsLCBjb21iaW5lTGF0ZXN0LCBjb21wb3NlLCBjb25uZWN0LCBjdXJyeTF0bzAsIGN1cnJ5MnRvMSwgZGVib3VuY2VUaW1lLCBkZWZhdWx0Q29tcGFyYXRvciwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGR1YywgZXZlbnRIYW5kbGVyLCBmaWx0ZXIsIGdldFZhbHVlLCBoYW5kbGVOZXh0LCBpbml0LCBqb2luUHJvYywgbWFwLCBtYXBUbywgbWVyZ2UsIG5vb3AsIHBpcGUsIHByb3AsIHB1Ymxpc2gsIHJlc2V0LCBzY2FuLCBza2lwLCBzdGF0ZWZ1bFN0cmVhbSwgc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlciwgc3RyZWFtLCBzdHJlYW1Gcm9tRW1pdHRlciwgc3Vic2NyaWJlLCBzeXN0ZW0sIHRhcCwgdGhyb3R0bGVUaW1lLCB0aHJ1c2gsIHR1cCwgd2l0aExhdGVzdEZyb20gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyeC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@virtuoso.dev/urx/dist/urx.esm.js\n");

/***/ })

};
;